<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IOS | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2014-05-20T16:41:49+08:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Perceptual Hash Algorithm in Objective C]]></title>
    <link href="http://pbking1.github.com/blog/2014/05/19/perceptual-hash-algorithm-in-objective-c/"/>
    <updated>2014-05-19T17:47:06+08:00</updated>
    <id>http://pbking1.github.com/blog/2014/05/19/perceptual-hash-algorithm-in-objective-c</id>
    <content type="html"><![CDATA[<h4>此文为借鉴阮一峰2011年和2013年发布的相似图片搜索原理</h4>

<ul>
<li>原文已经写得很好了，所以我只是把它整理了一下，学习学习~~</li>
</ul>


<h3>又名感知哈希算法</h3>

<ul>
<li>主要思想是

<ul>
<li>对每个图片生成一个“指纹”字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似</li>
</ul>
</li>
<li>这种算法的优点是简单快速，不收图片大小缩放的影响

<ul>
<li>缺点是图片内容不能变更。如果在图片上加几个文字，他就认不出来了</li>
</ul>
</li>
<li>因此最佳应用应该是根据缩略图找出原图</li>
</ul>


<!--more-->


<ul>
<li>算法样例

<ul>
<li>第一步 缩小尺寸

<ul>
<li>把图片缩小大8*8的尺寸，总共有64个像素。这一步的作用是去除图片的细节，只保留结构，明暗等基本信息，摒弃不同的尺寸，比例带来的图片差异</li>
</ul>
</li>
<li>第二步 简化色彩

<ul>
<li>将缩小之后的图片转为64级灰度。也就是说，所有的像素点总共之后64中颜色</li>
</ul>
</li>
<li>第三步 计算平均值

<ul>
<li>计算所有64个像素的灰度平均值</li>
</ul>
</li>
<li>第四步 比较像素的灰度

<ul>
<li>把每个像素的灰度，和平均值进行比较。大于或者等于平均值的，记为1；小于平均值，记为0；</li>
</ul>
</li>
<li>第五步 计算hash值

<ul>
<li>把上一步比较的结果，组合在一起，就构成一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片采用同样的次序就行了。</li>
<li>hash_value = 127ysje82ewrdfw3(16个数字)</li>
<li>这个值也就是指纹</li>
<li>得到指纹之后就可以对比不同的图片，看看64为中有多少位是不一样的。理论上，这等同与计算”汉明距离“。如果不相同的数据位不超过5，这就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>网上其他两种类似的算法</h3>

<h4>颜色分布法</h4>

<ul>
<li>每张图片都可以生成颜色分布的直方图。如果两种那个图片的直方图很接近，那么就可以认为他们很相似</li>
<li>由于任何一种颜色都是有红绿蓝三原色（RGB）构成的，所以可以画出四幅图（三原色直方图和最后合成的直方图）</li>
<li>如果每种原色都可以取256个值，那么整个颜色空间共有1600万种颜色（256的三次方）。针对这1600万种颜色比较直方图，计算量实在太大了，因此需要采用简化方法。可以将0～255分成四个区：0～63为第0区，64～127为第1区，128～191为第2区，192～255为第3区。这意味着红绿蓝分别有4个区，总共可以构成64种组合（4的3次方）。</li>
<li>任何一种颜色必然属于这64种组合中的一种，这样就可以统计每一种组合包含的像素数量。</li>
<li><img src="/images/oc_algorithm1.png"></li>
<li>上图是某张图片的颜色分布表，将表中最后一栏提取出来，组成一个64维向量(7414, 230, 0, 0, 8, &hellip;, 109, 0, 0, 3415, 53929)。这个向量就是这张图片的特征值或者叫"指纹"。</li>
<li>于是，寻找相似图片就变成了找出与其最相似的向量。这可以用皮尔逊相关系数或者余弦相似度算出。</li>
</ul>


<h4>内容特征法</h4>

<ul>
<li>除了颜色构成还可以从比较图片内容的相似性入手</li>
<li>首先

<ul>
<li>把图片装成一张比较小的灰度图片，假设为50*50像素。然后，确定一个阀值，把灰度图片转成黑白图片</li>
</ul>
</li>
<li>其次

<ul>
<li>如果两张图片很相似，那么他们的黑白轮廓应该是相近的。因此，问题就变成了如何去顶一个合理的阀值，正确的呈现图片中的轮廓</li>
</ul>
</li>
<li>因此

<ul>
<li><strong>前景色和背景色反差越大，轮廓就越明显</strong></li>
<li>这意味着，如果我们找到一个值，可以使得前景色和背景色格子的“类内差异最小”，或者“类间差异最大”，那么这个值就是理想的阀值</li>
</ul>
</li>
<li>后来因为有个如本的学者叫大津展之证明了两个是一样的，可以用他的“大津法”来求阀值

<ul>
<li>假定一张图片共有n个像素，其中灰度值小于阈值的像素为 n1 个，大于等于阈值的像素为 n2 个（ n1 + n2 = n ）。w1 和 w2 表示这两种像素各自的比重。

<ul>
<li>w1 = n1 / n</li>
<li>w2 = n2 / n</li>
</ul>
</li>
<li>再假定，所有灰度值小于阈值的像素的平均值和方差分别为 μ1 和 σ1，所有灰度值大于等于阈值的像素的平均值和方差分别为 μ2 和 σ2。于是，可以得到

<ul>
<li>类内差异 = w1(σ1的平方) + w2(σ2的平方)
　　      &ndash; 类间差异 = w1w2(μ1-μ2)^</li>
</ul>
</li>
<li>可以证明，这两个式子是等价的：得到"类内差异"的最小值，等同于得到"类间差异"的最大值。不过，从计算难度看，后者的计算要容易一些。</li>
<li>下一步用"穷举法"，将阈值从灰度的最低值到最高值，依次取一遍，分别代入上面的算式。使得"类内差异最小"或"类间差异最大"的那个值，就是最终的阈值.</li>
<li><p>有了50x50像素的黑白缩略图，就等于有了一个50x50的0-1矩阵。矩阵的每个值对应原图的一个像素，0表示黑色，1表示白色。这个矩阵就是一张图片的特征矩阵。</p></li>
<li><p>两个特征矩阵的不同之处越少，就代表两张图片越相似。这可以用"异或运算"实现（即两个值之中只有一个为1，则运算结果为1，否则运算结果为0）。对不同图片的特征矩阵进行"异或运算"，结果中的1越少，就是越相似的图片。</p></li>
</ul>
</li>
</ul>


<h3>objective c源码</h3>

<ul>
<li>tphash.h</li>
</ul>


<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface tphash : NSObject</p>

<ul>
<li>(uint64_t)ptHash:(UIImage*)image;</li>
<li>(int)hamdistance:(uint64_t)x with:(uint64_t) y;</li>
<li>(UIImage <em>)scaleImage:(UIImage </em>)image toSize(CGSize)newSize;</li>
<li>(uint64_t <em>) convertTogreyscale64Array: (UIImage </em>)i;</li>
</ul>


<p>@end
```</p>

<ul>
<li>tphash.m</li>
</ul>


<p>```</p>

<h1>import &ldquo;tphash.h&rdquo;</h1>

<p>@implementation tphash</p>

<ul>
<li><p>(uint64_t)ptHash:(UIImage <em>)image{
  image = [self scaleImage:image toSize:CGSizeMake(8,8)];
  uint64_t</em> imageArray = [self convertTogreyscale64Array:image];
  int sum = 0;
  for(int i = 0; i &lt; 64; i++){
      sum += imageArray[i];
  }
  uint8_t avg = sum/64;
  uint64_t ret = 0;
  for(int i = 0; i &lt; 64; i++){
      if(imageArray[i] >= avg){
          ret++;
      }
      ret &lt;&lt;= 1;
  }
  return ret;
}</p></li>
<li><p>(int)hamdistance:(uint64_t)x with:(uint64_t) y{
  unsigned dist = 0, val = x<sup>y</sup>;
  while (val) {
      ++dist;
      val &amp;= val &ndash; 1;
  }
}</p></li>
<li><p>(UIImage <em>)scaleImage:(UIImage </em>)image toSize(CGSize)newSize{
  UIGraphicsBeginIMageContextWithOptions(newSize, NO, 0.0);
  [image drawInRect:CGRectMake(0,0,newSize.width, newSize.height)];
  UIImage *newImage = UIGraphicsBeginImageFromCurrentImageContext();
  UIGraphicsEndImageContext();
  return newImage;
}</p></li>
<li><p>(uint64_t <em>) convertTogreyscale64Array: (UIImage </em>)i{
  int kRed = 1;
  int kGreen = 2;
  int kBlue = 4;</p>

<p>  int colors = kGreen;
  int m_width = i.size.width;
  int m_height = i.size.height;</p>

<p>  uint32_t <em>rgbImage = (uint32_t </em>) malloc(m_width * meight * sizeof(uint32_t));
  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
  CGContextRef context = CGBitmapContextCreate(rgbImage, m_width, m_height, 8, m_width * 4, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);
  CGContextSetInterpolationQuality(context, kCGInterpolationHigh);
  CGContextSetShouldAntialias(context, NO);
  CGContextDrawImage(context, CGRectMake(0, 0, m_width, m_height), [i CGImage]);
  CGContextRelease(context);
  CGColorSpaceRelease(colorSpace);</p>

<p>  uint8_t <em>m_imageData = (uint8_t </em>) malloc(m_width * m_height);
  for(int y = 0; y &lt; m_height; y++) {
      for(int x = 0; x &lt; m_width; x++) {
          uint32_t rgbPixel=rgbImage[y<em>m_width+x];
          uint32_t sum=0,count=0;
          if (colors &amp; kRed) {sum += (rgbPixel>>24)&255; count++;}
          if (colors &amp; kGreen) {sum += (rgbPixel>>16)&255; count++;}
          if (colors &amp; kBlue) {sum += (rgbPixel>>8)&255; count++;}
          m_imageData[y</em>m_width+x]=sum/count/4;
      }
  }
  free(rgbImage);
  return m_imageData;
}
@end</p></li>
</ul>


<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS Tutorial 3 Tabhost]]></title>
    <link href="http://pbking1.github.com/blog/2014/05/14/ios-tutorial-3-tabhost/"/>
    <updated>2014-05-14T21:25:25+08:00</updated>
    <id>http://pbking1.github.com/blog/2014/05/14/ios-tutorial-3-tabhost</id>
    <content type="html"><![CDATA[<h3>源代码</h3>

<ul>
<li>把数据载入到tableview中，，点击某一个item就可以出发alert对话框。</li>
<li>Cell 的样式也是可以自定义的

<ul>
<li>通过UITableViewCell来设置样式</li>
</ul>
</li>
<li>在<code>AppDelegate.h</code>中</li>
<li>加入mainView的声明

<ul>
<li><strong>注意要加<code>#import "ViewController.h"</code></strong></li>
</ul>
</li>
</ul>


<!--more-->


<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<p>@interface AppDelegate : UIResponder <UIApplicationDelegate></p>

<p>@property (strong, nonatomic) UIWindow <em>window;
@property (strong, nonatomic) ViewController </em>mainView;</p>

<p>@end
<code>``
- 在</code>AppDelegate.m`中加入以下代码</p>

<p>```
&ndash; (void)dealloc
{</p>

<pre><code>[_window release];
[_mainView release];
[super dealloc];
</code></pre>

<p>}</p>

<ul>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease];
  self.mainView = [[[ViewController alloc] init] autorelease];</p>

<p>  self.window.rootViewController = self.mainView;
  [self.window makeKeyAndVisible];
  // Override point for customization after application launch.
  return YES;
}
```</p></li>
<li>修改<code>ViewController.h</code></li>
</ul>


<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface ViewController : UIViewController&lt;UITableViewDataSource, UITableViewDelegate></p>

<p>@property (nonatomic, retain) NSMutableArray <em>datalist;
@property (nonatomic, retain) UITableView </em>myTableView;</p>

<p>@end</p>

<p>```</p>

<ul>
<li>文件<code>ViewController.m</code>如下</li>
</ul>


<p>```</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController
@synthesize datalist;
@synthesize myTableView;</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.
  NSMutableArray *list = [NSArray arrayWithObjects:@&ldquo;武汉&rdquo;,@&ldquo;上海&rdquo;,@&ldquo;北京&rdquo;,@&ldquo;深圳&rdquo;,@&ldquo;广州&rdquo;,@&ldquo;重庆&rdquo;,@&ldquo;香港&rdquo;,@&ldquo;台海&rdquo;,@&ldquo;天津&rdquo;, nil];
  self.datalist = list;</p>

<p>  UITableView *tableview = [[[UITableView alloc] initWithFrame:self.view.frame style:UITableViewStylePlain] autorelease];
  //set the data source
  tableview.dataSource = self;
  //set the delegate
  tableview.delegate = self;
  //set the background
  //tableview.backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&ldquo;Background.png&rdquo;]];
  self.myTableView = tableview;
  [self.view addSubview:myTableView];</p></li>
</ul>


<p>}</p>

<ul>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  static NSString </em>CellWithIdentifier = @&ldquo;Cell&rdquo;;
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellWithIdentifier];
  if(cell == nil){
      cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue2 reuseIdentifier:CellWithIdentifier];
  }
  NSUInteger row = [indexPath row];
  cell.textLabel.text = [self.datalist objectAtIndex:row];
  return cell;
}</p></li>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  return [self.datalist count];
}</p></li>
<li><p>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  return 70;  //设置行高
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  NSString <em>msg = [[NSString alloc] initWithFormat:@&ldquo;You choose :%@&rdquo;,  [self.datalist objectAtIndex:[indexPath row]]];
  UIAlertView </em>alert = [[UIAlertView alloc] initWithTitle:@&ldquo;Alert&rdquo; message:msg delegate:self cancelButtonTitle:@&ldquo;OK&rdquo; otherButtonTitles:nil, nil];
  [msg release];
  [alert show];
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  NSLog(@&ldquo;delete&rdquo;);  //滑动删除
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<p>@end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS Tutorial 2]]></title>
    <link href="http://pbking1.github.com/blog/2014/05/14/ios-tutorial-2/"/>
    <updated>2014-05-14T16:34:49+08:00</updated>
    <id>http://pbking1.github.com/blog/2014/05/14/ios-tutorial-2</id>
    <content type="html"><![CDATA[<ul>
<li>键盘收起以及弹出对话框</li>
<li>在<code>ViewController.h</code>里面加入<code>-(IBAction)View_TouchDown:(id)sender</code>;</li>
</ul>


<!--more-->


<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface ViewController : UIViewController</p>

<p>@property (strong, nonatomic) IBOutlet UITextField *tempText;</p>

<p>&ndash;(IBAction)showMessage;
&ndash;(IBAction)View_TouchDown:(id)sender;
@end</p>

<p><code>
- 在`ViewController.m`里面加入以下代码
</code>
&ndash; (IBAction)View_TouchDown:(id)sender
{</p>

<pre><code>[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>得到的全部代码如下</li>
</ul>


<p>```</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
<li><p>(IBAction)showMessage  //弹出对话框
{
  UIAlertView *a = [[UIAlertView alloc]
                    initWithTitle:@&ldquo;I am pb&rdquo; message:@&ldquo;hello world&rdquo; delegate:nil cancelButtonTitle:@&ldquo;I can do it&rdquo; otherButtonTitles: nil];
  [a show];
}</p></li>
<li><p>(IBAction)View_TouchDown:(id)sender
{
  [[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<ul>
<li><p>最后再在storybroad里面用outlet把整个屏幕和<code>View_TouchDown</code>连接起来就可以了</p></li>
<li><p>Touble shoot</p>

<ul>
<li>1.出现<code>'NSInternalInconsistencyException', reason: 'Could not load NIB in bundle:</code>

<ul>
<li>说明<code>self.viewController = [[[ViewController alloc] initWithNibName:@"name" bundle:nil] autorelease];</code>

<ul>
<li>里面的name写错了

<ul>
<li>要写成和ViewController一样的名字才行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS Tutorial 1]]></title>
    <link href="http://pbking1.github.com/blog/2014/05/14/ios-tutorial-1/"/>
    <updated>2014-05-14T13:11:01+08:00</updated>
    <id>http://pbking1.github.com/blog/2014/05/14/ios-tutorial-1</id>
    <content type="html"><![CDATA[<ul>
<li>1.一点基本语法</li>
<li>用NSLog打印，代替printf（也是可以用的）</li>
<li>用NSDate来获取时间</li>
<li>用NSData来把数据char*转成string存起来</li>
</ul>


<!--more-->


<ul>
<li>源码
```

<h1>import &lt;Foundation/Foundation.h></h1></li>
</ul>


<p>int main(int argc, const char * argv[])
{</p>

<pre><code>@autoreleasepool {

    // insert code here...
    NSLog(@"Hello, World!");

}
int i;
for(i = 0; i &lt;= 5; i++)
    NSLog(@"%d\n", i);

NSDate *yesterday = [NSDate dateWithTimeIntervalSinceNow:-(24*60*60)];
NSLog(@"yesterday is %@", yesterday);

NSDate *tomorrow = [NSDate dateWithTimeIntervalSinceNow:+(24*60*60)];
NSLog(@"tomorrow is %@", tomorrow);

const char *string = "Hi this is pb";
NSData *data = [NSData dataWithBytes:string length:strlen(string) + 1];
NSLog(@"data is %@", data);
NSLog(@"%lu Bytes string is '%s'", (unsigned long)[data length], [data bytes]);
return 0;
</code></pre>

<p>}
```</p>

<ul>
<li><p>2.线程的同步与锁
　　- 要说明线程的同步与锁，最好的例子可能就是多个窗口同时售票的售票系统了。我们知道在java中，使用synchronized来同步，而iphone虽然没有提供类似java下的synchronized关键字，但提供了NSCondition对象接口。</p>

<ul>
<li>查看NSCondition的接口说明可以看出，NSCondition是iphone下的锁对象，所以我们可以使用NSCondition实现iphone中的线程安全。这是来源于网上的一个例子：</li>
</ul>
</li>
<li><p>2.多个窗口同时售票的售票系统代码</p></li>
<li>AppDelegate.h</li>
</ul>


<p>```</p>

<h1>import &lt;Cocoa/Cocoa.h></h1>

<p>@interface AppDelegate : NSObject <NSApplicationDelegate>{</p>

<pre><code>int tickets;
int count;
NSThread *ticketThreadone;
NSThread *ticketThreadtwo;
NSCondition *ticketsCondition;
NSWindow *windows;
</code></pre>

<p>}</p>

<p>@property (assign) IBOutlet NSWindow *window;</p>

<p>@end</p>

<p>```</p>

<ul>
<li>AppDelegate.cpp</li>
</ul>


<p>```</p>

<h1>import &ldquo;AppDelegate.h&rdquo;</h1>

<p>@implementation AppDelegate
@synthesize window;</p>

<ul>
<li><p>(void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
  tickets = 100;
  count = 0;</p>

<p>  ticketsCondition = [[NSCondition alloc] init]; //初始化锁对象
  ticketThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; //初始化线程1
  [ticketThreadone setName:@&ldquo;Thread-1&rdquo;];
  [ticketThreadone start];</p>

<p>  ticketThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];  //初始化线程2
  [ticketThreadtwo setName:@&ldquo;Thread-2&rdquo;];
  [ticketThreadtwo start];</p>

<p>  [window makeKeyWindow];  //出错了，无法在窗口中运行，只能在命令行中运行，不知道为什么？求知道的筒子解答下~</p></li>
</ul>


<p>}</p>

<ul>
<li><p>(void)run{
  while(TRUE){
      [ticketsCondition lock];
      if(tickets > 0)
      {
          [NSThread sleepForTimeInterval:0.5];
          count = 100 &ndash; tickets;
          NSLog(@&ldquo;current tickets count are: %d, sell %d, thread name: %@&rdquo;, tickets, count, [[NSThread currentThread] name]);
          tickets&mdash;;
      }else
      {
          break;
      }
      [ticketsCondition unlock];
  }
}</p></li>
<li><p>(void)dealloc{
  [ticketThreadone release];  //释放内存
  [ticketThreadtwo release];
  [ticketsCondition release];
  [window release];
  [super dealloc];
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<ul>
<li>Trouble shooting</li>
<li><p>1.ARC forbids explicit message send of &lsquo;release&rsquo;
&lsquo;release&rsquo; is unavailable: not available in automatic reference counting mode</p>

<ul>
<li>错误原因：因为我们设置了用ARC来管理内存释放，我们却又调用了release方法去释放对象。</li>
<li>(From the Internet)

<ul>
<li>ARC是iOS 5推出的新功能，全称叫 ARC(Automatic Reference Counting)。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。该机制在 iOS 5/ Mac OS X 10.7 开始导入，利用 Xcode4.2 可以使用该机制。简单地理解ARC，就是通过指定的语法，让编译器(LLVM 3.0)在编译代码时，自动生成实例的引用计数管理部分代码。有一点，ARC并不是GC，它只是一种代码静态分析（Static Analyzer）工具。</li>
</ul>
</li>
<li>how to solve it?

<ul>
<li>找到项目中的Build setting

<ul>
<li>把<code>Objective-C Automatic Reference</code>从YES改成NO</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.找不到HOME键</p>

<ul>
<li>在模拟器上按<code>Shift+command+h</code></li>
</ul>
</li>
<li><p>3.出现<code>Auto Layout on iOS Versions prior to 6.0</code></p>

<ul>
<li>界面设置问题</li>
<li>找到storybroad

<ul>
<li>打开属性栏，把<code>Use AutoLayout</code>去掉。</li>
</ul>
</li>
</ul>
</li>
<li><p>4.ios7的全屏问题</p>

<ul>
<li>在viewcontroller里面加入以下代码
```</li>
<li><p>(void)viewDidLayoutSubviews{</p>

<p>  if ([self respondsToSelector:@selector(topLayoutGuide)]) // iOS 7 or above
  {
      CGFloat top = self.topLayoutGuide.length;
      if(self.view.frame.origin.y == 0){
          // We only want to do this once, or if the view has somehow been &quot;restored&quot; by other code.
          self.view.frame = CGRectMake(self.view.frame.origin.x, self.view.frame.origin.y + top, self.view.frame.size.width, self.view.frame.size.    height &ndash; top);
      }
  }
}
```</p></li>
<li>这个只能让上面原有的时间什么的消失，但是从根本上不能解决问题</li>
</ul>
</li>
<li><p>5.如果刚开始打开ios模拟器发现太大了</p>

<ul>
<li>再Window->scale那里可以调整成75%就可以使得模拟器看起来大小比较科学了。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
