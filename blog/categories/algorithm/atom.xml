<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-04-21T15:50:18-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T22:04:11-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<h4>little review about c++ pop</h4>

<ul>
<li>虚函数

<ul>
<li>核心理念就是基类访问派生类定义的函数</li>
<li>动态联编</li>
<li>一个函数的调用不是在编译的时候确定的，而是在运行的时候确定的，并且因为写代码的时候不能确定被调用的函数是基类的函数还是派生类的函数，所以这个函数又叫做“虚函数“</li>
<li><code>
class A{
  public:
      virtual void test(){
          cout&lt;&lt;"A:test() is called";
      }        
};
class B: public A{
  public:
      virtual void test(){
          cout&lt;&lt;"B:test() is called";
      }
};
int main(){
  A *a = new B();
  a -&gt; test();
}
</code></li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>虚函数表</p>

<ul>
<li>实现多态的主要功能</li>
<li>编译器会为每一个有虚函数的类的实例创建一个虚函数表</li>
<li>用来存虚函数的table

<ul>
<li>table的每个slot（槽）里面存放虚函数的地址</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数</p>

<ul>
<li><code>virtual void test() = 0</code></li>
<li>意思是抽象类，也可以说是接口，用来规范派生类的行为

<ul>
<li>告诉使用者我的派生类都会有这个函数</li>
</ul>
</li>
<li>虚构析函数

<ul>
<li>当一个类要被其他的类当基类使用的时候，必须是纯虚的</li>
<li>如果有两个class A和B

<ul>
<li>B继承A，但是A的构析函数没有设置成虚函数</li>
<li>那么在delete B的实例的时候，只有A的实例被delete， B的不会被delete。。。那这不是坑爹吗。。。。</li>
<li>但是再A的构析函数前面加上virtual，这样就能保证在delete B的实例的时候，两个类的构析函数都会被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>但是构造函数不能使虚函数</p></li>
</ul>


<h4>链表</h4>

<ul>
<li>链表ADT

<ul>
<li><code>
template &lt;typename E&gt; class List{
private:
  void operator = (const List &amp;){}
  List(const List&amp;){}
public:
  List(){}
  virtual ~List(){}
  virtual void clear() = 0;
  virtual void insert(const E&amp; item) = 0;
  virtual void append(const E&amp; item) = 0;
  virtual E remove() = 0;
  //move the pointer to start
  virtual void moveToStart() = 0;
  //move the pointer to end
  virtual void moveToEnd() = 0;
  virtual void prev() = 0;
  virtual void next() = 0;
  virtual int length() const = 0;
  virtual int currPos() const = 0;
  virtual void moveToPos(int pos) = 0;
  virtual const E&amp; getValue() const = 0;
};
</code></li>
</ul>
</li>
<li>数组实现

<ul>
<li><code>
template &lt;typename E&gt; class AList: public List&lt;E&gt;{
private:
  int maxSize;
  int listSize;
  int curr;
  E* listArray;   
public:
  AList(int size = 100){
      maxSize = size;
      listSize = 0;
      curr = 0;
      listArray = new E[maxSize];
  }
  ~AList(){
      delete []listArray;
  }
  void clear(){
      delete []listArray;
      listSize = 0;
      curr = 0;
      listArray = new E[maxSize];
  }
  void insert(const E&amp; it){
      for(int i = listSize; i &gt; curr; i--)
          listArray[i] = listArray[i-1];
      //move back the array from the current position
      listArray[curr] = it;
      listSize++;
  }
  void append(const E&amp; it){
      listArray[listSize++] = it;
  }
  E remove(){
      E it = listArray[curr];
      for(int i = curr; i &lt; listSize - 1; i++){
          listArray[i] = listArray[i + 1];
      }
      listSize--;
      return it;
  }
  void moveToStart(){
      curr = 0;
  }
  void moveToEnd(){
      curr = listSize;
  }
  void prev(){
      if(curr &gt; 0)
          curr--;
  }
  void next(){
      if(curr &lt; listSize)
          curr++;
  }
  int length(){
      return listSize;
  }
  int currPos() const{
      return curr;
  }
  void moveToPos(int pos){
      pos = curr;
  }
  const E&amp; getValue() const{
      return listArray[curr];
  }
};
</code></li>
</ul>
</li>
<li>链式实现</li>
</ul>


<h4>栈</h4>

<h4>队列</h4>

<h4>字典</h4>
]]></content>
  </entry>
  
</feed>
