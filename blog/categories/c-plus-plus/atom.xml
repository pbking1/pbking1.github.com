<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-02-08T19:01:17-05:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xapian_tutorial_3]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/06/xapian-tutorial-3/"/>
    <updated>2015-02-06T02:50:50-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/06/xapian-tutorial-3</id>
    <content type="html"><![CDATA[<h4>filter</h4>

<ul>
<li>There is a <code>faceted Search</code>, which is to preview the result of the query in many category.

<ul>
<li>like if we search for &lsquo;apple&rsquo;

<ul>
<li>the result may be classified into two

<ul>
<li>one is apple fruit</li>
<li>one is apple company</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>actually, this is a filter.

<ul>
<li>we can classify before index, and store into index</li>
<li>and use value to filter them when query</li>
</ul>
</li>
</ul>


<h4>how to build filter value</h4>

<ul>
<li>use <code>Document::add_value</code></li>
</ul>


<h4>how to use filter when query</h4>

<ul>
<li>two ways

<ul>
<li>one is use <code>Xapian::MatchDecider</code>, this return a bool value.

<ul>
<li>or we can use <code>Xapian::ValueSetMatchDecider</code>

<ul>
<li><code>Xapian::ValueSetMatchDecider(slot, inclusive)</code>

<ul>
<li>slot means which slot to filter</li>
<li>inclusive means using filter or reduce</li>
</ul>
</li>
<li>use <code>Xapian::ValueSetMatchDecider::add_value(string)</code>

<ul>
<li>user can decide one or many set of value

<ul>
<li>when document belong to one of these value

<ul>
<li>make it filter or stay</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>use <code>MatchSpy</code></li>
</ul>
</li>
</ul>


<h4>sample</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xapian_tutorial_2]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/05/xapian-tutorial-2/"/>
    <updated>2015-02-05T19:54:20-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/05/xapian-tutorial-2</id>
    <content type="html"><![CDATA[<h3>The expand of synonym(同义词)</h3>

<ul>
<li>such as ‘I love you‘ and &lsquo;ILU&rsquo;</li>
<li>process to do this

<ul>
<li>Write the synonym into database

<ul>
<li>use <code>WriteDatabase::add_synonym(term,synonym)</code></li>
<li>but we can only do &lsquo;I love you&rsquo; &ndash;> &lsquo;ILU&rsquo;

<ul>
<li>if we want to reverse it, we need to add the reverse version</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>use the synonym when query</h3>

<ul>
<li>use <code>QueryParser::set_database()</code> to set db</li>
<li>when using the <code>QueryParser::set_database()</code>, the second parameter use <code>FLAG_SYNONYM</code> or <code>FLAG_AUTO_SYNONYMS</code></li>
<li><code>FLAG_SYNONYM</code> is the ~WORD format in the query sentence. expend the synonym of the word automatically</li>
<li><code>FLAG_AUTO_SYNONYMS</code> is expend all the phrase, do not need to write ~</li>
</ul>


<!--more-->


<h3>sample</h3>

<ul>
<li><p>makefile</p>

<ul>
<li><p>```</p></li>
</ul>


<p>  all:
      g++ -o index -I/usr/local/include -l xapian index.cpp
      g++ -o query -I/usr/local/include -l xapian query.cpp
  clean:
      rm -rf index index_data/ query
```</p></li>
<li><p>index.cpp</p></li>
</ul>


<p>```</p>

<pre><code> #include&lt;xapian.h&gt;
 #include&lt;iostream&gt;
 #include&lt;string&gt;
 using namespace std;
 #define CONTENT "70:69， I love you This is man basketball race history the smallest point difference race ， smile to last is east man Chinese 。 Which can be said ， This time is the most famous victory and can be said this is the most lucky resuly 。After the end of the game, the coach of the Chinese aa and The boss bb hang togetherm and the two guy are so happy that the chinese win。"
 #define INDEX_PATH "./index_data"
 #define WORD1 "I love you"
 #define WORD2 "ILU"
int main(int argc, char *argv[]){
try{
    //The text to be indexed
    string content(CONTENT);

    //open a database and write
    Xapian::WritableDatabase db(string(INDEX_PATH), Xapian::DB_CREATE_OR_OPEN);

    //term generator
    Xapian::TermGenerator indexer;

    //add synonym
    db.add_synonym(string(WORD1), string(WORD2));

    //Make document
    Xapian::Document doc;
    doc.set_data(content);
    indexer.set_document(doc);
    indexer.index_text(content);

    //add document to db
    db.add_document(doc);

    //flush to disk
    db.commit();

}catch(const Xapian::Error &amp;e){
    cout&lt;&lt;e.get_description()&lt;&lt;endl;
}
return 0;}
</code></pre>

<p>```</p>

<ul>
<li>query.cpp</li>
</ul>


<p>```</p>

<pre><code> #include&lt;xapian.h&gt;
 #include&lt;iostream&gt;
 #include&lt;string&gt;
using namespace std;
 #define QUERY "~ILU AND Chinese"
 #define INDEX_PATH "./index_data"
 #define F_DOCID 1
int main(){

try{
    //The string for query
    string query_str(QUERY);
    //open the database
    Xapian::Database db(string(INDEX_PATH));

    //open search handle
    Xapian::Enquire enquire(db);

    //Parser Query
    Xapian::QueryParser qp;
    qp.set_database(db);
    Xapian::Query query = qp.parse_query(query_str, Xapian::QueryParser::FLAG_SYNONYM);
    cout&lt;&lt;"Query is "&lt;&lt;query.get_description()&lt;&lt;endl;

    //find the top 10 result
    enquire.set_query(query);
    Xapian::MSet result = enquire.get_mset(0,10);
    cout&lt;&lt;result.get_matches_estimated()&lt;&lt;" result found"&lt;&lt;endl;

    //print the result
    for(Xapian::MSetIterator iter = result.begin(); iter != result.end(); iter++){
        Xapian::Document doc = iter.get_document();
        cout&lt;&lt;iter.get_rank()&lt;&lt;": docid "&lt;&lt;doc.get_value(F_DOCID)&lt;&lt;", data"&lt;&lt;doc.get_data()&lt;&lt;endl;
    }

}catch(const Xapian::Error e){
    cout&lt;&lt;e.get_description()&lt;&lt;endl;
}
return 0;
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xapian_tutorial_1]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/05/xapian-tutorial-1/"/>
    <updated>2015-02-05T16:40:48-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/05/xapian-tutorial-1</id>
    <content type="html"><![CDATA[<ul>
<li>note:some of the content and code are refer from <a href="http://www.coder4.com/archives/2218">http://www.coder4.com/archives/2218</a></li>
</ul>


<h3>basic index build and search</h3>

<ul>
<li>first of all, xapian is an open source c++ search engine.</li>
<li>also note that xapian is called &ldquo;Zap-in&rdquo;</li>
</ul>


<!--more-->


<h4>basic data structure</h4>

<ul>
<li>used for search

<ul>
<li><code>Xapian::Database</code>

<ul>
<li>used to read index</li>
</ul>
</li>
<li><code>Xapian::Enquire</code>

<ul>
<li>use with Database</li>
<li>use to search</li>
</ul>
</li>
<li><code>Xapian::QueryParser</code>

<ul>
<li>query sentence parser</li>
</ul>
</li>
<li><code>Xapian::Query</code>

<ul>
<li>query</li>
</ul>
</li>
<li><code>Xapian::MSet</code>

<ul>
<li>the result set returned by searching</li>
</ul>
</li>
</ul>
</li>
<li>used for build index

<ul>
<li><code>Xapian::WritableDatabase</code>

<ul>
<li>use for built index</li>
</ul>
</li>
<li><code>Xapian::TermGenerator</code>

<ul>
<li>use for cut sentence, build index.</li>
</ul>
</li>
</ul>
</li>
<li>for both

<ul>
<li><code>Xapian::Document</code>

<ul>
<li>abstract of document</li>
</ul>
</li>
<li> <code>Xapian::SimpleStopper</code>

<ul>
<li> the word used for ending</li>
</ul>
</li>
<li> <code>Xapian::Error</code>

<ul>
<li> exception</li>
<li> use get_description() to get detailed info.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>how to build index</h4>

<ul>
<li>open a <code>Xapian::WritableDatabase</code></li>
<li>Then prepare for the document

<ul>
<li>use <code>set_data(string)</code> to set data(only one)</li>
<li>use <code>add_value(slot, string)</code> to set field(can have more), slot can not be -1</li>
<li>these two method is only used for storage

<ul>
<li>not used for parse or index</li>
</ul>
</li>
</ul>
</li>
<li>build index field

<ul>
<li>use <code>Document.add_term(word, pos)</code></li>
<li>use <code>Xapian::TermGenerator</code> and <code>.set_document(doc)</code>

<ul>
<li>then pass the string using delimiter space into index_text</li>
<li>then the doc will have the index field of this document</li>
</ul>
</li>
</ul>
</li>
<li>after building the document, import into database</li>
<li>use DB.commit()</li>
</ul>


<h4>how to query</h4>

<ul>
<li>open <code>Xapian::Database</code>, the path is the same as WriteableDatabase</li>
<li>use DB to construct <code>Xapian::Enquire</code></li>
<li>use <code>Xapian::QueryParser</code> to parse the string and generate <code>Xapian::Query</code></li>
<li>use <code>enquire.set_query()</code> to query</li>
<li>get the result set by using <code>enquire.get_mset(start, len)</code>.</li>
<li>use <code>Xapian::MsetIterator</code> to traverse the MSet.

<ul>
<li>use <code>get_rank()</code> to get the rank</li>
<li>use <code>get_document</code> to get the document</li>
</ul>
</li>
</ul>


<h4>query grammer</h4>

<ul>
<li><code>Term | Term | Term</code></li>
<li><code>Term -&gt; Term ~ Term</code>

<ul>
<li><code>~</code> is used for similar word</li>
</ul>
</li>
</ul>


<h4>About field</h4>

<ul>
<li>When building index

<ul>
<li>use <code>Xapian::TermGenerator</code> for example

<ul>
<li>we need to set the <code>TermGenerator.set_database(db)</code></li>
<li>when building the index field

<ul>
<li><code>index_text(text, wdf_inc=1, prefix)</code>

<ul>
<li>The second and third parameter are default</li>
<li>The second is TF increase</li>
<li>The third is prefix</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>When query

<ul>
<li>add mapping using <code>Xapian::QueryParser</code></li>
<li><code>.add_prefix("title", "T")</code></li>
<li>Then the <code>qp.parse_query</code> can have field when query the string</li>
<li>for example

<ul>
<li>&lsquo;title:news AND content:basketball&rsquo;</li>
<li>and now there are two field</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>sample code</h4>

<ul>
<li>create_index.cpp</li>
</ul>


<p>```
 #include&lt;xapian.h></p>

<h1>include<iostream></h1>

<h1>include<string></h1>

<p>using namespace std;</p>

<h1>define CONTENT &ldquo;70:69， This is man basketball race history the smallest point difference race ， smile to last is east man Chinese 。 Which can be said ， This time is the most famous victory and can be said this is the most lucky resuly 。After the end of the game, the coach of the Chinese aa and The boss bb hang togetherm and the two guy are so happy that the chinese win。&rdquo;</h1>

<h1>define TITLE &ldquo;This is a news&rdquo;</h1>

<h1>define INDEX_PATH &ldquo;./index_data&rdquo;</h1>

<h1>define F_DOCID 1</h1>

<p>int main(int argc, char *argv[]){</p>

<pre><code>try{
    //The text to be indexed
    string content(CONTENT);
    string title(TITLE);

    //open a database and write
    Xapian::WritableDatabase db(string(INDEX_PATH), Xapian::DB_CREATE_OR_OPEN);

    //term generator
    Xapian::TermGenerator indexer;

    //Make document
    Xapian::Document doc;
    doc.add_value(F_DOCID, string("1104"));
    doc.set_data(content);
    indexer.set_document(doc);
    indexer.index_text(title, 1, "T");
    indexer.index_text(content, 1, "C");

    //add document to db
    db.add_document(doc);

    //flush to disk
    db.commit();

}catch(const Xapian::Error &amp;e){
    cout&lt;&lt;e.get_description()&lt;&lt;endl;
}
return 0;
</code></pre>

<p>}</p>

<p> ```</p>

<ul>
<li>search.cpp</li>
</ul>


<p> ```</p>

<h1>include&lt;xapian.h></h1>

<h1>include<iostream></h1>

<h1>include<string></h1>

<p>using namespace std;</p>

<h1>define QUERY &ldquo;title:news AND content:70&rdquo;</h1>

<h1>define INDEX_PATH &ldquo;./index_data&rdquo;</h1>

<h1>define F_DOCID 1</h1>

<p>int main(){</p>

<pre><code>try{
    //The string for query
    string query_str(QUERY);

    //open the database
    Xapian::Database db(string(INDEX_PATH));

    //open search handle
    Xapian::Enquire enquire(db);

    //Parser Query
    Xapian::QueryParser qp;
    qp.add_prefix("title", "T");
    qp.add_prefix("content", "C");
    Xapian::Query query = qp.parse_query(query_str);
    cout&lt;&lt;"Query is "&lt;&lt;query.get_description()&lt;&lt;endl;

    //find the top 10 result
    enquire.set_query(query);
    Xapian::MSet result = enquire.get_mset(0,10);
    cout&lt;&lt;result.get_matches_estimated()&lt;&lt;" result found"&lt;&lt;endl;

    //print the result
    for(Xapian::MSetIterator iter = result.begin(); iter != result.end(); iter++){
        Xapian::Document doc = iter.get_document();
        cout&lt;&lt;iter.get_rank()&lt;&lt;": docid "&lt;&lt;doc.get_value(F_DOCID)&lt;&lt;", data"&lt;&lt;doc.get_data()&lt;&lt;endl;
    }

}catch(const Xapian::Error e){
    cout&lt;&lt;e.get_description()&lt;&lt;endl;
}
return 0;
</code></pre>

<p>}</p>

<p> ```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Difference Between Malloc and New in C++]]></title>
    <link href="http://pbking1.github.com/blog/2015/01/27/difference-between-malloc-and-new-in-c-plus-plus/"/>
    <updated>2015-01-27T15:30:52-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/01/27/difference-between-malloc-and-new-in-c-plus-plus</id>
    <content type="html"><![CDATA[<h3>new and delete</h3>

<ul>
<li>the way it allocate and release memory

<ul>
<li>the memory is allocate from <code>Free Store</code></li>
<li>will return a fully typed pointer

<ul>
<li>if failed will not return NULL</li>
</ul>
</li>
<li>the compiler will calculate the size</li>
<li>reallocate is not handled intuitively, using copy constructor</li>
<li>whether called malloc and delete can be user defined</li>
<li>can add a new memory allocator to deal with low memory</li>
<li>new and delete can be overwrite legally</li>
<li>use constructor/destructor to initial/destory object</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>new 动态创建和释放数组或者单个对象</p>

<ul>
<li>动态创建对象的时候，只需要指定其数据类型，不必为该对象命名</li>
<li>如果分配失败了，会抛出异常。</li>
<li>new 表达式返回指向该新建对象的指针</li>
<li>我们可以通过这个指针来访问新建的对象</li>
<li>int *p = new int

<ul>
<li>返回类型为int*类型， 分配大小为sizeof(int)</li>
</ul>
</li>
<li>int *p = new int[100]

<ul>
<li>返回类型为int*类型, 分配大小为sizeof(int) * 100</li>
</ul>
</li>
</ul>
</li>
<li><p>三种特殊指针</p>

<ul>
<li>void* 表示未确定类型的指针，更明确的说是指申请内存空间时还不知道user是用来储存什么类型的数据的。</li>
<li>零值指针：值为0的指针。可以是任何一种指针类型。</li>
<li>NULL指针：不提供任何地址信息的指针</li>
</ul>
</li>
<li><p>new 动态创建的对象是可以初始化的。</p>

<ul>
<li>e.g int *p = new int(1000)</li>
<li>如果不初始化，就会使用这个类的默认构造函数来初始化。

<ul>
<li>e.g int *p = new int()  //初始化为0</li>
</ul>
</li>
<li>但是如果对象是内置的，就没有初始化

<ul>
<li>e.g int *p = new int //指向一个没有初始化的int

<ul>
<li>string *str = new string()  //初始化为空串，因为string自带的默认构造函数会初始化为空串</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>delete</p>

<ul>
<li>delete p;

<ul>
<li>但是释放完p的内存之后，p会变成不确定的指针</li>
<li>因此要把p赋值为0

<ul>
<li>明确指针不再指向任何对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>malloc and free</h3>

<ul>
<li><p>the way it allocate and release memory</p>

<ul>
<li>the memory is allocate from <code>Heap</code></li>
<li>will return a void pointer

<ul>
<li>will return NULL if failed</li>
</ul>
</li>
<li>the space and size need to be specified(固定)</li>
<li>will not called new/delete</li>
<li>it is simple to reallocate large memory</li>
<li>user can not write code into allocation sequence to help with low memory</li>
<li>malloc/free can not be overriden legally</li>
</ul>
</li>
<li><p>malloc 动态内存分配</p>

<ul>
<li>void *malloc(int size)</li>
<li>向系统申请分配指定size个字节的内存空间</li>
<li>申请之后要检查是否分配成功</li>
<li>不用之后要释放：把纸箱这块内存的指针指向NULL, 防止程序不小心使用了它

<ul>
<li>如果忘了释放就是内存泄露</li>
</ul>
</li>
<li>操作系统中有一个记录空闲内存位置的链表，每次收到程序申请的时候，就会遍历这个链表，找到第一个空间大于申请的空间的堆节点，然后把该节点从链表中删除，把这个节点的空间分配给程序。</li>
<li> int p;

<ul>
<li>p = (int*)malloc(sizeof(int) * 128)</li>
<li>p指针会存储存储单元的首地址</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
