<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-04-22T01:01:00-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[string processing function implementation]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation/"/>
    <updated>2015-04-21T01:56:01-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation</id>
    <content type="html"><![CDATA[<h3>string function in c</h3>

<h4>strcpy</h4>

<ul>
<li>使用一个临时变量保存串的首地址，然后最后返回这个地址</li>
<li>然后在最后判断是否遇到'\0'来结束复制
<code>
char *strcpy1(char *des, const char*src){
  char *address = des;
  while((*des++ = *src++) != '\0');
  return address;
}
int main(){
  char *des;
  char *src = "aaa";
  char *result;
  result = strcpy1(des, src);
  cout&lt;&lt;result;
  return 0;
}
</code></li>
</ul>


<hr />

<h4>strlen</h4>

<ul>
<li>一直累加直到判断是否遇到'\0'来结束计数
<code>
int strlen1(const char*src){
  int count = 0;
  while((*src++) != '\0')
      count++;
  return count;
}
int main(){
  char *src = "aaa";
  int result;
  result = strlen1(src);
  cout&lt;&lt;result;
  return 0;
}
</code></li>
</ul>


<hr />

<h4>strcat</h4>

<ul>
<li>把指针移到最后，然后把b字符串的内容复制到a字符串最后</li>
<li><p>但是要注意a字符串要有足够的空间来支持b字符串内容的大小
```
char <em>strcat1(char </em>des, const char<em>src){
  char </em>address = des;
  while(*address)
      address++;</p>

<p>  while((<em>address++ = </em>src++) !=&lsquo;\0&rsquo;);
  return des;
}
int main(){
  char des[10] = &ldquo;&rdquo;;
  char <em>src = &ldquo;aaa&rdquo;;
  char </em>result;
  result = strcat1(des, src);
  printf(&ldquo;%s&rdquo;, result);
  return 0;
}
```</p></li>
</ul>


<hr />

<h4>strcmp</h4>

<ul>
<li>如果字符串一样，那么返回0</li>
<li>如果a>b那么返回正数，否则返回负数</li>
<li>比较方法是用asc码来比较，然后最后返回相减的结果

<ul>
<li>从左到右比较，知道出现不一样的字符或者出现'\0'为止
<code>
int strcmp1(const char *s1, const char*s2){
while(*s1 == *s2){
  if(*s1 == '\0'){
      return 0;
  }
  ++s1;
  ++s2;
}
return *s1 - *s2;
}
int main(){
char *des = "aaa";
char *src = "aaa";
int result;
result = strcmp1(des, src);
if(result == 0)
  cout&lt;&lt;"the string are the same";
else
  cout&lt;&lt;"the string are not the same";
return 0;
}
</code></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T22:04:11-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<h4>little review about c++ pop</h4>

<ul>
<li>虚函数

<ul>
<li>核心理念就是基类访问派生类定义的函数</li>
<li>动态联编</li>
<li>一个函数的调用不是在编译的时候确定的，而是在运行的时候确定的，并且因为写代码的时候不能确定被调用的函数是基类的函数还是派生类的函数，所以这个函数又叫做“虚函数“
<code>
class A{
  public:
      virtual void test(){
          cout&lt;&lt;"A:test() is called";
      }        
};
class B: public A{
  public:
      virtual void test(){
          cout&lt;&lt;"B:test() is called";
      }
};
int main(){
  A *a = new B();
  a -&gt; test();
}
</code></li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>虚函数表</p>

<ul>
<li>实现多态的主要功能</li>
<li>编译器会为每一个有虚函数的类的实例创建一个虚函数表</li>
<li>用来存虚函数的table

<ul>
<li>table的每个slot（槽）里面存放虚函数的地址</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数</p>

<ul>
<li><code>virtual void test() = 0</code></li>
<li>意思是抽象类，也可以说是接口，用来规范派生类的行为

<ul>
<li>告诉使用者我的派生类都会有这个函数</li>
</ul>
</li>
<li>虚构析函数

<ul>
<li>当一个类要被其他的类当基类使用的时候，必须是纯虚的</li>
<li>如果有两个class A和B

<ul>
<li>B继承A，但是A的构析函数没有设置成虚函数</li>
<li>那么在delete B的实例的时候，只有A的实例被delete， B的不会被delete。。。那这不是坑爹吗。。。。</li>
<li>但是再A的构析函数前面加上virtual，这样就能保证在delete B的实例的时候，两个类的构析函数都会被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>但是构造函数不能使虚函数</p></li>
</ul>


<h4>链表</h4>

<ul>
<li><p>链表ADT</p>

<ul>
<li><code>
template &lt;typename E&gt; class List{
private:
  void operator = (const List &amp;){}
  List(const List&amp;){}
public:
  List(){}
  virtual ~List(){}
  virtual void clear() = 0;
  virtual void insert(const E&amp; item) = 0;
  virtual void append(const E&amp; item) = 0;
  virtual E remove() = 0;
  //move the pointer to start
  virtual void moveToStart() = 0;
  //move the pointer to end
  virtual void moveToEnd() = 0;
  virtual void prev() = 0;
  virtual void next() = 0;
  virtual int length() const = 0;
  virtual int currPos() const = 0;
  virtual void moveToPos(int pos) = 0;
  virtual const E&amp; getValue() const = 0;
};
</code></li>
</ul>
</li>
<li><p>数组实现</p>

<ul>
<li><code>
template &lt;typename E&gt; class AList: public List&lt;E&gt;{
private:
  int maxSize;
  int listSize;
  int curr;
  E* listArray;   
public:
  //初始化列表
  AList(int size = 100){
      maxSize = size;
      listSize = 0;
      curr = 0;
      listArray = new E[maxSize];
  }
  //构析函数，删掉数组，释放空间
  ~AList(){
      delete []listArray;
  }
  void clear(){
      delete []listArray;
      listSize = 0;
      curr = 0;
      listArray = new E[maxSize];
  }
  //把当前位置之后的数组向后移动一位，再插入
  void insert(const E&amp; it){
      for(int i = listSize; i &gt; curr; i--)
          listArray[i] = listArray[i-1];
      //move back the array from the current position
      listArray[curr] = it;
      listSize++;
  }
  //直接在最后增加item
  void append(const E&amp; it){
      listArray[listSize++] = it;
  }
  //记录当前的数组索引的指向的数据，把数组向前移动一位
  E remove(){
      E it = listArray[curr];
      for(int i = curr; i &lt; listSize - 1; i++){
          listArray[i] = listArray[i + 1];
      }
      listSize--;
      return it;
  }
  void moveToStart(){
      curr = 0;
  }
  void moveToEnd(){
      curr = listSize;
  }
  void prev(){
      if(curr &gt; 0)
          curr--;
  }
  void next(){
      if(curr &lt; listSize)
          curr++;
  }
  int length(){
      return listSize;
  }
  int currPos() const{
      return curr;
  }
  void moveToPos(int pos){
      pos = curr;
  }
  const E&amp; getValue() const{
      return listArray[curr];
  }
};
</code></li>
</ul>
</li>
<li>链式实现

<ul>
<li><code>
template &lt;typename E&gt; class Link{
public:
  E element;
  Link *next;
  Link(const E&amp; elemval, Link *nextval = NULL){
      element = elemval;
      next = nextval;
  }
  Link(Link *nextval = NULL){
      next = nextval;
  }
};
template &lt;typename E&gt; class LList: public List&lt;E&gt;{
private:
  Link&lt;E&gt; *head;
  Link&lt;E&gt; *tail;
  Link&lt;E&gt; *curr;
  int count;
  void init(){
      curr = tail = head = new Link&lt;E&gt;;
      count = 0;
  }
  void removeall(){
      while(head != NULL){
          curr = head;
          head = head -&gt; next;
          delete curr;
      }
  }
public:
  LList(int size=100){
      init();
  }
  ~LList(){
      removeall();
  }
  void clear(){
      removeall();
      init();
  }
  void insert(const E&amp; it){
      //给要增加的节点初始化
      curr -&gt; next = new Link&lt;E&gt;(it, curr -&gt; next);
      //如果要curr指针就是再末尾
      //那么把curr的下一个赋给tail
      if(tail == curr)
          tail = curr -&gt; next;
      count++;
  }
  void append(const E&amp; it){
      //直接把末尾指针的next指向新建的link
      tail = tail -&gt; next = new Link&lt;E&gt;(it, NULL);
      count++;
  }
  //注意，这里要删除的节点叫做curr-&gt;next
  E remove(){
      //先把要删除的node的值存起来
      E it = curr -&gt; next -&gt; element;
      //用temp存一下要删除的节点
      Link&lt;E&gt; *temp = curr -&gt; next;
      //如果这个要删除的点是末尾，那么把末尾前一个节点赋给tail
      if(tail == curr -&gt; next)
          tail = curr;
      //否则，把要删除的节点的前一个节点的next指向要删除节点的下一个
      curr -&gt; next = curr -&gt; next -&gt; next;
      delete temp;
      count--;
      return it;
  }
  void moveToStart(){
      curr = head;
  }
  void moveToEnd(){
      curr = tail;
  }
  void prev(){
      if(curr == head)
          return ;
      Link&lt;E&gt; *temp = head;
      //向左移动一个单位
      //做法是先用temp存一个head，然后向右找，直到找到curr的前一个，然后把curr的前一个赋给curr
      while(temp -&gt; next != curr)
          temp = temp -&gt; next;
      curr = temp;
  }
  void next(){
      //只要curr指针不是tail，那么就向后移动
      if(curr != tail)
          curr = curr -&gt; next;
  }
  int length(){
      return count;
  }
  int currPos() const{
      Link&lt;E&gt; *temp = head;
      //用temp指针存head，然后依次向后遍历，并且每次后移count+1
      int i;
      for(i = 0; i &lt; count; i++){
          temp = temp -&gt; next;
      }
      return i;
  }
  void moveToPos(int pos){
      curr = head;
      //先把current的指针指向head
      //然后一直向后移动，直到pos次
      for(int i = 0; i &lt; pos; i++){
          curr = curr -&gt; next;
      }
  }
  const E&amp; getValue() const{
      return curr -&gt; next -&gt; element;
  }
};
</code>

<h4>栈</h4></li>
</ul>
</li>
<li>数组实现</li>
<li><code>
class Astack{
  private:
      int maxSize;
      int top;
      int *array;
  public:
      Astack(int size = 100){
          maxSize = size;
          top = 0;
          array = new int[size];
      }
      ~Astack(){
          delete []array;
      }
      void clear(){
          top = 0;
      }
      void push(int item){
          array[top++] = item;
      }
      int pop(){
          int temp = array[top];
          return array[--top];
      }
      int getTop(){
          return array[top - 1];
      }   
};
int main(){
  Astack a;
  a.push(1);
  cout&lt;&lt;a.getTop();
  a.pop();
  cout&lt;&lt;a.getTop();
  return 0;
}
</code></li>
</ul>


<h4>队列</h4>

<ul>
<li>数组实现</li>
<li><code>
class Aqueue{
  private:
      int front;
      int rear;
      int maxSize;
      int *array;
  public:
      Aqueue(int size = 100){
          maxSize = size;
          front = rear = 0;
          array = new int[size];
      }
      ~Aqueue(){
          delete [] array;
      }
      void enqueue(int item){
          array[rear] = item;
          rear = (rear + 1)%maxSize;
      }
      int dequeue(){
          int temp = array[front];
          front = (front + 1)%maxSize;
          array[front] = 0;
          return temp;
      }
      const int getFrontValue(){
          return array[front];
      }
};
int main(){
  Aqueue q;
  q.enqueue(1);
  cout&lt;&lt;q.getFrontValue()&lt;&lt;endl;
  q.dequeue();
  cout&lt;&lt;q.getFrontValue();
  return 0;
}
</code></li>
</ul>


<h4>二叉树</h4>

<ul>
<li>遍历

<ul>
<li>前序遍历

<ul>
<li><code>
void preorder(Node *root){
  if(root == NULL){
      return ;
  }
  cout&lt;&lt;root-&gt;value;
  preorder(root -&gt; left);
  preorder(root -&gt; right);
}
</code></li>
</ul>
</li>
<li>中序遍历

<ul>
<li><code>
void inorder(Node *root){
  if(root == NULL){
      return ;
  }
  inorder(root -&gt; left);
  cout&lt;&lt;root -&gt; value;
  inorder(root -&gt; right);
}
</code></li>
</ul>
</li>
<li>后序遍历

<ul>
<li><code>
void postorder(Node *root){
  if(root == NULL){
      return ;
  }
  postorder(root -&gt; left);
  postorder)root -&gt; right);
  cout&lt;&lt;root -&gt; value;
}
</code></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ program run time]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time/"/>
    <updated>2015-04-20T20:52:22-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time</id>
    <content type="html"><![CDATA[<h4>时间复杂度</h4>

<ul>
<li>costs for growth rate representative of most computer algorithm

<ul>
<li><table>
<thead>
<tr>
<th>n</th>
<th>loglogn</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n<sup>2</sup></th>
<th>n<sup>3</sup></th>
<th>2<sup>n</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2</td>
<td>4</td>
<td>2<sup>4</sup></td>
<td>2*2<sup>4</sup>=2<sup>5</sup></td>
<td>2<sup>8</sup></td>
<td>2<sup>12</sup></td>
<td>2<sup>16</sup></td>
</tr>
<tr>
<td>256</td>
<td>3</td>
<td>8</td>
<td>2<sup>8</sup></td>
<td>8*2<sup>8</sup>=2<sup>11</sup></td>
<td>2<sup>16</sup></td>
<td>2<sup>24</sup></td>
<td>2<sup>256</sup></td>
</tr>
<tr>
<td>1024</td>
<td>3.3</td>
<td>10</td>
<td>2<sup>10</sup></td>
<td>10*2<sup>10</sup>=2<sup>13</sup></td>
<td>2<sup>20</sup></td>
<td>2<sup>30</sup></td>
<td>2<sup>1024</sup></td>
</tr>
<tr>
<td>64K</td>
<td>4</td>
<td>16</td>
<td>2<sup>16</sup></td>
<td>16*2<sup>16</sup>=2<sup>20</sup></td>
<td>2<sup>32</sup></td>
<td>2<sup>48</sup></td>
<td>2<sup>64K</sup></td>
</tr>
<tr>
<td>1M</td>
<td>4.3</td>
<td>20</td>
<td>2<sup>20</sup></td>
<td>20*2<sup>20</sup>=2<sup>24</sup></td>
<td>2<sup>40</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>1M</sup></td>
</tr>
<tr>
<td>1G</td>
<td>4.9</td>
<td>30</td>
<td>2<sup>30</sup></td>
<td>30*2<sup>30</sup>=2<sup>35</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>90</sup></td>
<td>2<sup>1G</sup></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>最差，最好，平均

<ul>
<li>例如顺序搜索

<ul>
<li>如果在第一个就搜到，那么就是最佳的case</li>
<li>如果搜到最后一个才搜到，那就是最差的case</li>
<li>（最佳+最差）/2为平均</li>
</ul>
</li>
<li>一般都是用平均的</li>
</ul>
</li>
<li>上界

<ul>
<li>大O表示

<ul>
<li>对一个非负的函数T(n)，T(n)是O(f(n))的当且仅当存在两个非负的c和k，使得T(n)&lt;=cf(n) 对所有n > k;

<ul>
<li>其中k为n的最小值</li>
</ul>
</li>
</ul>
</li>
<li>大omega

<ul>
<li>对一个非负的函数T(n)，T(n)是omega(g(n))当且存在两个非负的c和k，使得T(n)>=cg(n) 对所有n > k;</li>
</ul>
</li>
<li>大theta

<ul>
<li>当上界和下界被同一个常数影响。</li>
</ul>
</li>
</ul>
</li>
<li>例子</li>
<li><code>
sum1 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=n;j++)
      sum1++;
sum2 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=k;j++)
      sum2++;
</code>

<ul>
<li>第一个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了n次

<ul>
<li>那么复杂度为nlogn</li>
</ul>
</li>
</ul>
</li>
<li>第二个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了执行了k次，k=2<sup>i</sup>

<ul>
<li>那么复杂度为n</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用算法的时间复杂度</li>
<li><p><strong>搜索</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>二分搜索</td>
<td>数组查n个元素</td>
<td>logn|</td>
</tr>
<tr>
<td>顺序查找</td>
<td>数组查n个元素</td>
<td>n|</td>
</tr>
<tr>
<td>最短路（乱序数组）</td>
<td>V个点和E条边</td>
<td>V<sup>2</sup></td>
</tr>
<tr>
<td>最短路（bellman-ford）</td>
<td> V个点和E条边</td>
<td>V*E       </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p><strong>排序</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>归并排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>堆排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>插入排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>选择排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>桶排序</td>
<td>数组</td>
<td>n+k</td>
</tr>
<tr>
<td>计数排序</td>
<td>数组</td>
<td>n*k </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<h4>算法加速</h4>

<ul>
<li>focus on算法主要消耗时间的部分</li>
<li>先优化算法，再优化代码</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xapian omindex build index and search]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search/"/>
    <updated>2015-04-15T22:28:58-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search</id>
    <content type="html"><![CDATA[<h3>omega is a component that can be used with xapian</h3>

<ul>
<li>we can use omega to build index</li>
</ul>


<h4>build index</h4>

<ul>
<li><code>omindex --db index --url / ./index_file/</code>

<ul>
<li>&mdash;db 后面跟的是索引数据库的名字</li>
<li>&mdash;url 后面跟的是 / 然后再加上要建索引的数据的文件夹（含有那些要建索引的文件）</li>
</ul>
</li>
<li>运行之后，就会生成index文件夹，这个文件夹里面就是建好的索引</li>
</ul>


<h4>query</h4>

<ul>
<li>quest &mdash;db=index &ldquo;asd&rdquo;

<ul>
<li>&mdash;db 后面跟的是索引数据库</li>
<li>然后再加上要查询的关键字</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compile qtox on OSX]]></title>
    <link href="http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx/"/>
    <updated>2015-03-03T23:49:35-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx</id>
    <content type="html"><![CDATA[<h3>Problems when compile qtox on mac</h3>

<ul>
<li>first is the modification of the qtox.pro file
<code>
  CONFIG += c++11
  CONFIG += x86_64
  CONFIG -= x86
  contains(JENKINS,YES) {
      INCLUDEPATH += ./libs/include/
  } else {
      INCLUDEPATH += libs/include
      # add head path
      INCLUDEPATH += /usr/include
      INCLUDEPATH += /usr/local/include
      INCLUDEPATH += /opt/local/include
  }
  macx {
      BUNDLEID = im.tox.qtox
      ICON = img/icons/qtox.icns
      QMAKE_INFO_PLIST = osx/info.plist
      QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9
      # add libtoxav
      LIBS += -L/usr/local/opt/libtoxcore/lib -ltoxav -ltoxcore
      LIBS += -L/usr/local/opt/libsodium/lib -lsodium
      LIBS += -L/usr/local/opt/libvpx/lib -lvpx
      LIBS += -L/usr/local/lib -lopus
      LIBS += -L/usr/local/lib -lopencv_core -lopencv_highgui
      #LIBS += -L/opt/local/lib -lopencv_core -lopencv_highgui
      LIBS += -L$$PWD/libs/lib/ -framework OpenAL -mmacosx-version-min=10.9
      #LIBS += -L$$PWD/libs/lib/ -ltoxcore -ltoxav -ltoxencryptsave -ltoxdns -lsodium -lvpx -lopus -framework OpenAL -lopencv_core -lopencv_highgui -mmacosx-version-min=10.7
      contains(DEFINES, QTOX_PLATFORM_EXT) { LIBS += -framework IOKit -framework CoreFoundation }
      contains(DEFINES, QTOX_FILTER_AUDIO) { LIBS += -lfilteraudio }
</code></li>
</ul>


<!--more-->


<ul>
<li><p>1.-ltoxcore can not found</p>

<ul>
<li>install the toxcore library

<ul>
<li>and remember to add the library path</li>
</ul>
</li>
</ul>
</li>
<li><p>2.can not find -lopus</p>

<ul>
<li>install the libogg first and then install the opus library</li>
</ul>
</li>
<li><ol>
<li>“Project ERROR: Could not resolve SDK path for ‘macosx10.8′”.</li>
<li><code>cd /Users/Mark/Qt/5.3/clang_64/mkspecs/</code>

<ul>
<li>modify <code>!host_build:QMAKE_MAC_SDK = macosx10.9</code></li>
</ul>
</li>
</ol>
</li>
<li><p>4.&ldquo;Undefined symbols for architecture x86_64&rdquo;</p>

<ul>
<li><strong>not solved</strong>

<ul>
<li>one way on the Internet(did not solve)

<ul>
<li>change <code>../Qt5.4.0/5.4.0-rc1/clang_64/mkspecs/macx-clang/qmake.conf</code>

<ul>
<li>from <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.6</code></li>
<li>into <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9</code>

<ul>
<li>and remember to clean the project before rebuild</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.&lsquo;#include &lt;>&rsquo; and &lsquo;#include &ldquo;&rdquo;&rsquo;</p>

<ul>
<li>&lsquo;#include &lt;>&rsquo;

<ul>
<li>find the header in particular path

<ul>
<li>/usr/include</li>
<li>for exmaple: /usr/include/stdio.h</li>
</ul>
</li>
</ul>
</li>
<li>&lsquo;#include &ldquo;&rdquo;&rsquo;

<ul>
<li>find the header in absolute path</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
