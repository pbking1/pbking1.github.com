<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-04-21T00:18:39-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T22:04:11-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<ul>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ program run time]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time/"/>
    <updated>2015-04-20T20:52:22-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time</id>
    <content type="html"><![CDATA[<h4>时间复杂度</h4>

<ul>
<li>costs for growth rate representative of most computer algorithm

<ul>
<li><table>
<thead>
<tr>
<th>n</th>
<th>loglogn</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n<sup>2</sup></th>
<th>n<sup>3</sup></th>
<th>2<sup>n</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2</td>
<td>4</td>
<td>2<sup>4</sup></td>
<td>2*2<sup>4</sup>=2<sup>5</sup></td>
<td>2<sup>8</sup></td>
<td>2<sup>12</sup></td>
<td>2<sup>16</sup></td>
</tr>
<tr>
<td>256</td>
<td>3</td>
<td>8</td>
<td>2<sup>8</sup></td>
<td>8*2<sup>8</sup>=2<sup>11</sup></td>
<td>2<sup>16</sup></td>
<td>2<sup>24</sup></td>
<td>2<sup>256</sup></td>
</tr>
<tr>
<td>1024</td>
<td>3.3</td>
<td>10</td>
<td>2<sup>10</sup></td>
<td>10*2<sup>10</sup>=2<sup>13</sup></td>
<td>2<sup>20</sup></td>
<td>2<sup>30</sup></td>
<td>2<sup>1024</sup></td>
</tr>
<tr>
<td>64K</td>
<td>4</td>
<td>16</td>
<td>2<sup>16</sup></td>
<td>16*2<sup>16</sup>=2<sup>20</sup></td>
<td>2<sup>32</sup></td>
<td>2<sup>48</sup></td>
<td>2<sup>64K</sup></td>
</tr>
<tr>
<td>1M</td>
<td>4.3</td>
<td>20</td>
<td>2<sup>20</sup></td>
<td>20*2<sup>20</sup>=2<sup>24</sup></td>
<td>2<sup>40</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>1M</sup></td>
</tr>
<tr>
<td>1G</td>
<td>4.9</td>
<td>30</td>
<td>2<sup>30</sup></td>
<td>30*2<sup>30</sup>=2<sup>35</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>90</sup></td>
<td>2<sup>1G</sup></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>最差，最好，平均

<ul>
<li>例如顺序搜索

<ul>
<li>如果在第一个就搜到，那么就是最佳的case</li>
<li>如果搜到最后一个才搜到，那就是最差的case</li>
<li>（最佳+最差）/2为平均</li>
</ul>
</li>
<li>一般都是用平均的</li>
</ul>
</li>
<li>上界

<ul>
<li>大O表示

<ul>
<li>对一个非负的函数T(n)，T(n)是O(f(n))的当且仅当存在两个非负的c和k，使得T(n)&lt;=cf(n) 对所有n > k;

<ul>
<li>其中k为n的最小值</li>
</ul>
</li>
</ul>
</li>
<li>大omega

<ul>
<li>对一个非负的函数T(n)，T(n)是omega(g(n))当且存在两个非负的c和k，使得T(n)>=cg(n) 对所有n > k;</li>
</ul>
</li>
<li>大theta

<ul>
<li>当上界和下界被同一个常数影响。</li>
</ul>
</li>
</ul>
</li>
<li>例子</li>
<li><code>
sum1 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=n;j++)
      sum1++;
sum2 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=k;j++)
      sum2++;
</code>

<ul>
<li>第一个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了n次

<ul>
<li>那么复杂度为nlogn</li>
</ul>
</li>
</ul>
</li>
<li>第二个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了执行了k次，k=2<sup>i</sup>

<ul>
<li>那么复杂度为n</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用算法的时间复杂度</li>
<li><p><strong>搜索</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>二分搜索</td>
<td>数组查n个元素</td>
<td>logn|</td>
</tr>
<tr>
<td>顺序查找</td>
<td>数组查n个元素</td>
<td>n|</td>
</tr>
<tr>
<td>最短路（乱序数组）</td>
<td>V个点和E条边</td>
<td>V<sup>2</sup></td>
</tr>
<tr>
<td>最短路（bellman-ford）</td>
<td> V个点和E条边</td>
<td>V*E       </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p><strong>排序</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>归并排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>堆排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>插入排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>选择排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>桶排序</td>
<td>数组</td>
<td>n+k</td>
</tr>
<tr>
<td>计数排序</td>
<td>数组</td>
<td>n*k </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<h4>空间复杂度</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xapian omindex build index and search]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search/"/>
    <updated>2015-04-15T22:28:58-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search</id>
    <content type="html"><![CDATA[<h3>omega is a component that can be used with xapian</h3>

<ul>
<li>we can use omega to build index</li>
</ul>


<h4>build index</h4>

<ul>
<li><code>omindex --db index --url / ./index_file/</code>

<ul>
<li>&mdash;db 后面跟的是索引数据库的名字</li>
<li>&mdash;url 后面跟的是 / 然后再加上要建索引的数据的文件夹（含有那些要建索引的文件）</li>
</ul>
</li>
<li>运行之后，就会生成index文件夹，这个文件夹里面就是建好的索引</li>
</ul>


<h4>query</h4>

<ul>
<li>quest &mdash;db=index &ldquo;asd&rdquo;

<ul>
<li>&mdash;db 后面跟的是索引数据库</li>
<li>然后再加上要查询的关键字</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compile qtox on OSX]]></title>
    <link href="http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx/"/>
    <updated>2015-03-03T23:49:35-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx</id>
    <content type="html"><![CDATA[<h3>Problems when compile qtox on mac</h3>

<ul>
<li>first is the modification of the qtox.pro file
<code>
  CONFIG += c++11
  CONFIG += x86_64
  CONFIG -= x86
  contains(JENKINS,YES) {
      INCLUDEPATH += ./libs/include/
  } else {
      INCLUDEPATH += libs/include
      # add head path
      INCLUDEPATH += /usr/include
      INCLUDEPATH += /usr/local/include
      INCLUDEPATH += /opt/local/include
  }
  macx {
      BUNDLEID = im.tox.qtox
      ICON = img/icons/qtox.icns
      QMAKE_INFO_PLIST = osx/info.plist
      QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9
      # add libtoxav
      LIBS += -L/usr/local/opt/libtoxcore/lib -ltoxav -ltoxcore
      LIBS += -L/usr/local/opt/libsodium/lib -lsodium
      LIBS += -L/usr/local/opt/libvpx/lib -lvpx
      LIBS += -L/usr/local/lib -lopus
      LIBS += -L/usr/local/lib -lopencv_core -lopencv_highgui
      #LIBS += -L/opt/local/lib -lopencv_core -lopencv_highgui
      LIBS += -L$$PWD/libs/lib/ -framework OpenAL -mmacosx-version-min=10.9
      #LIBS += -L$$PWD/libs/lib/ -ltoxcore -ltoxav -ltoxencryptsave -ltoxdns -lsodium -lvpx -lopus -framework OpenAL -lopencv_core -lopencv_highgui -mmacosx-version-min=10.7
      contains(DEFINES, QTOX_PLATFORM_EXT) { LIBS += -framework IOKit -framework CoreFoundation }
      contains(DEFINES, QTOX_FILTER_AUDIO) { LIBS += -lfilteraudio }
</code></li>
</ul>


<!--more-->


<ul>
<li><p>1.-ltoxcore can not found</p>

<ul>
<li>install the toxcore library

<ul>
<li>and remember to add the library path</li>
</ul>
</li>
</ul>
</li>
<li><p>2.can not find -lopus</p>

<ul>
<li>install the libogg first and then install the opus library</li>
</ul>
</li>
<li><ol>
<li>“Project ERROR: Could not resolve SDK path for ‘macosx10.8′”.</li>
<li><code>cd /Users/Mark/Qt/5.3/clang_64/mkspecs/</code>

<ul>
<li>modify <code>!host_build:QMAKE_MAC_SDK = macosx10.9</code></li>
</ul>
</li>
</ol>
</li>
<li><p>4.&ldquo;Undefined symbols for architecture x86_64&rdquo;</p>

<ul>
<li><strong>not solved</strong>

<ul>
<li>one way on the Internet(did not solve)

<ul>
<li>change <code>../Qt5.4.0/5.4.0-rc1/clang_64/mkspecs/macx-clang/qmake.conf</code>

<ul>
<li>from <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.6</code></li>
<li>into <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9</code>

<ul>
<li>and remember to clean the project before rebuild</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.&lsquo;#include &lt;>&rsquo; and &lsquo;#include &ldquo;&rdquo;&rsquo;</p>

<ul>
<li>&lsquo;#include &lt;>&rsquo;

<ul>
<li>find the header in particular path

<ul>
<li>/usr/include</li>
<li>for exmaple: /usr/include/stdio.h</li>
</ul>
</li>
</ul>
</li>
<li>&lsquo;#include &ldquo;&rdquo;&rsquo;

<ul>
<li>find the header in absolute path</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xapian_tutorial_3]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/06/xapian-tutorial-3/"/>
    <updated>2015-02-06T02:50:50-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/06/xapian-tutorial-3</id>
    <content type="html"><![CDATA[<h4>filter</h4>

<ul>
<li>There is a <code>faceted Search</code>, which is to preview the result of the query in many category.

<ul>
<li>like if we search for &lsquo;apple&rsquo;

<ul>
<li>the result may be classified into two

<ul>
<li>one is apple fruit</li>
<li>one is apple company</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>actually, this is a filter.

<ul>
<li>we can classify before index, and store into index</li>
<li>and use value to filter them when query</li>
</ul>
</li>
</ul>


<!--more-->


<h4>how to build filter value</h4>

<ul>
<li>use <code>Document::add_value</code></li>
</ul>


<h4>how to use filter when query</h4>

<ul>
<li>two ways

<ul>
<li>one is use <code>Xapian::MatchDecider</code>, this return a bool value.

<ul>
<li>or we can use <code>Xapian::ValueSetMatchDecider</code>

<ul>
<li><code>Xapian::ValueSetMatchDecider(slot, inclusive)</code>

<ul>
<li>slot means which slot to filter</li>
<li>inclusive means using filter or reduce</li>
</ul>
</li>
<li>use <code>Xapian::ValueSetMatchDecider::add_value(string)</code>

<ul>
<li>user can decide one or many set of value

<ul>
<li>when document belong to one of these value

<ul>
<li>make it filter or stay</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>use <code>MatchSpy</code></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
