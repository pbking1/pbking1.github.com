<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-04-22T17:23:11-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[c++ reference and pointer]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer/"/>
    <updated>2015-04-22T12:15:07-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer</id>
    <content type="html"><![CDATA[<h3>what is pointer</h3>

<ul>
<li>形参

<ul>
<li>formal parameter</li>
<li>定义时函数里面的变量

<ul>
<li>e.g int swao(int a, int b)</li>
<li>a和b就是形参</li>
</ul>
</li>
</ul>
</li>
<li>实参

<ul>
<li>actual parameter</li>
<li>在主函数里面引用的

<ul>
<li>e.g swap(x,y)</li>
<li>x和y就是实参，实际的值</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>指针</h4>

<ul>
<li><code>
void part1(){
  //basic
  //p指向变量，对p的重新复制就会改变p所指向的变量的值。
  //同样对p指向的变量重新复制也会改变*p的值
  int ptmp = 50;
  int *p;
  p = &amp;ptmp;
  cout&lt;&lt;p&lt;&lt;endl;
  //p存放的是ptmp变量所在的地址值
  cout&lt;&lt;*p&lt;&lt;endl;
  //50，是指储存在指针的内存地址中的值，也就是ptmp的值
  cout&lt;&lt;&amp;p&lt;&lt;endl;
  //p指针本身的地址值
  cout&lt;&lt;&amp;ptmp;
  //ptmp变量所在的地址值
}
</code></li>
</ul>


<h4>指针控制循环</h4>

<ul>
<li><code>
void part2(){
  //用指针来控制循环条件
  //针对数组
  int array[20];
  int *p = array;
  int i;
  for(int j = 0; j &lt; 20; j++)
      array[j] = j;
  cout&lt;&lt;endl;
  for(i = 0; i &lt; 20; i++){
      cout&lt;&lt;p&lt;&lt;" "&lt;&lt;(*p)&lt;&lt;" ";
      p++; //指针加一
      (*p)++; //指针指向内容加一
  }
  cout&lt;&lt;endl;
  //针对字符串
  char *str = "abc";
  while(*p){
      cout&lt;&lt;*p&lt;&lt;" ";
      p++;
  }
}
</code></li>
</ul>


<h4>引用</h4>

<ul>
<li><code>
void part3(){
  //引用
  int a = 20;
  int b = 10;
  int &amp;p = a;
  //p引用a,所以p是a的另外一个名字
  cout&lt;&lt;p&lt;&lt;endl;
  //p的值改变了
  p = b;
  //a的值也会改变
  cout&lt;&lt;a&lt;&lt;endl;
}
</code></li>
</ul>


<h4>传参</h4>

<ul>
<li><code>
void swap1(int x, int y){
  cout&lt;&lt;"in function before swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
  int temp = x;
  x = y;
  y = temp;
  cout&lt;&lt;"in fuction after swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
}
void swap2(int *a, int *b){
  //temp用来存a得值
  //所以其实这里是在交换值
  int temp = *a;
  *a = *b;
  *b = temp;
}
void swap3(int &amp;a, int &amp;b){
  //因为这里是传引用，所以任何的改变都会改变
  int temp = a;
  a = b;
  b = temp;
}
</code></li>
</ul>


<h4>注意事项</h4>

<ul>
<li>在可以使用引用的情况下，不要用指针</li>
<li>引用不能为空，当对象为NULL时，必须使用指针

<ul>
<li>引用不允许重新赋值，当使用一个变量指向不同的对象的时候，必须使用指针</li>
</ul>
</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part3]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3/"/>
    <updated>2015-04-22T01:27:20-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h3>图论</h3>

<h4>图的实现</h4>

<h4>图搜索</h4>

<h5>广度优先搜索</h5>

<h5>宽度优先搜索</h5>

<h5>拓扑排序和搜索</h5>

<h4>最短路径</h4>

<ul>
<li>单源最短路</li>
</ul>


<h4>最小生成树</h4>

<ul>
<li>Prim</li>
<li>Kruskal</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part2]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2/"/>
    <updated>2015-04-22T01:22:30-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h4>树</h4>

<h4>内排序</h4>

<ul>
<li><p>冒泡排序</p></li>
<li><p>插入排序</p></li>
<li><p>选择排序</p></li>
<li><p>快速排序</p></li>
<li><p>归并排序</p></li>
</ul>


<h3>外排序</h3>

<h4>哈希表</h4>

<h4>索引</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[string processing function implementation]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation/"/>
    <updated>2015-04-21T01:56:01-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation</id>
    <content type="html"><![CDATA[<h3>string function in c</h3>

<h4>strcpy</h4>

<ul>
<li>使用一个临时变量保存串的首地址，然后最后返回这个地址</li>
<li>然后在最后判断是否遇到'\0'来结束复制
<code>
char *strcpy1(char *des, const char*src){
  char *address = des;
  while((*des++ = *src++) != '\0');
  return address;
}
int main(){
  char *des;
  char *src = "aaa";
  char *result;
  result = strcpy1(des, src);
  cout&lt;&lt;result;
  return 0;
}
</code></li>
</ul>


<hr />

<h4>strlen</h4>

<ul>
<li>一直累加直到判断是否遇到'\0'来结束计数
<code>
int strlen1(const char*src){
  int count = 0;
  while((*src++) != '\0')
      count++;
  return count;
}
int main(){
  char *src = "aaa";
  int result;
  result = strlen1(src);
  cout&lt;&lt;result;
  return 0;
}
</code></li>
</ul>


<hr />

<h4>strcat</h4>

<ul>
<li>把指针移到最后，然后把b字符串的内容复制到a字符串最后</li>
<li><p>但是要注意a字符串要有足够的空间来支持b字符串内容的大小
```
char <em>strcat1(char </em>des, const char<em>src){
  char </em>address = des;
  while(*address)
      address++;</p>

<p>  while((<em>address++ = </em>src++) !=&lsquo;\0&rsquo;);
  return des;
}
int main(){
  char des[10] = &ldquo;&rdquo;;
  char <em>src = &ldquo;aaa&rdquo;;
  char </em>result;
  result = strcat1(des, src);
  printf(&ldquo;%s&rdquo;, result);
  return 0;
}
```</p></li>
</ul>


<hr />

<h4>strcmp</h4>

<ul>
<li>如果字符串一样，那么返回0</li>
<li>如果a>b那么返回正数，否则返回负数</li>
<li>比较方法是用asc码来比较，然后最后返回相减的结果

<ul>
<li>从左到右比较，知道出现不一样的字符或者出现'\0'为止
<code>
int strcmp1(const char *s1, const char*s2){
while(*s1 == *s2){
  if(*s1 == '\0'){
      return 0;
  }
  ++s1;
  ++s2;
}
return *s1 - *s2;
}
int main(){
char *des = "aaa";
char *src = "aaa";
int result;
result = strcmp1(des, src);
if(result == 0)
  cout&lt;&lt;"the string are the same";
else
  cout&lt;&lt;"the string are not the same";
return 0;
}
</code></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T22:04:11-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<h4>little review about c++ object oriented</h4>

<ul>
<li>虚函数

<ul>
<li>核心理念就是基类访问派生类定义的函数</li>
<li>动态联编</li>
<li>一个函数的调用不是在编译的时候确定的，而是在运行的时候确定的，并且因为写代码的时候不能确定被调用的函数是基类的函数还是派生类的函数，所以这个函数又叫做“虚函数“
<code>
class A{
  public:
      virtual void test(){
          cout&lt;&lt;"A:test() is called";
      }        
};
class B: public A{
  public:
      virtual void test(){
          cout&lt;&lt;"B:test() is called";
      }
};
int main(){
  A *a = new B();
  a -&gt; test();
}
</code></li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>虚函数表</p>

<ul>
<li>实现多态的主要功能</li>
<li><strong>编译器</strong>会为每一个有虚函数的类的实例创建一个虚函数表</li>
<li>用来存虚函数的table

<ul>
<li>table的每个slot（槽）里面存放虚函数的地址</li>
</ul>
</li>
<li>但是我们可以用函数指针来看虚函数表的地址

<ul>
<li>并且虚函数表在继承中，如果派生类没有重写基类的某个函数，他就会在基类中查那个函数，然后引用的时候就会引用基类的</li>
<li>并且如果子类如果增加了函数，就会在基类的虚函数表中增加</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数</p>

<ul>
<li><code>virtual void test() = 0</code></li>
<li>意思是抽象类，也可以说是接口，用来规范派生类的行为

<ul>
<li>告诉使用者我的派生类都会有这个函数</li>
</ul>
</li>
<li>虚构析函数

<ul>
<li>当一个类要被其他的类当基类使用的时候，必须是纯虚的</li>
<li>如果有两个class A和B

<ul>
<li>B继承A，但是A的构析函数没有设置成虚函数</li>
<li>那么在delete B的实例的时候，只有A的实例被delete， B的不会被delete。。。那这不是坑爹吗。。。。</li>
<li>但是再A的构析函数前面加上virtual，这样就能保证在delete B的实例的时候，两个类的构析函数都会被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>但是构造函数不能使虚函数</p></li>
</ul>


<hr />

<h4>链表</h4>

<ul>
<li>链表ADT
<code>
template &lt;typename E&gt; class List{
  private:
      void operator = (const List &amp;){}
      List(const List&amp;){}
  public:
      List(){}
      virtual ~List(){}
      virtual void clear() = 0;
      virtual void insert(const E&amp; item) = 0;
      virtual void append(const E&amp; item) = 0;
      virtual E remove() = 0;
      //move the pointer to start
      virtual void moveToStart() = 0;
      //move the pointer to end
      virtual void moveToEnd() = 0;
      virtual void prev() = 0;
      virtual void next() = 0;
      virtual int length() const = 0;
      virtual int currPos() const = 0;
      virtual void moveToPos(int pos) = 0;
      virtual const E&amp; getValue() const = 0;
};
</code></li>
</ul>


<hr />

<ul>
<li>数组实现
<code>
  template &lt;typename E&gt; class AList: public List&lt;E&gt;{
  private:
      int maxSize;
      int listSize;
      int curr;
      E* listArray;   
  public:
      //初始化列表
      AList(int size = 100){
          maxSize = size;
          listSize = 0;
          curr = 0;
          listArray = new E[maxSize];
      }
      //构析函数，删掉数组，释放空间
      ~AList(){
          delete []listArray;
      }
      void clear(){
          delete []listArray;
          listSize = 0;
          curr = 0;
          listArray = new E[maxSize];
      }
      //把当前位置之后的数组向后移动一位，再插入
      void insert(const E&amp; it){
          for(int i = listSize; i &gt; curr; i--)
              listArray[i] = listArray[i-1];
          //move back the array from the current position
          listArray[curr] = it;
          listSize++;
      }
      //直接在最后增加item
      void append(const E&amp; it){
          listArray[listSize++] = it;
      }
      //记录当前的数组索引的指向的数据，把数组向前移动一位
      E remove(){
          E it = listArray[curr];
          for(int i = curr; i &lt; listSize - 1; i++){
              listArray[i] = listArray[i + 1];
          }
          listSize--;
          return it;
      }
      void moveToStart(){
          curr = 0;
      }
      void moveToEnd(){
          curr = listSize;
      }
      void prev(){
          if(curr &gt; 0)
              curr--;
      }
      void next(){
          if(curr &lt; listSize)
              curr++;
      }
      int length(){
          return listSize;
      }
      int currPos() const{
          return curr;
      }
      void moveToPos(int pos){
          pos = curr;
      }
      const E&amp; getValue() const{
          return listArray[curr];
      }
  };
</code></li>
</ul>


<hr />

<ul>
<li>链式实现
<code>
  template &lt;typename E&gt; class Link{
  public:
      E element;
      Link *next;
      Link(const E&amp; elemval, Link *nextval = NULL){
          element = elemval;
          next = nextval;
      }
      Link(Link *nextval = NULL){
          next = nextval;
      }
};
template &lt;typename E&gt; class LList: public List&lt;E&gt;{
  private:
      Link&lt;E&gt; *head;
      Link&lt;E&gt; *tail;
      Link&lt;E&gt; *curr;
      int count;
      void init(){
          curr = tail = head = new Link&lt;E&gt;;
          count = 0;
      }
      void removeall(){
          while(head != NULL){
              curr = head;
              head = head -&gt; next;
              delete curr;
          }
      }
  public:
      LList(int size=100){
          init();
      }
      ~LList(){
          removeall();
      }
      void clear(){
          removeall();
          init();
      }
      void insert(const E&amp; it){
          //给要增加的节点初始化
          curr -&gt; next = new Link&lt;E&gt;(it, curr -&gt; next);
          //如果要curr指针就是再末尾
          //那么把curr的下一个赋给tail
          if(tail == curr)
              tail = curr -&gt; next;
          count++;
      }
      void append(const E&amp; it){
          //直接把末尾指针的next指向新建的link
          tail = tail -&gt; next = new Link&lt;E&gt;(it, NULL);
          count++;
      }
      //注意，这里要删除的节点叫做curr-&gt;next
      E remove(){
          //先把要删除的node的值存起来
          E it = curr -&gt; next -&gt; element;
          //用temp存一下要删除的节点
          Link&lt;E&gt; *temp = curr -&gt; next;
          //如果这个要删除的点是末尾，那么把末尾前一个节点赋给tail
          if(tail == curr -&gt; next)
              tail = curr;
          //否则，把要删除的节点的前一个节点的next指向要删除节点的下一个
          curr -&gt; next = curr -&gt; next -&gt; next;
          delete temp;
          count--;
          return it;
      }
      void moveToStart(){
          curr = head;
      }
      void moveToEnd(){
          curr = tail;
      }
      void prev(){
          if(curr == head)
              return ;
          Link&lt;E&gt; *temp = head;
          //向左移动一个单位
          //做法是先用temp存一个head，然后向右找，直到找到curr的前一个，然后把curr的前一个赋给curr
          while(temp -&gt; next != curr)
              temp = temp -&gt; next;
          curr = temp;
      }
      void next(){
          //只要curr指针不是tail，那么就向后移动
          if(curr != tail)
              curr = curr -&gt; next;
      }
      int length(){
          return count;
      }
      int currPos() const{
          Link&lt;E&gt; *temp = head;
          //用temp指针存head，然后依次向后遍历，并且每次后移count+1
          int i;
          for(i = 0; i &lt; count; i++){
              temp = temp -&gt; next;
          }
          return i;
      }
      void moveToPos(int pos){
          curr = head;
          //先把current的指针指向head
          //然后一直向后移动，直到pos次
          for(int i = 0; i &lt; pos; i++){
              curr = curr -&gt; next;
          }
      }
      const E&amp; getValue() const{
          return curr -&gt; next -&gt; element;
      }
  };
</code></li>
</ul>


<hr />

<h4>栈</h4>

<ul>
<li>数组实现
<code>
class Astack{
  private:
      int maxSize;
      int top;
      int *array;
  public:
      Astack(int size = 100){
          maxSize = size;
          top = 0;
          array = new int[size];
      }
      ~Astack(){
          delete []array;
      }
      void clear(){
          top = 0;
      }
      void push(int item){
          array[top++] = item;
      }
      int pop(){
          int temp = array[top];
          return array[--top];
      }
      int getTop(){
          return array[top - 1];
      }   
};
int main(){
  Astack a;
  a.push(1);
  cout&lt;&lt;a.getTop();
  a.pop();
  cout&lt;&lt;a.getTop();
  return 0;
}
</code></li>
</ul>


<hr />

<h4>队列</h4>

<ul>
<li>数组实现
<code>
class Aqueue{
  private:
      int front;
      int rear;
      int maxSize;
      int *array;
  public:
      Aqueue(int size = 100){
          maxSize = size;
          front = rear = 0;
          array = new int[size];
      }
      ~Aqueue(){
          delete [] array;
      }
      void enqueue(int item){
          array[rear] = item;
          rear = (rear + 1)%maxSize;
      }
      int dequeue(){
          int temp = array[front];
          front = (front + 1)%maxSize;
          array[front] = 0;
          return temp;
      }
      const int getFrontValue(){
          return array[front];
      }
};
int main(){
  Aqueue q;
  q.enqueue(1);
  cout&lt;&lt;q.getFrontValue()&lt;&lt;endl;
  q.dequeue();
  cout&lt;&lt;q.getFrontValue();
  return 0;
}
</code></li>
</ul>


<h4>二叉树</h4>

<ul>
<li>遍历

<ul>
<li>前序遍历
<code>
  void preorder(Node *root){
      if(root == NULL){
          return ;
      }
      cout&lt;&lt;root-&gt;value;
      preorder(root -&gt; left);
      preorder(root -&gt; right);
  }
</code></li>
<li>中序遍历
<code>
  void inorder(Node *root){
      if(root == NULL){
          return ;
      }
      inorder(root -&gt; left);
      cout&lt;&lt;root -&gt; value;
      inorder(root -&gt; right);
  }
</code></li>
<li>后序遍历
<code>
  void postorder(Node *root){
      if(root == NULL){
          return ;
      }
      postorder(root -&gt; left);
      postorder)root -&gt; right);
      cout&lt;&lt;root -&gt; value;
  }
</code></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
