<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | KING]]></title>
  <link href="http://pbking1.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2014-10-23T10:50:09-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Regular Expression]]></title>
    <link href="http://pbking1.github.com/blog/2014/10/03/python-regular-expression/"/>
    <updated>2014-10-03T13:00:03-04:00</updated>
    <id>http://pbking1.github.com/blog/2014/10/03/python-regular-expression</id>
    <content type="html"><![CDATA[<h3>regular expression</h3>

<ul>
<li>use the match string

<ul>
<li>but not all the string can be matched</li>
</ul>
</li>
</ul>


<!--more-->


<h3>basic character in python</h3>

<p><code>
import re
</code>
&ndash; ordinary character</p>

<pre><code>- like re'test' will match the string test
</code></pre>

<ul>
<li>oral character

<ul>
<li>like . ^ $ * + ? {} [] \ | ()</li>
<li>like []

<ul>
<li>use to direct to a range of the string set</li>
<li><code>
s = r'abc'
re.findall(s, "aaaaaaaabc")
//use []
rt = "top tip tap twp tep"
r1 = r"t[io]p"
re.findall(r1, rt)
//output ['top'], ['tip']
r2 = r"t[^io]p"
re.findall(r2, rt)
//output ['tap'],['tep'], ['twp']
</code></li>
<li>and oral character is no use in the []</li>
<li>also can use <code>r'0-3'</code> replace <code>r'0123'</code>

<ul>
<li>use &lsquo;r&rsquo;[0-3a-cA-C]&lsquo;&rsquo; replace <code>r'[0123abcABC]'</code></li>
</ul>
</li>
</ul>
</li>
<li>like ^

<ul>
<li>use the match the head of the line</li>
<li><code>
s = r'^t'
st = 'tss'
//output ['t']
</code></li>
</ul>
</li>
<li>like $

<ul>
<li>use to match the end of the line</li>
</ul>
</li>
<li>like \

<ul>
<li>used if you want to transform the oral character into a original one</li>
<li>use &lsquo;^&rsquo; to make ^ as a original character</li>
<li>and can be used as

<ul>
<li>\d match [0-9]</li>
<li>\D match [^0-9]</li>
<li>\s match [\t\n\r\f\v]

<ul>
<li>means and empty character</li>
</ul>
</li>
<li>\S match [^\t\n\r\f\v]

<ul>
<li>means non empty character</li>
</ul>
</li>
<li>\w match [a-zA-Z0-9]</li>
<li>\W match [^a-zA-Z0-9]</li>
</ul>
</li>
</ul>
</li>
<li>like *

<ul>
<li>match multiple character</li>
<li>means repeat the character in front of the * for 0-many times</li>
<li><code>
r = r'ab*'
rt = 'abbbbbb'
re.findall(r, rt)
//output['abbbbbb']
</code></li>
</ul>
</li>
<li>like +

<ul>
<li>match the charter that appear more than one time</li>
</ul>
</li>
<li>like ?

<ul>
<li> match the charter that appear zero or one time</li>
<li>can be used as minimum match

<ul>
<li><code>r = r'ab+?'</code></li>
<li><code>rt = 'abbbbbb'</code></li>
<li>output the ab</li>
</ul>
</li>
</ul>
</li>
<li>like the {}

<ul>
<li>means that the character can be repeat how many times</li>
<li><code>
r = r'a{1,3}'
rt = 'aaaaa'
then can match a, aa, aaa
</code></li>
<li>{0,} == *</li>
<li>{1,} == +</li>
<li>{0,1} == ?</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>functions</h3>

<ul>
<li>compile the expression to speed up

<ul>
<li><code>
r = r'\d{3,4}-?\d{8}'
p_telephone = re.compile(r)
p_telephone.findall('010-12345678')
//output ['010-12345678']
</code></li>
<li>and you can add attribute while compile</li>
</ul>
</li>
<li><p>there are some normal functions</p>

<ul>
<li>match

<ul>
<li>only search from the front</li>
<li><code>
p_telephone.match('o010-12345678')
//output nothing because the 010-12345678 is not start from the begin
</code></li>
</ul>
</li>
<li>search

<ul>
<li>search the whole string</li>
<li>no matter where the number is , if you can find it, you can find it.</li>
</ul>
</li>
<li>findall</li>
<li>finditer

<ul>
<li>the same as findall but you need to use iter so that you can get the value</li>
</ul>
</li>
</ul>
</li>
<li><p>and there are sub(), subn(), split()</p>

<ul>
<li>sub()

<ul>
<li><code>
r = r'c..t'
re.sub(r, 'aaa', 'caat cast cccc')
//output 'aaa aaa cccc'
</code></li>
</ul>
</li>
<li>subn()

<ul>
<li>the difference between sub and subj is that subj provide a count of the how many stuff you replace</li>
<li><code>
r = r'c..t'
re.subn(r, 'aaa', 'caat cast cccc')
//output 'aaa aaa cccc', 2
</code></li>
</ul>
</li>
<li>split()

<ul>
<li>split the string using a regular express</li>
<li><code>
re.split(r'[\+\*\-]', '1+2-3*5')
//output ['1', '2', '3', '5']
</code></li>
</ul>
</li>
<li>use <code>dir(re)</code> to see what functions re have</li>
</ul>
</li>
</ul>


<h3>flags in re module</h3>

<table>
<thead>
<tr>
<th>flags </th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotall, S</td>
<td> let . match all the character contains \n</td>
</tr>
<tr>
<td>ignore case, I </td>
<td>make the match no sensitive about the uppercase and lowercase</td>
</tr>
<tr>
<td>locale, L </td>
<td> do locale-aware match, match the French or the other language</td>
</tr>
<tr>
<td>multiline, M </td>
<td> match multiline, affect ^ and $</td>
</tr>
<tr>
<td>verbose, X </td>
<td> can use the REs verbose status, and make the organise more clearly</td>
</tr>
</tbody>
</table>


<h3>devision</h3>

<ul>
<li>()</li>
<li><code>email = r'\w{3}@\w+(\.com|\.cn)'</code></li>
<li>use the () to divide the .com and .cn</li>
<li>so that we can use the regular form to match email address</li>
</ul>

]]></content>
  </entry>
  
</feed>
