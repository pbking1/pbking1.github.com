<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[KING]]></title>
  <link href="http://pbking1.github.com/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2016-02-15T19:38:37-06:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hackathron_clothes_collection_and_some_other_pictures]]></title>
    <link href="http://pbking1.github.com/blog/2016/02/15/hackathron-clothes-collection-and-some-other-pictures/"/>
    <updated>2016-02-15T19:02:10-06:00</updated>
    <id>http://pbking1.github.com/blog/2016/02/15/hackathron-clothes-collection-and-some-other-pictures</id>
    <content type="html"><![CDATA[<h3>Post usage</h3>

<ul>
<li>The post is used for storing the clothes and other picture from hackathron</li>
</ul>


<!--more-->


<h3>Tools for resize the picture</h3>

<ul>
<li><a href="http://www124.lunapic.com/editor/">http://www124.lunapic.com/editor/</a></li>
</ul>


<h3>gallery</h3>

<ul>
<li>1.Indy redefine hackathron</li>
<li><p>location: Indianapolis, IN</p>

<ul>
<li><img src="http://pbking1.github.com/images/hackathron_clothes/indy.jpeg"></li>
</ul>
</li>
<li><p>2.Fashion hackathron</p></li>
<li>location: Kent, OH

<ul>
<li><img src="http://pbking1.github.com/images/hackathron_clothes/1.jpeg"></li>
<li><img src="http://pbking1.github.com/images/hackathron_clothes/2.jpeg"></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016_florida_hackFSU_hackathron_and_travel]]></title>
    <link href="http://pbking1.github.com/blog/2016/02/12/2016-florida-hackfsu-hackathron-and-travel/"/>
    <updated>2016-02-12T13:46:31-06:00</updated>
    <id>http://pbking1.github.com/blog/2016/02/12/2016-florida-hackfsu-hackathron-and-travel</id>
    <content type="html"><![CDATA[<h3>The second hackathron of the year</h3>

<!--more-->


<ul>
<li>This hackathron is held in florida state university, Tallassee

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/7.jpg"></li>
<li>before the check in, I found a restaurant that sells biscuit sandwish

<ul>
<li>However, the only thing I want to say about the food is &hellip;. it sucks.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/1.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>After arrive at florida state university</h4>

<ul>
<li>check in is the same as the other hackathron, just show them your student id.</li>
<li>Seems I am the only one that fly from chicago and arrive first. Those guys seems to be more excited than I am.</li>
</ul>


<h3>walk around the building</h3>

<ul>
<li>The hackathron is held in the science library.

<ul>
<li>Actually there are not much books and feels like more a living rather than a library.</li>
</ul>
</li>
<li>Some guys are setting up n64 game console and I feel really weird to see this kind of old stuff here.

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/2.jpg"></li>
</ul>
</li>
<li>One of the most important thing during this hackathron is that Apple company is sponsoring. And they are also looking for intern too.

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/3.jpg"></li>
</ul>
</li>
</ul>


<h4>opening ceremony</h4>

<ul>
<li>The opening ceremony is held somewhere else.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/4.jpg"></li>
</ul>


<h4>food</h4>

<ul>
<li>Oh my god, finally comes some rice not pizza and sandwish.</li>
<li>However, the quantity is limit and I eat 6 apple, drink 10 bottles of water during the weekend.</li>
<li>I hate the hackathron that do not provide enough food!!!</li>
<li>The food looks like some kind of mexican food or indiana food.

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/5.jpg"></li>
</ul>
</li>
</ul>


<h4>hardware provided</h4>

<ul>
<li>They actually provide a lot of hardware for you to play with.

<ul>
<li>arduino</li>
<li>3D printer</li>
<li>leap motion</li>
<li>oculus rift</li>
</ul>
</li>
</ul>


<h4>solo hackathron</h4>

<ul>
<li>This time, due to I am not quite interested in the project they provide during the team forming. I decided to work alone.</li>
<li>It is lucky that I found a room for myself.

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/6.jpg"></li>
</ul>
</li>
</ul>


<h4>about the project</h4>

<ul>
<li>I write a chrome plugin to analyse the comment and visualize it.</li>
<li>I was targeting the prize that provide by a sponsor which is an insurance company.

<ul>
<li>Althrough I do not get the prize, I still think my project is much better than the one is awarded.</li>
<li>So I am not help that company to promote by writing they name every where HAHAHAHAHAHAHAHA</li>
</ul>
</li>
<li>The poster I draw for the expo

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/8.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/9.jpg"></li>
</ul>
</li>
<li>The project code link is : <a href="https://github.com/pbking1/comment_visualizer">https://github.com/pbking1/comment_visualizer</a></li>
<li>The project video link is : <a href="https://www.youtube.com/watch?v=0JtgYmPjNis">https://www.youtube.com/watch?v=0JtgYmPjNis</a></li>
</ul>


<h4>after finishing the hackathron, Travel begin!</h4>

<ul>
<li>I fly to miami and stay in a house book using Airbnb

<ul>
<li>I have to say Airbnb and uber, lyft is one of the greatest thing invented in the past 2 years.</li>
</ul>
</li>
<li>The house is located in 1450 meridian Ave, just next to Miami beach.

<ul>
<li>The house is so nice that it provide almost everything I need.</li>
<li>Here are some pictures of it.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/10.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/11.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/12.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/13.jpg"></li>
</ul>
</li>
</ul>


<h4>Seafood</h4>

<ul>
<li>Well, due to I am confident to cook seafood better than most of the restaurant, I decide to go the fish market in the morning and buy myself some lobster, snow crab and king crab!

<ul>
<li>The Australian lobster is so big and taste fantastic!</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/14.jpg"></li>
</ul>
</li>
</ul>


<h4>Gun Shooting!</h4>

<ul>
<li>I always wants to go to the gun store and shot some guns!</li>
<li>The gun store I found is called &ldquo;Lock &amp; Load&rdquo;

<ul>
<li>not far away from Miami downtown.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/21.jpg"></li>
</ul>
</li>
<li><p>Here is some gun display on the wall</p>

<ul>
<li>AK47

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/15.jpg"></li>
</ul>
</li>
<li>Century Club

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/16.jpg"></li>
</ul>
</li>
<li>Sniper! My favorate one

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/17.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>Try the guns!</p>

<ul>
<li>FN HERSTAL SCAR 17 HEAVY(.308)

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/18.jpg"></li>
</ul>
</li>
<li>FN HERSTAL SAW M249 &ndash; BELF FED

<ul>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/19.jpg"></li>
</ul>
</li>
<li>BARRETT 50 CAL SNIPER EIFLE

<ul>
<li>The sniper is really loud and smell really bad.</li>
<li>But it feel badass when shooting it!</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/20.jpg"></li>
<li>The coach give me the bullet shell of the snipper

<ul>
<li>2016-2-5&mdash;2-7-hackFSU_florida<img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/32.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>Vizcaya Museum &amp; Gardens</h4>

<ul>
<li>After playing the guns, I go to the museum to get some fresh air.</li>
<li>Being a student is really nice because you have discount every where in US. HAHAHAHA</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/22.jpg"></li>
<li>This place is built by some one that wants to duplicate the European style.

<ul>
<li>Althrough I do not know much about those stuff, but I walk in such a big house and garden is really enjoyable.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/23.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/24.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/25.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/26.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/27.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/28.jpg"></li>
</ul>
</li>
</ul>


<h4>little havana</h4>

<ul>
<li>The only famous thing I saw from Internet that little havana is Versailles cuba restaurant

<ul>
<li>The food there is ok, but not as good as I can imaged</li>
<li>chicken

<ul>
<li>2016-2-5&mdash;2-7-hackFSU_florida<img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/29.jpg"></li>
</ul>
</li>
<li>oxtail

<ul>
<li>2016-2-5&mdash;2-7-hackFSU_florida<img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/30.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>Espanola way</h4>

<ul>
<li>Accidentally encounter this street on my way to the beach.</li>
<li>A lot of restaurant, not much to see.</li>
</ul>


<h4>Some interesting shop</h4>

<ul>
<li>Well, I am not expected to see this kind of old fashion shop in US.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/37.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/38.jpg"></li>
</ul>


<h4>Miami Beach and South Beach</h4>

<ul>
<li>Well, The sand, water here is really good.</li>
<li>However it&rsquo;s a pity that the temperature is not high enough to swim.</li>
<li>And no bikini !!!! The only reason I want to come to the beach is to see some bikini!</li>
<li>Except for the sand and water, the beach is not much excited because the beach in China has everything except the soft sand and clean water.</li>
<li>But it is quite enjoyable when walk on the sand.</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/34.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/35.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/36.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/40.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/41.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/42.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/43.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/44.jpg"></li>
</ul>


<h4>in the miami airport</h4>

<ul>
<li>It is quite funny when I see a AD that use japanese game charactor to advertise.</li>
<li>And the company is LV!</li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/46.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016-2-5--2-7-hackFSU_florida/47.jpg"></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016_ohio_fashion_hackathron]]></title>
    <link href="http://pbking1.github.com/blog/2016/02/12/2016-ohio-fashion-hackathron/"/>
    <updated>2016-02-12T13:02:13-06:00</updated>
    <id>http://pbking1.github.com/blog/2016/02/12/2016-ohio-fashion-hackathron</id>
    <content type="html"><![CDATA[<h3>The first hackathron of the year</h3>

<!--more-->


<ul>
<li>This hackathron is held in kent state university ohio

<ul>
<li>And the following is the schedule of it.

<ul>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/1.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>After arrive at kent state university</h4>

<ul>
<li>well, actually it is kind of country side so when I try to book a uber , I need to wait for 10+ mins.</li>
<li>When I arrived at the fashion school library, people there was still preparing for the hackathron check in. So I went to a donut restaurant to grab some food in case they do not provide foor at night.</li>
<li>Check in is really boring, if you get a student id from a US university, you will be good to go.</li>
</ul>


<h3>walk around the building</h3>

<ul>
<li>well, the product designed here is actully not bad

<ul>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/3.jpg"></li>
</ul>
</li>
</ul>


<h4>skip the boring opening ceremony</h4>

<ul>
<li>They actually provide a lot of hardware for you to play with.

<ul>
<li>arduino</li>
<li>body scanner

<ul>
<li>one of my teammate go in and try the machine. however the data is not quite useful.</li>
</ul>
</li>
<li>two 3D printer

<ul>
<li>well, in this hackathron many people use the printer and the printer actually help them a lot</li>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/4.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/5.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/6.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>about the project</h3>

<ul>
<li>We create a product that would bridge the sustainability information gap between shoppers and companies.

<ul>
<li>The website gives shoppers the knowledge they need in order to make sustainable fashion choices.</li>
</ul>
</li>
<li>The project code link is : <a href="https://github.com/pbking1/fashion_hackathron_project">https://github.com/pbking1/fashion_hackathron_project</a></li>
<li>The project video link is : <a href="https://www.youtube.com/watch?v=F1uz8_mpKC4">https://www.youtube.com/watch?v=F1uz8_mpKC4</a></li>
</ul>


<h3>after finishing the project, expo</h3>

<ul>
<li>My teammate will introduce the project in the expo and when it comes to the tech detail. I will be answering.

<ul>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/7.jpg"></li>
</ul>
</li>
<li>There  are actually some good design in this hackathron.

<ul>
<li><p>1.This one put two eletronic board on the eye glass. and you will be able to change the picture display on it.</p>

<ul>
<li>a good tools for party.</li>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/8.jpg"></li>
</ul>
</li>
<li><p>2.This one embed a eletronic board on the bag and you will be able to change the light display on it.</p>

<ul>
<li>a good tools for party.</li>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/9.jpg"></li>
</ul>
</li>
<li><p>3.These two, look like they use tech on scarf and bra.</p>

<ul>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/10.jpg"></li>
<li><img src="http://pbking1.github.com/images/2016_1-29--1-31-hackFashion_ohio/11.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tech Interview Prepare resource]]></title>
    <link href="http://pbking1.github.com/blog/2015/08/19/tech-interview-prepare-resource/"/>
    <updated>2015-08-19T14:21:39-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/08/19/tech-interview-prepare-resource</id>
    <content type="html"><![CDATA[<h3>Review project</h3>

<ul>
<li>familiar with the project and algorithm you used to do</li>
<li>review the algorithm and how you optimise it</li>
<li>review the syntax of the programming language you used</li>
<li>review the framework of the project you use</li>
</ul>


<h3>Review resource</h3>

<ul>
<li><p>data structure(very important)</p>

<ul>
<li><a href="http://www.geeksforgeeks.org/data-structures/">http://www.geeksforgeeks.org/data-structures/</a></li>
</ul>
</li>
<li><p>leetcode</p>

<ul>
<li>understand the question and implement at least 3 times before interview in big company</li>
</ul>
</li>
<li><p>careercup</p>

<ul>
<li>a lot of company interview question</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[computer architecture final exam review]]></title>
    <link href="http://pbking1.github.com/blog/2015/05/04/computer-architecture-final-exam-review/"/>
    <updated>2015-05-04T22:07:15-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/05/04/computer-architecture-final-exam-review</id>
    <content type="html"><![CDATA[<!--more-->


<h3>memory</h3>

<ul>
<li><p>Memory Hierarchy</p>

<ul>
<li>Understand what is memory wall? Why it is a bottleneck?瓶颈

<ul>
<li>内存壁垒：处理器和内存的悬殊持续增长</li>
<li>瓶颈：好的内存架构设计对系统的性能有越来越高的重要性</li>
</ul>
</li>
<li>Illusion provided from a memory hierarchy

<ul>
<li>大的内存都是很慢的，但是caching可以give 错觉他们很快</li>
<li>所以这个错觉可以是

<ul>
<li>caching + virtual memory 能够是的内存变快</li>
</ul>
</li>
<li>传统的内存层级

<ul>
<li>通过使用局部性的优势

<ul>
<li>能够尽可能的利用磁盘上能够使用的内存</li>
<li>速度也会很快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Principle of locality (two types of locality)

<ul>
<li>定义:程序每次会使用一小部分的地址空间

<ul>
<li>temporal locality

<ul>
<li>曾经使用过的程序，再次被使用的可能会很大</li>
<li>比如循环中的指令和数据</li>
</ul>
</li>
<li>spatial locality

<ul>
<li>在执行过的程序附近的程序被使用的可能性很大</li>
<li>例如顺序执行中的数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DDR RAM? Relationship between memory clock rate and memory bandwidth

<ul>
<li>mobile system require 2X bandwidth every 2 years</li>
</ul>
</li>
<li><p>DDR DRAM 叫double data rate DRAM</p>

<ul>
<li>transfer data on rising and falling clock edges</li>
<li>E.g., 800MHz DDR &ndash;> BW?</li>
</ul>
</li>
<li><p>Know how to calculate Average Disk Read Time</p>

<ul>
<li>average disk read time = seek time + rotation latency + transfer time + controller delay</li>
<li>rpm = revolution per minutes</li>
<li>e.g

<ul>
<li>512B sector, 15000rpm, 4ms average seek time, 100MB/s transfer rate, 0.2ms controller overhead, idle disk</li>
<li> time = 4ms seek time +

<ul>
<li>(&frac12;)/(15000/60) = 2ms rotationl latency</li>
<li>512/100MB/s = 5.12 s = 0.00512ms transfer time</li>
<li>0.2ms controller delay</li>
<li>= 6.2 ms</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Difference between three types of caches:</p>

<ul>
<li><strong>Direct-mapped cache</strong>

<ul>
<li>根据索引表映射哪个cache块用来存数据</li>
<li>一个block只能有一个选择存哪里</li>
<li>内存块的那一个位置分配给cache的某个位置，由后三位决定（假设有8个块（2<sup>3</sup>=8））

<ul>
<li>001：00001，01001，10001，11001</li>
</ul>
</li>
<li>用valid bit来判断cache的数据<strong>是否存在</strong>内存那个位置</li>
<li>tag用来判断cache的数据在内存哪个位置</li>
<li><strong>重点</strong>

<ul>
<li>index不存在cache里面，就像数组不会存索引</li>
<li>假设有一个word：22

<ul>
<li>首先转成二进制10110</li>
<li>然后后三位位index</li>
<li>前两位为tag</li>
<li>然后把数据存入对应位置</li>
<li>因为没存进来的时候，对应位置没有数据，所以为miss（第一次访问那个内存地址），存入之后，才会变成hit</li>
<li>然后数据valid bit变成Y</li>
</ul>
</li>
</ul>
</li>
<li> 假设一个cache有32 bit的地址

<ul>
<li> tag:22bits</li>
<li> index:4bits</li>
<li> offsets:6bits</li>
<li> 那么 cache block size 为2<sup>6</sup> byte</li>
<li> 那么 cache有2<sup>4</sup> entries</li>
</ul>
</li>
</ul>
</li>
<li>n-way Set-associative cache

<ul>
<li>每个set都有n个成员</li>
<li>用块的号数来决定哪个set</li>
<li>在给定的set中搜索全部成员（因为set里面的成员少，所以搜索起来快）

<ul>
<li>那么就只要比较n次，更加省时间</li>
</ul>
</li>
<li>假设一个cache有2<sup>s</sup>个sets， 并且每个block有2<sup>n</sup>个bytes。

<ul>
<li>那么block offset为n</li>
<li>index为s</li>
<li>假设address长度为m

<ul>
<li>则tag长度为m-s-n</li>
</ul>
</li>
<li>计算set index

<ul>
<li>block address = memory address / 2<sup>n</sup></li>
<li>set index = block address % 2<sup>s</sup></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Fully associative cache

<ul>
<li>cache可以映射到内存中任何一个位置</li>
<li>所有成员都要搜索一次</li>
<li>耗费时间长，每个成员都要对比, 每个block的tag都要对比</li>
</ul>
</li>
</ul>
</li>
<li>For each of the above cache type

<ul>
<li><p>How to calculate a block(or set) index give an address?</p>

<ul>
<li>miss: load 的数据不再memory里面

<ul>
<li>every miss always load the 64 byte</li>
</ul>
</li>
<li>如何选block size

<ul>
<li>用两种方式

<ul>
<li>early restart

<ul>
<li>CPU在等第一个byte，但是64byte还没load进去</li>
<li>或者可以先读第一个byte， 不用等他读完</li>
</ul>
</li>
<li>critical word first</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>How to subdivide an address given a cache design, or vice versa?</p></li>
</ul>
</li>
<li>Write back vs write through（write hit）

<ul>
<li>write through

<ul>
<li>如果write hit， 则更新缓存里面的block和memory里面的block</li>
<li>这样缓存和内存里面的数据就同步了</li>
<li>但是会使得数据的写更长时间

<ul>
<li>解决方案：使用write buffer

<ul>
<li>把要写入内存的数据hold waiting</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>write back</p>

<ul>
<li>当你更新数据的时候，只改cache里面的数据</li>
<li>速度快</li>
</ul>
</li>
<li><p>两者使用的差别</p>

<ul>
<li>如果写的频率高的时候，write back快</li>
</ul>
</li>
</ul>
</li>
<li>Write allocate vs no write allocate (on write miss)

<ul>
<li>allocate

<ul>
<li>fetch the block</li>
</ul>
</li>
<li>no allocate

<ul>
<li>do not fetch the block</li>
</ul>
</li>
</ul>
</li>
<li><p>condition</p>

<ul>
<li>if read hit: cpu continue</li>
<li>if write hit: write through or write back</li>
<li>if read miss: store pipeline, read data to pipeline and continue</li>
<li>if write miss: write through (allocate or no allocate)</li>
</ul>
</li>
<li><p>Know how to calculate AMAT, actual CPI</p>

<ul>
<li>AMAT: average memory access time

<ul>
<li>hit time + miss rate * miss penalty</li>
<li>如果是两层

<ul>
<li>AMAT = hit time1 + miss rate1 * (hit time2 + miss rate2 * miss penalty2)</li>
</ul>
</li>
</ul>
</li>
<li><p>actual CPI : cpu time divide into 2 parts</p>

<ul>
<li>cpu execution clock cycles</li>
<li>memory stall clock cycles

<ul>
<li>(instruction / program)* <strong>(misses/introduction)</strong> * miss penalty</li>
</ul>
</li>
<li>miss penalty = main memory access time / clock cycle</li>
<li>Effective CPI = bass CPI + L1 Miss rate * L2 Hit Time + L2 global miss rate * L2 Miss time</li>
<li>AMAT = L1 Hit time + L1 miss rate * L2 Hit time + L2 global miss rate * L2 Miss time</li>
<li>performance = 慢的/快的</li>
<li>e.g

<ul>
<li>CPU base CPI = 1, clock rate = 4GHz</li>
<li>Miss rate / instruction = 2%</li>
<li>Main memory access time = 100ms

<ul>
<li>then if there is only primary memory

<ul>
<li>Miss penalty = 100ns / clock cycle</li>
<li>clock cycle = 1/clock rate = 0.25

<ul>
<li>Miss penalty = 400 cycle</li>
</ul>
</li>
<li>Effective CPI = 1 + 2% * 400 = 9 cycle</li>
</ul>
</li>
</ul>
</li>
<li>then suppose we add L-2 cache

<ul>
<li>L2 cache access time = 5ns</li>
<li>L2 global miss rate = 0.5%

<ul>
<li>L2 Hit time = 5ns / clock cycle = 5ns / 0.25 = 20 cycles</li>
<li>L2 Miss time = 400 cycles</li>
<li>Effective CPI = 1 + 2% * 20 + 0.5% * 400 = 3.4 cycle</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>E.g. on a machine with one or two level caches</p></li>
<li>3 formulas (two from lectures, one from the HW 6 solution)</li>
</ul>
</li>
<li><p>Know what is LRU(least recent use) replacement policy</p></li>
<li>Virtual memory

<ul>
<li>1K = 2<sup>10</sup>

<ul>
<li>1K * 1K = 1M</li>
</ul>
</li>
<li>What is page table

<ul>
<li>用来在物理内存里面找一个页的</li>
<li>PTE:page table entries

<ul>
<li>indexed by virtual page</li>
</ul>
</li>
<li>如果page不在内存里面

<ul>
<li>PTE存物理page的数字</li>
</ul>
</li>
<li>如果page在内存里面

<ul>
<li>PTE refer to一个磁盘的位置</li>
</ul>
</li>
<li>dirty bit set to 1 当一个page被改动过</li>
</ul>
</li>
<li>Address subdivision</li>
<li>How to translate a virtual address to a physical address

<ul>
<li>CPU and OS translate virtual address to physical address</li>
<li>The CPU sends virtual address to MMU</li>
<li>The MMU send physical address to the memory</li>
</ul>
</li>
<li>Purpose of MMU

<ul>
<li>转换虚拟地址和物理地址</li>
</ul>
</li>
<li>What is page fault

<ul>
<li>其实相当于cache miss</li>
<li>当你有一个page fault，这个page就要被fetch from磁盘到内存</li>
<li>如何减少page fault？

<ul>
<li>全关联placement</li>
<li>小页面替换算法</li>
</ul>
</li>
</ul>
</li>
<li>How a page fault handler works?

<ul>
<li>use faulting virtual address to find PTE</li>
<li>locate page on disk</li>
<li>choose page to replace

<ul>
<li>if dirty, write the page to disk first</li>
</ul>
</li>
<li>read page into memory and update page table</li>
<li>make process runnable again

<ul>
<li>restart from faulting instruction</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>假设virtual address = 43 bits, page size = 4KB, PTE size = 4 byte</p>

<ul>
<li>那么对于单层 page table， 需要多少个PTES？

<ul>
<li>page size = 4KB = 2<sup>12</sup></li>
<li>那么最差要2<sup>43-12</sup></li>
</ul>
</li>
<li>那么需要存这个page table要多少物理内存？

<ul>
<li>2<sup>43-12</sup>*4 byte</li>
<li>2<sup>31</sup>*2<sup>2</sup> = 2<sup>33</sup></li>
</ul>
</li>
</ul>
</li>
<li><p>Know what is TLB</p>

<ul>
<li>Translate look-aside Buffer

<ul>
<li>TLB的miss由硬件或者软件控制</li>
<li>a spacial cache of page table entries within CPU</li>
</ul>
</li>
<li>Understand the interaction between TLB and caches

<ul>
<li>cache rage use physical address

<ul>
<li>need to translate before cache</li>
</ul>
</li>
</ul>
</li>
<li>TLB cache is a page table entries</li>
</ul>
</li>
<li><p>Know the sources of cache misses (3 Cs model) <strong>必考</strong></p>

<ul>
<li>三种类型的miss

<ul>
<li>compulsory miss

<ul>
<li>第一次访问会导致这种miss</li>
<li>因为第一次访问的时候数据不会在内存里面</li>
<li>解决方案

<ul>
<li>假设一个block只能存一个byte，然后我们要load 128 byte的数据

<ul>
<li>那么我们就要load 128次</li>
<li>但是如果把block增大成128 byte，那么我们只要存一次</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>capacity miss

<ul>
<li>理论上存在，实际的机器是不存在的</li>
<li>只有full associate cache</li>
<li>空间不足</li>
<li>解决方案

<ul>
<li>增大cache size</li>
</ul>
</li>
</ul>
</li>
<li>conflict miss

<ul>
<li>假设有两个entry，但是有100个要进去

<ul>
<li>这个时候就会发生这种miss</li>
</ul>
</li>
<li>也就是资源竞争</li>
<li>解决方案

<ul>
<li>增加关联性</li>
</ul>
</li>
<li>不存在于full associate cache</li>
</ul>
</li>
</ul>
</li>
<li>What about the fourth C?</li>
</ul>
</li>
<li><p>Software optimisation techniques: AVX, Loop Unrolling, Blocking?</p>

<ul>
<li>blocking

<ul>
<li>maximise accesses to data before it is replaced</li>
<li>应该就是访问数据之前，先把空间申请了</li>
</ul>
</li>
</ul>
</li>
<li><p>A few fallacies and pitfalls</p>

<ul>
<li><p>1.在多核CPU里里面，并且有shared的L2和L3cache</p>

<ul>
<li>如果关联性不够core多的话，会导致 conflict miss

<ul>
<li>e.g

<ul>
<li>如果有一个8核CPU，那么至少需要一个8-way的set 关联cache</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.用AMAT来评估一个out-of-order processor的性能</p>

<ul>
<li>忽略effect of non-blocking accesses(continuing execution on misses)</li>
<li>instead, evaluate performance by simulation</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>parallel processor</h3>

<ul>
<li>Amdahl&rsquo;s law

<ul>
<li>知道公式以及知道如何计算</li>
<li>公式

<ul>
<li>speedup = 1/[(1-F)+F/P]</li>
<li>F为并行化的百分比</li>
<li>P为处理器数量</li>
<li>e.g

<ul>
<li>我们有100个处理器，想要90倍的speedup</li>
<li>1/[(1-F) + F/100] = 90

<ul>
<li>F = 89*100/(99*90) = 99.9%</li>
<li>所以非并行的部分必须要&lt;=0.1%</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>strong scaling(缩放) and weak scaling

<ul>
<li><p>scaling</p>

<ul>
<li>e.g1 10*10 matrix

<ul>
<li>从10个处理器加速到100个处理器，speedup是多少

<ul>
<li>首先在单个处理器：time=(10+100)*Tadd=110*Tadd</li>
<li>10个处理器

<ul>
<li>time=10*Tadd + (10*10)/10*Tadd = 20*Tadd</li>
<li>speedup = 110/20=5.5</li>
</ul>
</li>
<li>100个处理器

<ul>
<li>time=10*Tadd + (10*10)/100*Tadd = 11*Tadd</li>
<li>speedup = 110/11 = 10</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>strong scaling</p>

<ul>
<li>数据规模确定</li>
</ul>
</li>
<li>weak scaling

<ul>
<li>数据规模和处理器的数量有关</li>
<li>例如

<ul>
<li>我们有10个处理器，那么数组的规模就是10*10</li>
<li>如果有100个处理器，那么数组的规模就是100*100</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>good understanding of hardware threading

<ul>
<li>增加单个核的资源利用率</li>
<li>在thread里面，dependency handled by scheduling and register renaming</li>
<li>不同的thread里面的指令在函数单元available 的时候执行</li>
<li>每个cycle都没有thread switching</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[operating system final exam review]]></title>
    <link href="http://pbking1.github.com/blog/2015/05/04/operating-system-final-exam-review/"/>
    <updated>2015-05-04T00:16:19-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/05/04/operating-system-final-exam-review</id>
    <content type="html"><![CDATA[<!--more-->


<h3>charpter 8 Main Memory</h3>

<ul>
<li>background

<ul>
<li><p>address binding内存绑定</p>

<ul>
<li>在三个时间发生

<ul>
<li>编译时间

<ul>
<li>如果内存地址确定，那么就生成<strong>absolute</strong>的代码：如果内存的起始地址改变了，代码就要重新编译</li>
</ul>
</li>
<li>载入时间

<ul>
<li>如果内存地址再编译时间不是确定的，就要生成<strong>relocatable</strong>(可重定位)的代码</li>
</ul>
</li>
<li>执行时间

<ul>
<li>如果进程能够重一个内存段移动到另外一个内存段，那么就把绑定地址延迟到run time。需要硬件支持</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>logical and physical address space逻辑地址和物理地址</p>

<ul>
<li>logical address

<ul>
<li>CPU生成的地址，也就是虚拟地址</li>
</ul>
</li>
<li>physical address

<ul>
<li>内存单元看见的地址</li>
<li>加载到寄存器中的地址</li>
</ul>
</li>
<li>不同

<ul>
<li>在编译时间和载入时间logical地址和physical地址一样</li>
<li>在执行时间的时候不一样</li>
</ul>
</li>
</ul>
</li>
<li>Memory management Unit(MMU)

<ul>
<li>用于映射虚拟地址到物理地址</li>
<li>因为真实的程序用的都是逻辑地址</li>
</ul>
</li>
<li>dynamic linking动态链接

<ul>
<li>和动态加载的不同在于

<ul>
<li>不是把加载延迟到运行时，而是将连接延迟到运行时</li>
</ul>
</li>
<li>常用于系统库</li>
</ul>
</li>
<li>dynamic loading动态加载

<ul>
<li>一个子程序只有在调用时才被加载，所有子程序都以可重定位的形式保存在磁盘上。</li>
<li>优点：

<ul>
<li>不用的子程序不会被装入内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>swapping交换空间

<ul>
<li>内存需要在内存中来执行</li>
<li>但是进程可以暂时从内存中交换出来到备份储存上，在执行的时候再调回内存</li>
<li>交换时间的主要消耗是在传输时间</li>
</ul>
</li>
<li>contiguous memory allocation连续内存分配<em>必考</em>

<ul>
<li>动态内存分配

<ul>
<li>首次适应</li>
<li>最佳适应</li>
<li>最差适应</li>
</ul>
</li>
</ul>
</li>
<li>segmentation分段

<ul>
<li>a segment is a logical unit

<ul>
<li>比如

<ul>
<li>main program</li>
<li>procedure</li>
<li>function</li>
<li>method</li>
<li>object</li>
<li>common lock</li>
<li>stack</li>
<li>array</li>
</ul>
</li>
</ul>
</li>
<li>外部碎片

<ul>
<li>放不进内存的块</li>
<li>因为内存被用完了，剩下的空间大小不足

<ul>
<li>因此本来要放进去的块，放不进去了</li>
</ul>
</li>
</ul>
</li>
<li>内部碎片

<ul>
<li>内存空间剩下的那些一点点的空间，放不下其他的块</li>
<li>这些小小的空间就是内部碎片</li>
</ul>
</li>
</ul>
</li>
<li>paging分页

<ul>
<li>进程的块也叫页</li>
<li><p>把页平均分成一定数量的页</p>

<ul>
<li>这样分配空间的时候可以更充分地利用空间</li>
<li>并且不会有外部碎片，只会有内部碎片</li>
</ul>
</li>
<li><p>page table</p>

<ul>
<li>use to translate logical to physical address</li>
<li>address is devided into

<ul>
<li>page number

<ul>
<li></li>
</ul>
</li>
<li>page offset</li>
</ul>
</li>
<li>implementaion

<ul>
<li>PTBR 页表基寄存器

<ul>
<li>point to page to table</li>
</ul>
</li>
<li>PRLR 页长寄存器

<ul>
<li>indicate size of the page table</li>
</ul>
</li>
<li>TLB 翻译后备缓冲器

<ul>
<li>又叫关联内存</li>
<li>special fast-lookup cache</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>effective memory-access time 有效内存访问时间

<ul>
<li>EAT = 内存映射反应时间<em>命中率 + （1-命中率）</em>（内存映射反应时间+额外时间）</li>
</ul>
</li>
<li>valid-invalid bit

<ul>
<li>用于保护</li>
<li>valid的意思是要找的页在进程的逻辑地址空间里面</li>
<li>invalid的意思是是不在</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>charpter 9 virtual memory</h3>

<ul>
<li>background

<ul>
<li>因为程序执行的时候只需要一部分程序在内存里面</li>
<li>把user的逻辑内存从物理内存里面分离出来</li>
<li>进程中所有寄存器访问的地址都是逻辑地址，这些逻辑地址在运行的时候被转换成物理地址</li>
<li>效果

<ul>
<li>主存中保留多个进程</li>
<li>进程可以比主存的全部空间还大</li>
</ul>
</li>
</ul>
</li>
<li><p>demand paging</p>

<ul>
<li>lazy swapper

<ul>
<li>只有在需要的时候才把页调进主存

<ul>
<li>可以造成更少的I/O</li>
<li>更少的内存使用</li>
<li>更快的速度</li>
<li>更多的用户</li>
</ul>
</li>
</ul>
</li>
<li>如果页已经在内存里面了，那么这个页就是valid

<ul>
<li>否则就是invalid(造成page fault，因为是对无效地址的访问)</li>
</ul>
</li>
</ul>
</li>
<li><p>page replacement</p>

<ul>
<li>FIFO

<ul>
<li>每次换第一个</li>
</ul>
</li>
<li>opt

<ul>
<li>淘汰离现在最长时间后再访问的页</li>
</ul>
</li>
<li>LRU

<ul>
<li>把离现在最远没有调用的换掉</li>
</ul>
</li>
</ul>
</li>
<li>allocation of frame

<ul>
<li>equal allocation

<ul>
<li>在n个进程之间分配m个frame

<ul>
<li>那么就是平均每个进程一个平均值m/n</li>
</ul>
</li>
</ul>
</li>
<li>proportional allocation

<ul>
<li>gloabl replacement</li>
<li>local replacement</li>
</ul>
</li>
</ul>
</li>
<li>thrashing

<ul>
<li>频繁的把页调出去又调进来，导致严重的性能问题</li>
<li><p>working-set model</p></li>
<li><p>page fault frequency</p></li>
</ul>
</li>
</ul>


<h3>charpter 10 Mass-storage structure</h3>

<ul>
<li>disk structure

<ul>
<li>logical block

<ul>
<li>disk drive被addressed做一位数组的逻辑块

<ul>
<li>这些块是传输的最小单元</li>
</ul>
</li>
</ul>
</li>
<li>CLV</li>
<li>CAV</li>
</ul>
</li>
<li>disk attachment

<ul>
<li>host attached storage accessed through I/O ports talking to I/O busses</li>
</ul>
</li>
<li>disk scheduling

<ul>
<li>access latency

<ul>
<li>= Average access time = average seek time + average latency</li>
</ul>
</li>
<li>seek time

<ul>
<li>寻道时间</li>
<li>约等于seek distance</li>
</ul>
</li>
<li>rotational latency</li>
<li>bandwidth

<ul>
<li>byte 传输的总数</li>
</ul>
</li>
<li>algorithm

<ul>
<li>比如有queue:98，183，37，122，14，124，65，67
  -start from 53</li>
<li>FCFS

<ul>
<li>从头加到尾</li>
<li>所以执行队列

<ul>
<li>53，98，183，37，122，14，124，65，67</li>
</ul>
</li>
</ul>
</li>
<li>SSTF

<ul>
<li>最常用</li>
<li>把绝对值离起点最近点依次加入</li>
<li>所以执行队列

<ul>
<li>首先排序

<ul>
<li>14，37，65，67，98，122，124，183</li>
</ul>
</li>
<li>然后找离起点绝对值最小的

<ul>
<li>53，65，67，37，14，98，122，124，183</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SCAN

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从右扫到左</li>
<li>所以执行队列

<ul>
<li>首先排序

<ul>
<li>14，37，65，67，98，122，124，183</li>
</ul>
</li>
<li>53，37，14，0，65，67，98，122，124，183，255</li>
</ul>
</li>
</ul>
</li>
<li>C-SCAN

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从头扫到尾</li>
<li>所以执行队列

<ul>
<li>首先排序

<ul>
<li>14，37，65，67，98，122，124，183</li>
</ul>
</li>
<li>53，65，67，98，122，124，183，255，0，14，37</li>
</ul>
</li>
</ul>
</li>
<li>LOOK

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从右扫到左</li>
<li>执行队列不含有0和255

<ul>
<li>53，37，14，65，67，98，122，124，183</li>
</ul>
</li>
</ul>
</li>
<li>C-LOOK

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从头扫到尾</li>
<li>53，65，67，98，122，124，183，14，37</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>disk management

<ul>
<li>low level formatting

<ul>
<li>physical formatting</li>
<li>divide a disk into sectors that the disk controller can read and write</li>
<li>把disk分成几个sector</li>
</ul>
</li>
<li>bootstrap被存储在ROM里面</li>
</ul>
</li>
<li><p>swap-space management</p>

<ul>
<li>虚拟内存使用磁盘空间来作为内存的extension</li>
<li>因为虚拟内存的使用是

<ul>
<li>程序只有一部分在内存里面，其他的部分都放在磁盘上</li>
<li>只有在需要使用其他部分的时候才会把哪些部分放进内存</li>
</ul>
</li>
</ul>
</li>
<li><p>RAID structure</p>

<ul>
<li><p>redundant array of inexpensive disks</p></li>
<li><p>reliability</p>

<ul>
<li>通过redundancy是的多个disk drives提供可靠性</li>
</ul>
</li>
<li><p>MTTF</p>

<ul>
<li>mean time to failure</li>
</ul>
</li>
<li><p>MTTR</p>

<ul>
<li>mean time to repair</li>
<li>exposure time when another failure could cause data loss</li>
</ul>
</li>
<li>data striping

<ul>
<li>把一组disk用作一个存储单元</li>
</ul>
</li>
<li>bit-level</li>
<li>block-level</li>
</ul>
</li>
</ul>


<h3>charpter 11 file system interface</h3>

<ul>
<li><p>file concept</p>

<ul>
<li><p>file attribute</p>

<ul>
<li>name</li>
<li>id</li>
<li>type</li>
<li>date</li>
<li>size</li>
<li>protection</li>
</ul>
</li>
<li><p>file operation</p>

<ul>
<li>read</li>
<li>write</li>
<li>execute</li>
<li>delete</li>
<li>create</li>
<li>seek</li>
<li>open</li>
<li>close</li>
</ul>
</li>
<li>file type

<ul>
<li>data

<ul>
<li>numeric</li>
<li>charactor</li>
<li>binary</li>
</ul>
</li>
<li>program</li>
</ul>
</li>
</ul>
</li>
<li><p>access method</p>

<ul>
<li>sequential access顺序访问

<ul>
<li>一个记录接着一个记录的访问</li>
<li>常用于文件读写</li>
</ul>
</li>
<li>direct access直接访问

<ul>
<li>文件由固定长度的逻辑记录组成，允许任何程序按照任意顺序进行快速读和写</li>
<li>基于文件的磁盘模式</li>
<li>常用语数据库</li>
</ul>
</li>
</ul>
</li>
<li>directory and disk structure

<ul>
<li>single level directory

<ul>
<li>相当于单层map

<ul>
<li>&lt;command,file></li>
</ul>
</li>
</ul>
</li>
<li>two level directory

<ul>
<li>每个用户都有自己的文件目录</li>
<li>相当于双层map

<ul>
<li>第一层变成&lt;user,command></li>
<li>第二层变成&lt;command,file></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>tree structure directory

<ul>
<li>general graph directory

<ul>
<li>其实和双层很像，前两层一样

<ul>
<li>第三层开始多了很多别的命令的map</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>file system mounting

<ul>
<li>mount point

<ul>
<li>文件系统使用之前必须要mount</li>
<li>也就是说目录结构要建立在多个分区上就必须安装这些分区来使其可用</li>
<li>mount point 通常是空目录

<ul>
<li>用于安装文件系统</li>
<li>e.g unix常常安装在/home

<ul>
<li>这样访问这个文件系统的目录结构的时候

<ul>
<li>只要加上这个/home前缀就可以了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>charpter 12 file system implementation</h3>

<ul>
<li>file system structure

<ul>
<li>文件结构

<ul>
<li>逻辑存储单元</li>
<li>相关信息的收集</li>
</ul>
</li>
<li>文件系统依赖磁盘</li>
<li>磁盘提供random access和inplace write</li>
<li>file control block

<ul>
<li>记录文件信息</li>
</ul>
</li>
<li>device driver</li>
<li>layer file system

<ul>
<li>应用程序->逻辑文件系统->文件组织模块->基本文件系统->I/O控制->设备</li>
</ul>
</li>
</ul>
</li>
<li>file system implementation

<ul>
<li>使用多个磁盘和内存结构

<ul>
<li>boot control block

<ul>
<li>包括系统冲该分区引导操作系统所需要的信息</li>
</ul>
</li>
<li>partition control block

<ul>
<li>包括分区的详细信息</li>
</ul>
</li>
</ul>
</li>
<li>VFS

<ul>
<li>虚拟文件系统允许使用同样的系统调用API来使用不同类型的文件系统</li>
</ul>
</li>
</ul>
</li>
<li>directory implementation
  -使用线性表和hash表来指向数据块</li>
<li><p>allocation method</p>

<ul>
<li>disk block给文件的分配方法</li>
<li>连续分配

<ul>
<li>continguous allocation</li>
<li>每个文件使用一个集合的连续块</li>
</ul>
</li>
<li>链式分配

<ul>
<li>每个文件都有一个链表的block</li>
</ul>
</li>
<li>index分配

<ul>
<li>每个文件都有他自己的index block</li>
</ul>
</li>
</ul>
</li>
<li><p>free space management</p>

<ul>
<li>文件系统使用free space list 来跟踪可以使用的block</li>
<li>bit vector</li>
<li>bit map</li>
<li>Grouping</li>
<li>counting</li>
</ul>
</li>
<li><p>efficiency and performance</p>

<ul>
<li>效率

<ul>
<li>取决于所使用的磁盘分配和目录管理算法</li>
<li>首先是只要是磁盘就会有一定的空间用来存索引节点

<ul>
<li>因为索引会加快查询</li>
</ul>
</li>
</ul>
</li>
<li>性能

<ul>
<li>增加复杂的index</li>
</ul>
</li>
</ul>
</li>
<li><p>recovery</p>

<ul>
<li>consistency checking

<ul>
<li>compare data in directory structure with data block on disk and try to fix inconsistencies</li>
<li>慢而且容易失败</li>
</ul>
</li>
<li>用系统程序备份数据</li>
<li>用备份恢复系统程序</li>
</ul>
</li>
<li><p>log structured file system</p>

<ul>
<li>用来记录每个metadata的更新</li>
</ul>
</li>
<li><p>NFS</p>

<ul>
<li>一个用来通过网络远程access file的软件系统</li>
</ul>
</li>
</ul>


<h3>charpter 13 I/O system</h3>

<ul>
<li>I/O hardware

<ul>
<li><p>basic</p>

<ul>
<li>port端口

<ul>
<li>设备的连接点</li>
</ul>
</li>
<li>bus总线

<ul>
<li>直接共享连接</li>
</ul>
</li>
<li>controller控制器

<ul>
<li>操作port，bus，device的电子元件</li>
</ul>
</li>
<li>I/O指令控制设备</li>
</ul>
</li>
<li><p>SCSI</p>

<ul>
<li>SCSI总线控制器常常是纤维和计算机相连接的独立线路板或者主机适配器</li>
</ul>
</li>
<li><p>memory mapped I/O</p>

<ul>
<li>内存映射I/O

<ul>
<li>设备数据和指令寄存器映射到处理器的地址空间</li>
<li>例如，PC可以用I/O指令来控制一些设备，并且使用内存映射I/O来控制其他设备</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O port register</p></li>
<li>polling轮询

<ul>
<li>主机和控制器之间的交互完成协议需要握手</li>
<li>过程

<ul>
<li>首先<strong>忙等待</strong>读取忙bit</li>
<li>然后如果接到下一个命令，就清除忙bit</li>
<li>然后通过命令寄存器里面的命令就绪bit来表示其意愿</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>interrupt

<ul>
<li>设备控制器通过catch中断并且dispatch到中断处理程序</li>
<li>中断处理程序通过处理设备来清除中断</li>
<li>终端也可以用与异常处理</li>
</ul>
</li>
<li>DMA

<ul>
<li>直接内存访问</li>
<li>direct memory access</li>
<li>用于避免对大规模数据移动使用I/O</li>
<li>这样无需cpu的帮助也可以把地址放到总线然后开始传输</li>
</ul>
</li>
<li>Kernal I/O subsystem

<ul>
<li>I/O scheduing

<ul>
<li>有一些I/O请求通过设备队列来排序</li>
<li>有一些操作系统使用公平式的</li>
<li>有一席实现服务质量</li>
</ul>
</li>
<li>buffering

<ul>
<li>在设备之间传输数据的时候把数据存在内存里面</li>
<li>为了解决以下两种情况

<ul>
<li>设备速度不一样</li>
<li>设备传输大小不一样</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>安全</h3>

<ul>
<li><p>goal of protection</p>

<ul>
<li>确保每个对象的访问都是正确的，没有越权访问</li>
</ul>
</li>
<li><p>principal of protection</p>

<ul>
<li>最低优先级准则

<ul>
<li>给程序分配他所需要的最低优先级</li>
</ul>
</li>
</ul>
</li>
<li><p>domain of protection</p>

<ul>
<li><p>domain:set of access right</p>

<ul>
<li>等于user id</li>
<li>在文件系统之间交换</li>
</ul>
</li>
<li><p>domain：可以含有user, process, procedure</p></li>
<li>access-right: &lt;object-name, right-set></li>
</ul>
</li>
<li><p>accesss matrix</p>

<ul>
<li>行：domain</li>
<li>列：object</li>
<li>Access(i,j)：在domain(i)中的process能够对object(j)使用的operation set</li>
</ul>
</li>
<li>implementation of the access matrix

<ul>
<li>用(sparse)稀疏矩阵实现</li>
<li>option1

<ul>
<li>global table

<ul>
<li>三元式&lt;domain, object, right-set></li>
</ul>
</li>
</ul>
</li>
<li>option2

<ul>
<li>access list

<ul>
<li>每一列是一个object</li>
<li>然后每个object含有一个list&lt;domain, right-set></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>access control

<ul>
<li>使用access matrix 来控制用户的访问权限</li>
<li>要对process设置privilage</li>
<li>capacity list</li>
<li>access list</li>
</ul>
</li>
<li>security problem

<ul>
<li>资源和访问是否在所有情况下使用正确</li>
<li>man in the middle attack

<ul>
<li>接入sender和receiver的信息传输

<ul>
<li>更改传输的信息</li>
</ul>
</li>
</ul>
</li>
<li>four level of security problem

<ul>
<li>physical</li>
<li>operating system</li>
<li>human</li>
<li>network</li>
</ul>
</li>
</ul>
</li>
<li>program threat

<ul>
<li><p>trojan horse</p>

<ul>
<li>木马</li>
<li>一个误用自身环境的代码段</li>
</ul>
</li>
<li><p>trap door</p>

<ul>
<li>后门</li>
<li>在程序中留一个只有他自己可以使用的漏洞</li>
</ul>
</li>
<li>logic bomb

<ul>
<li>在某种特殊情况下才会激发的安全隐患</li>
</ul>
</li>
<li>virus

<ul>
<li>在正常软件中嵌入的代码段</li>
<li>用来感染别的电脑</li>
</ul>
</li>
</ul>
</li>
<li>system an network threat

<ul>
<li>worm

<ul>
<li>通过繁殖机制破坏系统性能的进程

<ul>
<li>大量繁殖导致操作系统耗尽资源</li>
<li>然后瘫痪系统</li>
</ul>
</li>
</ul>
</li>
<li>morris internet worm

<ul>
<li>一个字符串查询finger，超出分配给输入的缓冲，并且覆写栈</li>
</ul>
</li>
</ul>
</li>
<li>crytography as a security tool

<ul>
<li>RSA工作方式

<ul>
<li>加密用公钥</li>
<li>解密用私钥</li>
</ul>
</li>
<li>同步加密</li>
<li>异步加密</li>
</ul>
</li>
<li>user authentication

<ul>
<li>密码</li>
<li>biometric</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[computation theory final exam review]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/30/computation-theory-final-exam-review/"/>
    <updated>2015-04-30T22:45:08-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/30/computation-theory-final-exam-review</id>
    <content type="html"><![CDATA[<h3>Chapter 12:</h3>

<ul>
<li>undecidable decision problem不可解问题

<ul>
<li>不是所有问题都能找到多项式级的算法</li>
<li>有些问题甚至没有正确的算法</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>Understand what it means for a problem to be decidable (or not)

<ul>
<li>A decision problem is any arbitrary yes-or-no question on an infinite set of input.</li>
<li>也就是任意的输入都能产生一个yes或者no的结果</li>
</ul>
</li>
<li>Be able to state the Halting Problem and discuss its implications含义.

<ul>
<li>halting problem 停机问题

<ul>
<li>因为不存在一个算法，是的我们无法写出一个程序来判断一个随机程序P能够对所有的输入停机</li>
<li>判断任意一个程序是否会在有限的时间之内结束执行的问题。该问题等价于

<ul>
<li>给定一个程序P和输入w，程序P再输入w下能够最终停止</li>
</ul>
</li>
<li>停机问题是无解的</li>
</ul>
</li>
</ul>
</li>
<li>Be able to outline概述 a proof of the Halting Problem.

<ul>
<li>证明

<ul>
<li>用反证

<ul>
<li>假设停机问题有解

<ul>
<li>那么就存在过程H(P,I)可以判断程序P再输入I的情况下是否可停机的问题

<ul>
<li>如果P在输入的时候可以停机，那么H输出停机</li>
<li>如果不能停机，就输出无限循环（无限循环那么其实也是停机），所以矛盾</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to carry out a reducibility（归约） argument辩论.

<ul>
<li>一个问题A能够归约化为问题B的含义是，可以用问题B的解法解决A</li>
<li>e.g

<ul>
<li>我们要求解一个一元一次方程和一个一元二次方程，那么我们可以说前者可以约化成后者</li>
<li>也可以说求解一元二次方程的时间复杂度要高于求解一元一次方程

<ul>
<li>因为如果求解一元二次方程的时间复杂度比求解一元一次方程的时间复杂度还低，那么就可以把算法优化</li>
</ul>
</li>
</ul>
</li>
<li>约化的过程只有在用多项式的时间完成才有意义</li>
</ul>
</li>
</ul>


<h3>Chapter 14:</h3>

<ul>
<li>Be able to give an informal definition for the sets P, NP, and NP-complete.

<ul>
<li>set P

<ul>
<li>问题能够再多项式（polynomial）时间内<strong>解决</strong></li>
<li>也就是可以一步步很有效率的解决的问题</li>
<li>或者说，可以用deterministic sequential machine在多项式时间内解决的decision problem</li>
</ul>
</li>
<li>set NP

<ul>
<li>在多项式时间内验证一个解的问题，也就是在多项式时间内猜出一个解的问题</li>
<li>也就是你求出了一个问题的解，我要<strong>验证</strong>你的解是否正确，我用了多项式时间，至于你求解这个问题是否用多项式时间不关我事，可能这个问题有多项式的算法，可能没有。</li>
<li>或者说，可以用non deterministic sequential machine在多项式时间内解决的decision problem。

<ul>
<li>这类问题只要给个解答，可以很快验证这个解答是否正确</li>
</ul>
</li>
</ul>
</li>
<li>set NP-complete

<ul>
<li>最麻烦的NP问题，基本不可能有P的解法

<ul>
<li>例子：

<ul>
<li>我们要在一堆整数内找出和为零的那些组合

<ul>
<li>我们可以很容易验证一个组合的和是否为零，因此是NP问题</li>
<li>但是要我们去找，是没有P的解法的</li>
<li>所以这个是一个NP-complete问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>通俗的讲就是一个时间复杂度最高，并且能够“通吃“所有NP问题的NP问题

<ul>
<li>也就是解决了这个问题，所有的NP问题就解决了</li>
</ul>
</li>
<li>有以下两个条件

<ul>
<li>1.是一个NP问题</li>
<li>2.所有NP问题都能约化成它</li>
</ul>
</li>
<li>证明NP-complete问题

<ul>
<li>首先证明他是一个NP问题</li>
<li>然后证明其中一个NP-complete问题能够约化成它。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关系</strong>

<ul>
<li><strong>NP和NP-hard的交集是NP-complete</strong></li>
<li><strong>P在NP内</strong></li>
<li>所有NP问题都可以设计出一个多项式的算法，转换成另外一个NP问题

<ul>
<li>也就是所有的NP问题都可以用多项式时间的算法来彼此转换</li>
</ul>
</li>
</ul>
</li>
<li>NP=P？

<ul>
<li>也就是NP是否能够用P的时间解决？

<ul>
<li>如果可一个话，NP问题就会都变成P问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to give an informal definition for the set NP hard and its relationship to the classes P,    NP, and NP-complete.

<ul>
<li>NP-hard问题

<ul>
<li>满足NP-complete问题的第二个条件，但是不满足第一个条件</li>
<li>也就是所有NP问题都能约化成它，但是它不是一个NP问题</li>
<li>定义：一个问题被称为P-hard问题，当且仅当一个NP-complete问题可以在多项式时间内归约到这个问题</li>
<li>也就是NP-hard问题比NP-complete问题还难</li>
</ul>
</li>
</ul>
</li>
<li>Be able to name some NP-complete problems.

<ul>
<li>traveling salesman problem旅行者问题

<ul>
<li>这个问题是NP-complete问题，并且这个也是NP-hard问题</li>
<li>是一个多局部最优的最优化问题</li>
<li>问题描述：

<ul>
<li>有n个城市，一个推销员要从其中一个城市出发，走遍所有城市（每个城市只能走一遍），再回到原点，求<strong>是否存在</strong>最短路</li>
<li>如果暴力枚举，只能O(n!)</li>
<li>动态规划可以加快到O((n<sup>2</sup>) * (2<sup>n</sup>))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Compiler theory:</h3>

<ul>
<li>There will be a question or two based on the compiler theory session (slides are online).

<ul>
<li>编译过程：

<ul>
<li>首先是lexical analyzer词法分析</li>
<li>其次是syntax analyzer语法分析器

<ul>
<li>至上而下分析</li>
<li>至下而上分析</li>
<li>用于解析字串，并且看看是否满足语法

<ul>
<li>语法：

<ul>
<li>上下文无关文法

<ul>
<li>pda能够识别任何上下文无关文法生成的语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其次是semantic analyzer语义分析</li>
<li>其次是intermediate code generator中间代码生成</li>
<li>其次是code optimizer代码优化</li>
<li>最后是code generator代码生成</li>
</ul>
</li>
<li>lexical analyzer</li>
<li>FSA:finite state machine</li>
<li>LL 的意思是scan left to right, substitute leftmost</li>
<li>LR 的意思是scan left to right, substitute rightmost</li>
<li>LL(k) 向前看前k个symbol，看是否能够决定每一句语法</li>
<li>二义性：能够构造两颗语法树</li>
</ul>
</li>
</ul>


<h3>Divide and Conquer:</h3>

<ul>
<li>Be able to describe the divide-and-conquer design technique and give at least one example of an algorithm that uses this technique.

<ul>
<li>分而治之思想

<ul>
<li>把一个大问题分成几个小问题</li>
<li>分别解决这些小问题</li>
<li>把小问题的解答组合起来，得到原来问题的答案</li>
</ul>
</li>
<li>例子；

<ul>
<li>归并排序

<ul>
<li>sort数组

<ul>
<li>如果子集为1，那么算法终止</li>
<li>否则，把集合分割成两个子集，对每个子集排序

<ul>
<li>然后把排序好的子集归并为一个集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>并行算法</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Dynamic Programming:</h3>

<ul>
<li>Be able to describe the characteristics of problems suitable for this design approach and give at least one example of an algorithm that uses this technique.

<ul>
<li>动态规划是子问题最优化问题</li>
<li>例子有最长公共子串，最长公共子序列，背包，TSP

<ul>
<li>最长公共子串

<ul>
<li>假设两个字符串s和t，s[i]和t[j]表示第i个和第j个字符</li>
<li>L[i][j]表示以s[i]和t[j]结尾的相同子串的最长长度

<ul>
<li>那么L[i][j]和L[i+1][j+1]的关系是

<ul>
<li>L[i+1][j+1] = s[i]==t[j]?L[i][j]+1:0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to solve a problem using dynamic programming given some hints.</li>
</ul>


<h3>Greedy Algorithms:</h3>

<ul>
<li>Be able to describe the greedy algorithm design technique and give at least one example of an algorithm that uses this technique.

<ul>
<li>最优子结构问题</li>
<li>每次都找最优解</li>
</ul>
</li>
<li>Be able to trace Dijkstra&rsquo;s shortest path problem on a given graph.

<ul>
<li> 首先从空的集合开始，选择离集合最近的点，把那个点加入集合</li>
<li> 然后再更新列表中离这个集合相邻的点的距离

<ul>
<li>然后以这个新的点开始，找他的邻居

<ul>
<li>然后对比到这个邻居的最短的路

<ul>
<li>在原有的最短路上加上这个新的点的距离

<ul>
<li>如果比前一步加上另外一条路径的距离还长，就更新最短路

<ul>
<li>否则就把当前的这个值更新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>循环直到到达终点</li>
</ul>
</li>
</ul>
</li>
<li>Be able to generate Huffman codes for a given frequency analysis

<ul>
<li><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
<li>解法是首先排序

<ul>
<li><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>C</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>然后递归的对数组中<strong>最小的两个元素</strong>进行合并</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>         （22）
</span><span class='line'>         /    \
</span><span class='line'>      （9）     (13)
</span><span class='line'>      /  \      /   \
</span><span class='line'>    G(4) (5)   (7)   (6)
</span><span class='line'>         / \    | \     |\
</span><span class='line'>       A(2)B(3) E(3)C(4)F(3)D(3) </span></code></pre></td></tr></table></div></figure>


<h3>Amortized Analysis:</h3>

<ul>
<li>Be able to describe the goal of an amortized analysis for a given algorithm.

<ul>
<li>平摊分析

<ul>
<li>执行一系列数据结构所需要的时间是通过执行的所有操作求平均得到的。</li>
<li>平摊分析可以用来证明在一系列操作中，通过对所有操作求平均之后，即使对其中单一的操作具有较大的代价，平均代价还是很小的</li>
</ul>
</li>
<li>aggregate method

<ul>
<li>证明对所有的n，由n各操作所构成的序列的总时间再最坏情况下T(n)</li>
<li>所有操作都是同样的cost</li>
</ul>
</li>
<li>accounting method

<ul>
<li>对不同的操作赋予不同的cost，某些操作的费用比他们的实际代价或多或少</li>
<li>平摊代价：一个操作的收费数量

<ul>
<li>如果一个操作的平摊代价超过他的实际代价的时候，差值就是credit

<ul>
<li>这个credit用来补偿那些平摊代价地域实际代价的操作</li>
</ul>
</li>
</ul>
</li>
<li>总的平摊代价是总的实际代价的上界</li>
</ul>
</li>
<li>potential method

<ul>
<li>平摊代价=实际代价+势能</li>
<li>平摊代价依赖于势函数，不同的势函数会产生不同的平摊代价，但是都是实际代价的上限</li>
<li>e.g

<ul>
<li>动态表

<ul>
<li>当向满的表插入一个元素，把表扩大一倍</li>
<li>当删除意向引起表不足1/4满时，把表缩小为原来的一半</li>
</ul>
</li>
<li>由平摊分析可知两项操作的平摊代价都是O(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to carry out an amortized analysis (using the aggregate method, the accounting method, or the potential method, as specified) for a given algorithm given some hints.</li>
</ul>


<h3>Approximation Algorithms:</h3>

<ul>
<li>近似算法的结果不一定是最优的（不是说结果不准确）</li>
<li>对于一些已经被证明是NP-complete问题的优化问题，无法在多项式时间内得到最优解</li>
<li>Be able to give the characteristics of a good approximation algorithm

<ul>
<li>假设最优值为K，求解一个问题的近似算法求得的近似最优解相应的目标函数值为C

<ul>
<li>所以近似性能比x={K/C,C/K}</li>
<li>假设通常情况下，性能比x是问题输入规模n的一个函数P(n)，也就是x&lt;=P(n)</li>
<li>相对误差定义为s=abs((K-C) / K)

<ul>
<li>如果对问题有输入规模n，有一函数V(n)>=s,那么V(n)为该近似算法的相对误差界。</li>
</ul>
</li>
<li>那么有P(n)-1>=V(n)</li>
</ul>
</li>
</ul>
</li>
<li>Be able to define what it means for an approximation algorithm to give an answer &ldquo;close&rdquo; to the optimum result.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015_citadel_onsite_interview]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/29/2015-citadel-onsite-interview/"/>
    <updated>2015-04-29T22:55:50-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/29/2015-citadel-onsite-interview</id>
    <content type="html"><![CDATA[<h3>citadel onsite面试</h3>

<ul>
<li>结果是rejected

<h4>面试流程</h4></li>
<li>第一轮 hr发邮件通知说有一个技术面

<ul>
<li>然后就会有一个技术人员打电话给你，然后面试一些技术方面的内容</li>
<li>例如：

<ul>
<li>如何找出两个只有一个field的数据库表的区别</li>
<li>问了快排和归并的区别</li>
<li>还有问mutex在什么时候用</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>第二轮

<ul>
<li>hr会跟你说邀请你去芝加哥总部面试</li>
<li>路费报销，免费一晚上宾馆</li>
<li>的士费也是</li>
<li>一共六轮面试

<ul>
<li>全部都是技术面试</li>
<li>第一轮：linux admin

<ul>
<li>sed

<ul>
<li>sum the 1th column and 3 column of a file</li>
</ul>
</li>
<li>python</li>
<li>acm

<ul>
<li>how many time will the two clock pointer overlap

<ul>
<li>from 12, each hour the overlap will move on 1/5 part of one hour</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二轮：

<ul>
<li>write some python program to deal with string</li>
</ul>
</li>
<li>第三轮:

<ul>
<li>program manger

<ul>
<li>ask about the future of you</li>
<li>what is the favorite project</li>
<li>whether you will use our company as a jump stone and create your own company</li>
</ul>
</li>
</ul>
</li>
<li>第四轮 network (difficult)

<ul>
<li>ask something about the latency of the network</li>
<li>and ask about the thread</li>
<li>ask about the mutex and how to lock</li>
</ul>
</li>
<li>第五轮第六轮</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[resize disk in OSX10.10]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/29/resize-disk-in-osx10-dot-10/"/>
    <updated>2015-04-29T11:31:35-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/29/resize-disk-in-osx10-dot-10</id>
    <content type="html"><![CDATA[<h3>Resize disk in OS X 10.10 Yosemite</h3>

<ul>
<li>due to the update of OSX, we can not resize the disk after we split the disk in the first time.</li>
<li>so we need to use some other command</li>
</ul>


<!--more-->


<h4>diskutil</h4>

<ul>
<li>first we can use <code>diskutil corestorage</code> to see what option we have</li>
<li>then we will choose <code>diskutil corestorage resizeDisk</code> or something else to resize the disk</li>
<li>some option that is not shown in the menu</li>
<li>Physical Volume (Disk) Commands

<ul>
<li>resizeDisk (undocumented) – Resize a physical volume</li>
<li>removeDisk (undocumented) – Remove a physical volume from a logical volume group</li>
<li>addDisk (undocumented) &ndash; Add a new physical volume to a logical volume group</li>
</ul>
</li>
<li><p>Logical Volume Commands</p>

<ul>
<li>deleteVolume (undocumented) – Delete a logical volume and all of its contents</li>
<li>resizeVolume (undocumented) – Grow or shrink a logical volume</li>
<li>resizeStack (undocumented) – Grow or shrink a logical volume as well as the volume group and physical volume.</li>
</ul>
</li>
<li><p>for example</p>

<ul>
<li>Example: diskutil coreStorage resizeVolume 11111111-2222-3333-4444-555555555555 10g</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ reference and pointer]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer/"/>
    <updated>2015-04-22T11:15:07-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer</id>
    <content type="html"><![CDATA[<h3>what is pointer</h3>

<ul>
<li>形参

<ul>
<li>formal parameter</li>
<li>定义时函数里面的变量

<ul>
<li>e.g int swao(int a, int b)</li>
<li>a和b就是形参</li>
</ul>
</li>
</ul>
</li>
<li>实参

<ul>
<li>actual parameter</li>
<li>在主函数里面引用的

<ul>
<li>e.g swap(x,y)</li>
<li>x和y就是实参，实际的值</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>指针</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part1(){
</span><span class='line'>  //basic
</span><span class='line'>  //p指向变量，对p的重新复制就会改变p所指向的变量的值。
</span><span class='line'>  //同样对p指向的变量重新复制也会改变*p的值
</span><span class='line'>  int ptmp = 50;
</span><span class='line'>  int *p;
</span><span class='line'>  p = &ptmp;
</span><span class='line'>  cout&lt;&lt;p&lt;&lt;endl;
</span><span class='line'>  //p存放的是ptmp变量所在的地址值 
</span><span class='line'>  cout&lt;&lt;*p&lt;&lt;endl;
</span><span class='line'>  //50，是指储存在指针的内存地址中的值，也就是ptmp的值
</span><span class='line'>  cout&lt;&lt;&p&lt;&lt;endl; 
</span><span class='line'>  //p指针本身的地址值
</span><span class='line'>  cout&lt;&lt;&ptmp; 
</span><span class='line'>  //ptmp变量所在的地址值
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>指针控制循环</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part2(){
</span><span class='line'>  //用指针来控制循环条件
</span><span class='line'>  //针对数组
</span><span class='line'>  int array[20];
</span><span class='line'>  int *p = array;
</span><span class='line'>  int i;
</span><span class='line'>  for(int j = 0; j &lt; 20; j++)
</span><span class='line'>      array[j] = j;
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  for(i = 0; i &lt; 20; i++){
</span><span class='line'>      cout&lt;&lt;p&lt;&lt;" "&lt;&lt;(*p)&lt;&lt;" ";
</span><span class='line'>      p++; //指针加一
</span><span class='line'>      (*p)++; //指针指向内容加一
</span><span class='line'>      //如果要用指针遍历数组
</span><span class='line'>      //用*(p+i)
</span><span class='line'>      //应为int 的p++ = p + 2
</span><span class='line'>      //int 占2byte
</span><span class='line'>  }
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  //针对字符串
</span><span class='line'>  char *str = "abc";
</span><span class='line'>  while(*p){
</span><span class='line'>      cout&lt;&lt;*p&lt;&lt;" ";
</span><span class='line'>      p++;
</span><span class='line'>      //可以这么做的原因是char占 1 byte
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>引用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part3(){
</span><span class='line'>  //引用
</span><span class='line'>  int a = 20;
</span><span class='line'>  int b = 10;
</span><span class='line'>  int &p = a;
</span><span class='line'>  //p引用a,所以p是a的另外一个名字
</span><span class='line'>  cout&lt;&lt;p&lt;&lt;endl;
</span><span class='line'>  //p的值改变了
</span><span class='line'>  p = b;
</span><span class='line'>  //a的值也会改变
</span><span class='line'>  cout&lt;&lt;a&lt;&lt;endl;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>传参</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap1(int x, int y){
</span><span class='line'>  cout&lt;&lt;"in function before swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
</span><span class='line'>  int temp = x;
</span><span class='line'>  x = y;
</span><span class='line'>  y = temp;
</span><span class='line'>  cout&lt;&lt;"in fuction after swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
</span><span class='line'>}
</span><span class='line'>void swap2(int *a, int *b){
</span><span class='line'>  //temp用来存a得值
</span><span class='line'>  //所以其实这里是在交换值
</span><span class='line'>  int temp = *a;
</span><span class='line'>  *a = *b;
</span><span class='line'>  *b = temp;
</span><span class='line'>}
</span><span class='line'>void swap3(int &a, int &b){
</span><span class='line'>  //因为这里是传引用，所以任何的改变都会改变
</span><span class='line'>  int temp = a;
</span><span class='line'>  a = b;
</span><span class='line'>  b = temp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>注意事项</h4>

<ul>
<li>在可以使用引用的情况下，不要用指针</li>
<li>引用不能为空，当对象为NULL时，必须使用指针</li>
<li>引用不允许重新赋值，当使用一个变量指向不同的对象的时候，必须使用指针</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part3]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3/"/>
    <updated>2015-04-22T00:27:20-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h3>图论</h3>

<h4>图的实现</h4>

<ul>
<li>V为点的个数 E边的个数</li>
<li>邻接矩阵

<ul>
<li>用一个n*n的矩阵

<ul>
<li>第一列第二个为1的意思是

<ul>
<li>第一个点和第二个点相连</li>
<li>1为权值</li>
</ul>
</li>
</ul>
</li>
<li>O(V<sup>2</sup>)</li>
<li>用一个二维数组实现</li>
</ul>
</li>
<li>邻接表

<ul>
<li>用一个n长度的数组

<ul>
<li>然后每一个数组后面接的链表里面存着

<ul>
<li>这个数组index对应的点和哪些点相连

<ul>
<li>这些点存在链表里面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>O(V+E)</li>
<li>stl实现</li>
<li>用vector<Node> list

<ul>
<li>然后Node就是每个点

<ul>
<li>如果有别的点和这个Node相连，就list.push_back(别的点)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>图搜索</h4>

<h5>广度优先搜索</h5>

<ul>
<li>使用的数据结构是queue</li>
<li>相当于先把第一层的所有点入队

<ul>
<li>然后把每个点的相邻的节点入队

<ul>
<li>e.g

<ul>
<li>假设第一层的节点为A, 第二层为B，第三层为C

<ul>
<li>那么队列中的情况就是

<ul>
<li>A,B,C,A1,A2,A3,B1,C2</li>
<li>这样访问下来，就相当于一层一层的遍历了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>伪代码</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function bfs(vertex v){
</span><span class='line'>  create a queue Q
</span><span class='line'>  enqueue v into Q
</span><span class='line'>  mark v as visited
</span><span class='line'>  while Q is not empty{
</span><span class='line'>      use temp to store Q.top
</span><span class='line'>      dequeue the top vertex from Q
</span><span class='line'>      for each adjacent w in temp{
</span><span class='line'>          mark w as visited
</span><span class='line'>          enqueue w into Q
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>深度优先搜索</h5>

<ul>
<li>使用的数据结构是stack</li>
<li>伪代码</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function dfs(vertex v){
</span><span class='line'>  mark v as visited //把点标记为已经访问过了
</span><span class='line'>  for each node adjacent to v //对这个点的所有邻接点进行搜索
</span><span class='line'>      if node is unvisited  //如果从左到右，找到这个点没有被访问过
</span><span class='line'>          dfs(node) //递归调用
</span><span class='line'>      //如果这个点访问过了
</span><span class='line'>          //那么向右移，继续搜索
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>二叉树的BFS和DFS</h5>

<ul>
<li>首先递归建树

<ul>
<li>再用bfs和dfs</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define Element char
</span><span class='line'>typedef struct Node{
</span><span class='line'>  Element data;
</span><span class='line'>  struct Node *left;
</span><span class='line'>  struct Node *right;
</span><span class='line'>}*Tree;
</span><span class='line'>int i = 0;
</span><span class='line'>//按照先序遍历建树
</span><span class='line'>void construct_tree(Tree &root, Element data[]){
</span><span class='line'>  Element e = data[i++];
</span><span class='line'>  if(e == '#')
</span><span class='line'>      root = NULL;
</span><span class='line'>  else{
</span><span class='line'>      root = new Node();
</span><span class='line'>      root -&gt; data = e;
</span><span class='line'>      construct_tree(root -&gt; left, data); //递归建立左子树
</span><span class='line'>      construct_tree(root -&gt; right, data); //递归建立右子树
</span><span class='line'>  }   
</span><span class='line'>}
</span><span class='line'>void bfs(Tree root){  
</span><span class='line'>  queue&lt;Node *&gt; q;
</span><span class='line'>  q.push(root);
</span><span class='line'>  while(!q.empty()){
</span><span class='line'>      Node *temp = q.front();
</span><span class='line'>      q.pop();
</span><span class='line'>      cout&lt;&lt;temp -&gt; data;
</span><span class='line'>      if(temp -&gt; left)
</span><span class='line'>          q.push(temp -&gt; left);
</span><span class='line'>      if(temp -&gt; right)
</span><span class='line'>          q.push(temp -&gt; right);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>void dfs(Tree root){
</span><span class='line'>  stack&lt;Node *&gt; s;
</span><span class='line'>  s.push(root);
</span><span class='line'>  while(!s.empty()){
</span><span class='line'>      Node *temp = s.top();
</span><span class='line'>      s.pop();
</span><span class='line'>      cout&lt;&lt;temp -&gt; data;
</span><span class='line'>      //因为stack是先进后出，所以先把right压进去
</span><span class='line'>      if(temp -&gt; right)
</span><span class='line'>          s.push(temp -&gt; right);
</span><span class='line'>      if(temp -&gt; left)
</span><span class='line'>          s.push(temp -&gt; left);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  //#表示没有左子树或者右子树
</span><span class='line'>  //             A
</span><span class='line'>  //           /   \
</span><span class='line'>  //          B     C
</span><span class='line'>  //        /  \   /  \
</span><span class='line'>  //      D    E   F   G
</span><span class='line'>  Element data[15] = {'A','B','D','#','#','E','#','#','C','F','#','#','G','#','#'};
</span><span class='line'>  Tree tree;
</span><span class='line'>  construct_tree(tree, data);
</span><span class='line'>  //bfs
</span><span class='line'>  cout&lt;&lt;"result of bfs: ";
</span><span class='line'>  bfs(tree);
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  //dfs
</span><span class='line'>  cout&lt;&lt;"result of dfs: ";
</span><span class='line'>  dfs(tree);
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>拓扑排序</h5>

<ul>
<li>方法

<ul>
<li>用在有向图里面</li>
<li>选择一个入度为0的点，输出

<ul>
<li>然后删除这个点和所有和他相连的出去的边</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>最短路径</h4>

<ul>
<li>单源最短路</li>
<li>Dijkstra算法

<ul>
<li>首先把起点加入集合</li>
<li>每次查询的时候

<ul>
<li>把和这个集合最近的那个点加入集合</li>
<li>然后递归</li>
</ul>
</li>
</ul>
</li>
<li>floyd算法

<ul>
<li>原理是动态规划</li>
<li>首先得出图的邻接矩阵

<ul>
<li>然后如果i==j那么为0，因为自己到自己的距离为0</li>
<li>如果两个点不邻接，那么为INF(很大的数字)</li>
</ul>
</li>
<li>其次，如果有N个点，那么就要对矩阵进行n次更新

<ul>
<li>依次把距离当前集合距离最小的点加入集合</li>
<li>并且更新矩阵数据</li>
<li>如果a[i][j] > a[i][k] + a[k][j]

<ul>
<li>则a[i][j] = a[i][k] + a[k][j]</li>
</ul>
</li>
</ul>
</li>
<li>最后得出的矩阵就是包含所有点到所有点的最短距离</li>
</ul>
</li>
</ul>


<h4>最小生成树(todo)</h4>

<ul>
<li>Prim</li>
<li>Kruskal</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part2]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2/"/>
    <updated>2015-04-22T00:22:30-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h4>树</h4>

<ul>
<li>trie树

<ul>
<li>特点

<ul>
<li>根节点没有字符，除此之外，所有节点都只有一个字符</li>
<li>从根节点到任意叶子节点，都是一个独立的单词</li>
<li>每个节点的子节点包含的后续字符串都是不一样的</li>
</ul>
</li>
<li>但是hash表不能一边建立索引一边查数据

<ul>
<li>trie树可以

<ul>
<li>因为只要之前建立过的，再次出现的时候，就不会再增加</li>
</ul>
</li>
<li>而hash表建立的时候，不知道之前这个单词出现过，所以还是要建完表

<ul>
<li>再搜索</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>内排序</h4>

<ul>
<li><p>O(n<sup>2</sup>)</p>

<ul>
<li>主要是交换那个动作耗时</li>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
</ul>
</li>
<li><p>快速排序</p>

<ul>
<li>时间复杂度：nlogn</li>
<li>最坏：n<sup>2</sup>

<ul>
<li>把区域划分成n-1和1</li>
</ul>
</li>
<li>空间复杂度：nlogn</li>
<li>所以其实要解释快排是什么

<ul>
<li>就是选一个中间值

<ul>
<li>把比这个中间值小的放到左边</li>
<li>把比这个中间值大的放到右边</li>
<li>然后分别对这两个子数组递归调用快速排序</li>
<li>最后的出来的就是排序好的</li>
</ul>
</li>
</ul>
</li>
<li>思想：

<ul>
<li>对于A[p&hellip;.r]</li>
<li>基于分而治之</li>
<li>首先

<ul>
<li>A[p&hellip;.r]被分解成两个子数组

<ul>
<li>一个是A[p&hellip;.q-1]，一个是A[q+1&hellip;..r]</li>
<li>然后递归调用对A[p&hellip;q-1]和A[q+1&hellip;..r]排序</li>
</ul>
</li>
<li>最后合并子数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void quicksort(int *a, int low, int upp){
</span><span class='line'>  //low和upp为数组的上界和下界
</span><span class='line'>  int i = low;
</span><span class='line'>  int j = upp;
</span><span class='line'>  int mid = (low + upp)/2;
</span><span class='line'>  //设置pivot用作对比
</span><span class='line'>  int pivot = a[mid];
</span><span class='line'>  int temp;
</span><span class='line'>  //partition
</span><span class='line'>  do{
</span><span class='line'>      while(a[i] &lt; pivot)
</span><span class='line'>          i++;
</span><span class='line'>      while(a[j] &gt; pivot)
</span><span class='line'>          j--;
</span><span class='line'>      if(i &lt;= j){
</span><span class='line'>          swap(a[i], a[j]);
</span><span class='line'>          i++;
</span><span class='line'>          j--;
</span><span class='line'>      }
</span><span class='line'>  }while(i &lt; j);
</span><span class='line'>  //递归调用解决子问题
</span><span class='line'>  if(low &lt; j)
</span><span class='line'>      quicksort(a, low, j);
</span><span class='line'>  if(i &lt; upp)
</span><span class='line'>      quicksort(a, i, upp);
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  int a[10] = {1,5,4,3,6,5,3,4,5,3};
</span><span class='line'>  for(int i = 0; i &lt; 10; i++){
</span><span class='line'>      cout&lt;&lt;a[i]&lt;&lt;" ";
</span><span class='line'>  }
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  quicksort(a, 0, 9);
</span><span class='line'>  for(int i = 0; i &lt; 10; i++){
</span><span class='line'>      cout&lt;&lt;a[i]&lt;&lt;" ";
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>归并排序</li>
<li>基本思想：

<ul>
<li>分而治之</li>
<li>先通过递归分解数组，然后再合并数组完成归并排序</li>
</ul>
</li>
<li>如何合并两个有序数组

<ul>
<li>比较两个数列的第一个数，把小的那个加入到结果数组中，然后从原来的数组删掉</li>
<li>然后一直循环比较到全部数据都取出来为止
&#8220;`</li>
</ul>
</li>
</ul>


<p>&#8220;`</p>

<h4>归并和快排的区别</h4>

<ul>
<li>快排分解之后不需要合并就能得到最终答案</li>
<li>归并分解之后还要对比两个子数组然后合并的到答案</li>
</ul>


<h3>外排序</h3>

<ul>
<li>适合在内存不够的时候用</li>
<li>把一个大文件分割成很多小文件

<ul>
<li>然后依次把每个小文件放入内存排序</li>
<li>排序完之后，再存入文件中</li>
<li>最后就会得到很多排好序的小文件</li>
</ul>
</li>
<li>然后用多路归并，对比每个文件的第一个，把最小的放到一个结果文件中

<ul>
<li>然后把这个元素在原本的文件中删掉</li>
</ul>
</li>
<li>得到的结果文件就是结果</li>
</ul>


<h4>哈希表</h4>

<ul>
<li>建立hash表

<ul>
<li>用hash函数把key转换成一个整型数字，这个整型数字对数组长度求模之后就是数组的下标

<ul>
<li>那么value就存在这个下表的数组空间里面</li>
</ul>
</li>
</ul>
</li>
<li><p>查询hash表</p>

<ul>
<li>把要查询的key用hash函数转换成数组下标，再去数组里面提取</li>
<li>O(N)非常快</li>
</ul>
</li>
<li><p>假设有1000万个记录，有重复，去除重复之后大约300万</p>

<ul>
<li>求top 10出现率的记录</li>
<li>解答：

<ul>
<li>用hash表

<ul>
<li>维护一个&lt;记录，出现次数>的hash表

<ul>
<li>这样就有一个300万条左右记录的hash表</li>
<li>再找前十就行了</li>
</ul>
</li>
</ul>
</li>
<li>找前10可以用部分排序

<ul>
<li>也就是用一个10个大小的数组

<ul>
<li>然后搜hash表，每次都和数组最后的那个比

<ul>
<li>如果比他大，就交换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>把key变成下表的方法</p>

<ul>
<li>1.对key求模

<ul>
<li>index = value % 16</li>
</ul>
</li>
<li>2.平方散列

<ul>
<li>index = (value * value) >> 28

<ul>
<li>右移28bit是指除以2<sup>28</sup></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果两个value在hash表中对应同一个index怎么办？

<ul>
<li>可以用链表解决

<ul>
<li>这样就不会有冲突产生</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>索引</h4>

<ul>
<li><p>线性索引</p>

<ul>
<li>索引文件是一个线性的列表</li>
<li>并且列表中的每个元素都对应者数据库中的一个元素

<ul>
<li>或者数据库的某个位置</li>
</ul>
</li>
<li>但是有时候索引文件太大，装不进内存

<ul>
<li>那么解决方案就是用二级索引

<ul>
<li>这个二级索引是索引文件的索引</li>
</ul>
</li>
</ul>
</li>
<li>但是每个数据库更新的时候

<ul>
<li>所有的索引文件都要更新，但是线性索引的代价很大</li>
</ul>
</li>
</ul>
</li>
<li><p>ISAM</p></li>
<li>树状索引

<ul>
<li>B树

<ul>
<li>balance tree</li>
<li>b树的搜索

<ul>
<li>对根节点进行二分查找</li>
</ul>
</li>
</ul>
</li>
<li>B+树

<ul>
<li>B树的变种</li>
<li>叶子节点存数据</li>
<li>非叶子节点存索引</li>
<li>好处

<ul>
<li>因为B+树内部只是存索引，不像B树是存数据的

<ul>
<li>因此B+树I/O读写次数降低了</li>
</ul>
</li>
<li>查找效率稳定

<ul>
<li>因为所有非叶子节点都是索引</li>
<li>因此数据都在叶子节点上，因此关键字查询的路径相同</li>
<li>因此每一个数据的查找效率相当</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[string processing function implementation]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation/"/>
    <updated>2015-04-21T00:56:01-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation</id>
    <content type="html"><![CDATA[<h3>string function in c</h3>

<h4>strcpy</h4>

<ul>
<li>使用一个临时变量保存串的首地址，然后最后返回这个地址</li>
<li>然后在最后判断是否遇到&#8217;\0&#8217;来结束复制</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char *strcpy1(char *des, const char*src){
</span><span class='line'>  char *address = des;
</span><span class='line'>  while((*des++ = *src++) != '\0');
</span><span class='line'>  return address;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *des;
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  char *result;
</span><span class='line'>  result = strcpy1(des, src);
</span><span class='line'>  cout&lt;&lt;result;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<hr />

<h4>strlen</h4>

<ul>
<li>一直累加直到判断是否遇到&#8217;\0&#8217;来结束计数</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int strlen1(const char*src){
</span><span class='line'>  int count = 0;
</span><span class='line'>  while((*src++) != '\0')
</span><span class='line'>      count++;
</span><span class='line'>  return count;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  int result;
</span><span class='line'>  result = strlen1(src);
</span><span class='line'>  cout&lt;&lt;result;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>strcat</h4>

<ul>
<li>把指针移到最后，然后把b字符串的内容复制到a字符串最后</li>
<li>但是要注意a字符串要有足够的空间来支持b字符串内容的大小</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char *strcat1(char *des, const char*src){
</span><span class='line'>  char *address = des;
</span><span class='line'>  while(*address)
</span><span class='line'>      address++;
</span><span class='line'>
</span><span class='line'>  while((*address++ = *src++) !='\0');
</span><span class='line'>  return des;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char des[10] = "";
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  char *result;
</span><span class='line'>  result = strcat1(des, src);
</span><span class='line'>  printf("%s", result);
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>strcmp</h4>

<ul>
<li>如果字符串一样，那么返回0</li>
<li>如果a>b那么返回正数，否则返回负数</li>
<li>比较方法是用asc码来比较，然后最后返回相减的结果

<ul>
<li>从左到右比较，知道出现不一样的字符或者出现&#8217;\0&#8217;为止</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int strcmp1(const char *s1, const char*s2){
</span><span class='line'>  while(*s1 == *s2){
</span><span class='line'>      if(*s1 == '\0'){
</span><span class='line'>          return 0;
</span><span class='line'>      }
</span><span class='line'>      ++s1;
</span><span class='line'>      ++s2;
</span><span class='line'>  }
</span><span class='line'>  return *s1 - *s2;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *des = "aaa";
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  int result;
</span><span class='line'>  result = strcmp1(des, src);
</span><span class='line'>  if(result == 0)
</span><span class='line'>      cout&lt;&lt;"the string are the same";
</span><span class='line'>  else
</span><span class='line'>      cout&lt;&lt;"the string are not the same";
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T21:04:11-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<h4>little review about c++ object oriented</h4>

<ul>
<li>虚函数

<ul>
<li>核心理念就是基类访问派生类定义的函数</li>
<li>动态联编</li>
<li>一个函数的调用不是在编译的时候确定的，而是在运行的时候确定的，并且因为写代码的时候不能确定被调用的函数是基类的函数还是派生类的函数，所以这个函数又叫做“虚函数“</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A{
</span><span class='line'>    public:
</span><span class='line'>        virtual void test(){
</span><span class='line'>            cout&lt;&lt;"A:test() is called";
</span><span class='line'>        }        
</span><span class='line'>};
</span><span class='line'>class B: public A{
</span><span class='line'>    public:
</span><span class='line'>        virtual void test(){
</span><span class='line'>            cout&lt;&lt;"B:test() is called";
</span><span class='line'>        }
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>    A *a = new B();
</span><span class='line'>    a -&gt; test();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!--more-->


<ul>
<li><p>虚函数表</p>

<ul>
<li>实现多态的主要功能</li>
<li><strong>编译器</strong>会为每一个有虚函数的类的实例创建一个虚函数表</li>
<li>用来存虚函数的table

<ul>
<li>table的每个slot（槽）里面存放虚函数的地址</li>
</ul>
</li>
<li>但是我们可以用函数指针来看虚函数表的地址

<ul>
<li>并且虚函数表在继承中，如果派生类没有重写基类的某个函数，他就会在基类中查那个函数，然后引用的时候就会引用基类的</li>
<li>并且如果子类如果增加了函数，就会在基类的虚函数表中增加</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数</p>

<ul>
<li><code>virtual void test() = 0</code></li>
<li>意思是抽象类，也可以说是接口，用来规范派生类的行为

<ul>
<li>告诉使用者我的派生类都会有这个函数</li>
</ul>
</li>
<li>虚构析函数

<ul>
<li>当一个类要被其他的类当基类使用的时候，必须是纯虚的</li>
<li>如果有两个class A和B

<ul>
<li>B继承A，但是A的构析函数没有设置成虚函数</li>
<li>那么在delete B的实例的时候，只有A的实例被delete， B的不会被delete。。。那这不是坑爹吗。。。。</li>
<li>但是再A的构析函数前面加上virtual，这样就能保证在delete B的实例的时候，两个类的构析函数都会被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>但是构造函数不能使虚函数</p></li>
</ul>


<hr />

<h4>链表</h4>

<ul>
<li>链表ADT</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class List{
</span><span class='line'>  private:
</span><span class='line'>      void operator = (const List &){}
</span><span class='line'>      List(const List&){}
</span><span class='line'>  public:
</span><span class='line'>      List(){}
</span><span class='line'>      virtual ~List(){}
</span><span class='line'>      virtual void clear() = 0;
</span><span class='line'>      virtual void insert(const E& item) = 0;
</span><span class='line'>      virtual void append(const E& item) = 0;
</span><span class='line'>      virtual E remove() = 0;
</span><span class='line'>      //move the pointer to start
</span><span class='line'>      virtual void moveToStart() = 0;
</span><span class='line'>      //move the pointer to end
</span><span class='line'>      virtual void moveToEnd() = 0;
</span><span class='line'>      virtual void prev() = 0;
</span><span class='line'>      virtual void next() = 0;
</span><span class='line'>      virtual int length() const = 0;
</span><span class='line'>      virtual int currPos() const = 0;
</span><span class='line'>      virtual void moveToPos(int pos) = 0;
</span><span class='line'>      virtual const E& getValue() const = 0;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class AList: public List&lt;E&gt;{
</span><span class='line'>private:
</span><span class='line'>  int maxSize;
</span><span class='line'>  int listSize;
</span><span class='line'>  int curr;
</span><span class='line'>  E* listArray;   
</span><span class='line'>public:
</span><span class='line'>    //初始化列表
</span><span class='line'>  AList(int size = 100){
</span><span class='line'>      maxSize = size;
</span><span class='line'>      listSize = 0;
</span><span class='line'>      curr = 0;
</span><span class='line'>      listArray = new E[maxSize];
</span><span class='line'>  }
</span><span class='line'>  //构析函数，删掉数组，释放空间
</span><span class='line'>  ~AList(){
</span><span class='line'>      delete []listArray;
</span><span class='line'>  }
</span><span class='line'>  void clear(){
</span><span class='line'>      delete []listArray;
</span><span class='line'>      listSize = 0;
</span><span class='line'>      curr = 0;
</span><span class='line'>      listArray = new E[maxSize];
</span><span class='line'>  }
</span><span class='line'>  //把当前位置之后的数组向后移动一位，再插入
</span><span class='line'>  void insert(const E& it){
</span><span class='line'>      for(int i = listSize; i &gt; curr; i--)
</span><span class='line'>          listArray[i] = listArray[i-1];
</span><span class='line'>      //move back the array from the current position
</span><span class='line'>      listArray[curr] = it;
</span><span class='line'>      listSize++;
</span><span class='line'>  }
</span><span class='line'>  //直接在最后增加item
</span><span class='line'>  void append(const E& it){
</span><span class='line'>      listArray[listSize++] = it;
</span><span class='line'>  }
</span><span class='line'>  //记录当前的数组索引的指向的数据，把数组向前移动一位
</span><span class='line'>  E remove(){
</span><span class='line'>      E it = listArray[curr];
</span><span class='line'>      for(int i = curr; i &lt; listSize - 1; i++){
</span><span class='line'>          listArray[i] = listArray[i + 1];
</span><span class='line'>      }
</span><span class='line'>      listSize--;
</span><span class='line'>      return it;
</span><span class='line'>  }
</span><span class='line'>  void moveToStart(){
</span><span class='line'>      curr = 0;
</span><span class='line'>  }
</span><span class='line'>  void moveToEnd(){
</span><span class='line'>      curr = listSize;
</span><span class='line'>  }
</span><span class='line'>  void prev(){
</span><span class='line'>      if(curr &gt; 0)
</span><span class='line'>          curr--;
</span><span class='line'>  }
</span><span class='line'>  void next(){
</span><span class='line'>      if(curr &lt; listSize)
</span><span class='line'>          curr++;
</span><span class='line'>  }
</span><span class='line'>  int length(){
</span><span class='line'>      return listSize;
</span><span class='line'>  }
</span><span class='line'>  int currPos() const{
</span><span class='line'>      return curr;
</span><span class='line'>  }
</span><span class='line'>  void moveToPos(int pos){
</span><span class='line'>      pos = curr;
</span><span class='line'>  }
</span><span class='line'>  const E& getValue() const{
</span><span class='line'>      return listArray[curr];
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>链式实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class Link{
</span><span class='line'>public:
</span><span class='line'>  E element;
</span><span class='line'>  Link *next;
</span><span class='line'>  Link(const E& elemval, Link *nextval = NULL){
</span><span class='line'>      element = elemval;
</span><span class='line'>      next = nextval;
</span><span class='line'>  }
</span><span class='line'>  Link(Link *nextval = NULL){
</span><span class='line'>      next = nextval;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>template &lt;typename E&gt; class LList: public List&lt;E&gt;{
</span><span class='line'>private:
</span><span class='line'>  Link&lt;E&gt; *head;
</span><span class='line'>  Link&lt;E&gt; *tail;
</span><span class='line'>  Link&lt;E&gt; *curr;
</span><span class='line'>  int count;
</span><span class='line'>  void init(){
</span><span class='line'>      curr = tail = head = new Link&lt;E&gt;;
</span><span class='line'>      count = 0;
</span><span class='line'>  }
</span><span class='line'>  void removeall(){
</span><span class='line'>      while(head != NULL){
</span><span class='line'>          curr = head;
</span><span class='line'>          head = head -&gt; next;
</span><span class='line'>          delete curr;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>public:
</span><span class='line'>  LList(int size=100){
</span><span class='line'>      init();
</span><span class='line'>  }
</span><span class='line'>  ~LList(){
</span><span class='line'>      removeall();
</span><span class='line'>  }
</span><span class='line'>  void clear(){
</span><span class='line'>      removeall();
</span><span class='line'>      init();
</span><span class='line'>  }
</span><span class='line'>  void insert(const E& it){
</span><span class='line'>      //给要增加的节点初始化
</span><span class='line'>      curr -&gt; next = new Link&lt;E&gt;(it, curr -&gt; next);
</span><span class='line'>      //如果要curr指针就是再末尾
</span><span class='line'>      //那么把curr的下一个赋给tail
</span><span class='line'>      if(tail == curr)
</span><span class='line'>          tail = curr -&gt; next;
</span><span class='line'>      count++;
</span><span class='line'>  }
</span><span class='line'>  void append(const E& it){
</span><span class='line'>      //直接把末尾指针的next指向新建的link
</span><span class='line'>      tail = tail -&gt; next = new Link&lt;E&gt;(it, NULL);
</span><span class='line'>      count++;
</span><span class='line'>  }
</span><span class='line'>  //注意，这里要删除的节点叫做curr-&gt;next
</span><span class='line'>  E remove(){
</span><span class='line'>      //先把要删除的node的值存起来
</span><span class='line'>      E it = curr -&gt; next -&gt; element;
</span><span class='line'>      //用temp存一下要删除的节点
</span><span class='line'>      Link&lt;E&gt; *temp = curr -&gt; next;
</span><span class='line'>      //如果这个要删除的点是末尾，那么把末尾前一个节点赋给tail
</span><span class='line'>      if(tail == curr -&gt; next)
</span><span class='line'>          tail = curr;
</span><span class='line'>      //否则，把要删除的节点的前一个节点的next指向要删除节点的下一个
</span><span class='line'>      curr -&gt; next = curr -&gt; next -&gt; next;
</span><span class='line'>      delete temp;
</span><span class='line'>      count--;
</span><span class='line'>      return it;
</span><span class='line'>  }
</span><span class='line'>  void moveToStart(){
</span><span class='line'>      curr = head;
</span><span class='line'>  }
</span><span class='line'>  void moveToEnd(){
</span><span class='line'>      curr = tail;
</span><span class='line'>  }
</span><span class='line'>  void prev(){
</span><span class='line'>      if(curr == head)
</span><span class='line'>          return ;
</span><span class='line'>      Link&lt;E&gt; *temp = head;
</span><span class='line'>      //向左移动一个单位
</span><span class='line'>      //做法是先用temp存一个head，然后向右找，直到找到curr的前一个，然后把curr的前一个赋给curr
</span><span class='line'>      while(temp -&gt; next != curr)
</span><span class='line'>          temp = temp -&gt; next;
</span><span class='line'>      curr = temp;
</span><span class='line'>  }
</span><span class='line'>  void next(){
</span><span class='line'>      //只要curr指针不是tail，那么就向后移动
</span><span class='line'>      if(curr != tail)
</span><span class='line'>          curr = curr -&gt; next;
</span><span class='line'>  }
</span><span class='line'>  int length(){
</span><span class='line'>      return count;
</span><span class='line'>  }
</span><span class='line'>  int currPos() const{
</span><span class='line'>      Link&lt;E&gt; *temp = head;
</span><span class='line'>      //用temp指针存head，然后依次向后遍历，并且每次后移count+1
</span><span class='line'>      int i;
</span><span class='line'>      for(i = 0; i &lt; count; i++){
</span><span class='line'>          temp = temp -&gt; next;
</span><span class='line'>      }
</span><span class='line'>      return i;
</span><span class='line'>  }
</span><span class='line'>  void moveToPos(int pos){
</span><span class='line'>      curr = head;
</span><span class='line'>      //先把current的指针指向head
</span><span class='line'>      //然后一直向后移动，直到pos次
</span><span class='line'>      for(int i = 0; i &lt; pos; i++){
</span><span class='line'>          curr = curr -&gt; next;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  const E& getValue() const{
</span><span class='line'>      return curr -&gt; next -&gt; element;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>栈</h4>

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Astack{
</span><span class='line'>  private:
</span><span class='line'>      int maxSize;
</span><span class='line'>      int top;
</span><span class='line'>      int *array;
</span><span class='line'>  public:
</span><span class='line'>      Astack(int size = 100){
</span><span class='line'>          maxSize = size;
</span><span class='line'>          top = 0;
</span><span class='line'>          array = new int[size];
</span><span class='line'>      }
</span><span class='line'>      ~Astack(){
</span><span class='line'>          delete []array;
</span><span class='line'>      }
</span><span class='line'>      void clear(){
</span><span class='line'>          top = 0;
</span><span class='line'>      }
</span><span class='line'>      void push(int item){
</span><span class='line'>          array[top++] = item;
</span><span class='line'>      }
</span><span class='line'>      int pop(){
</span><span class='line'>          int temp = array[top];
</span><span class='line'>          return array[--top];
</span><span class='line'>      }
</span><span class='line'>      int getTop(){
</span><span class='line'>          return array[top - 1];
</span><span class='line'>      }   
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>  Astack a;
</span><span class='line'>  a.push(1);
</span><span class='line'>  cout&lt;&lt;a.getTop();
</span><span class='line'>  a.pop();
</span><span class='line'>  cout&lt;&lt;a.getTop();
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>队列</h4>

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Aqueue{
</span><span class='line'>  private:
</span><span class='line'>      int front;
</span><span class='line'>      int rear;
</span><span class='line'>      int maxSize;
</span><span class='line'>      int *array;
</span><span class='line'>  public:
</span><span class='line'>      Aqueue(int size = 100){
</span><span class='line'>          maxSize = size;
</span><span class='line'>          front = rear = 0;
</span><span class='line'>          array = new int[size];
</span><span class='line'>      }
</span><span class='line'>      ~Aqueue(){
</span><span class='line'>          delete [] array;
</span><span class='line'>      }
</span><span class='line'>      void enqueue(int item){
</span><span class='line'>          array[rear] = item;
</span><span class='line'>          rear = (rear + 1)%maxSize;
</span><span class='line'>      }
</span><span class='line'>      int dequeue(){
</span><span class='line'>          int temp = array[front];
</span><span class='line'>          front = (front + 1)%maxSize;
</span><span class='line'>          array[front] = 0;
</span><span class='line'>          return temp;
</span><span class='line'>      }
</span><span class='line'>      const int getFrontValue(){
</span><span class='line'>          return array[front];
</span><span class='line'>      }
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>  Aqueue q;
</span><span class='line'>  q.enqueue(1);
</span><span class='line'>  cout&lt;&lt;q.getFrontValue()&lt;&lt;endl;
</span><span class='line'>  q.dequeue();
</span><span class='line'>  cout&lt;&lt;q.getFrontValue();
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>二叉树</h4>

<ul>
<li>遍历</li>
<li>前序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void preorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        cout&lt;&lt;root-&gt;value;
</span><span class='line'>        preorder(root -&gt; left);
</span><span class='line'>        preorder(root -&gt; right);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>中序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void inorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        inorder(root -&gt; left);
</span><span class='line'>        cout&lt;&lt;root -&gt; value;
</span><span class='line'>        inorder(root -&gt; right);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>后序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void postorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        postorder(root -&gt; left);
</span><span class='line'>        postorder)root -&gt; right);
</span><span class='line'>        cout&lt;&lt;root -&gt; value;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ program run time]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time/"/>
    <updated>2015-04-20T19:52:22-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time</id>
    <content type="html"><![CDATA[<h4>时间复杂度</h4>

<ul>
<li>costs for growth rate representative of most computer algorithm

<ul>
<li><table>
<thead>
<tr>
<th>n</th>
<th>loglogn</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n<sup>2</sup></th>
<th>n<sup>3</sup></th>
<th>2<sup>n</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2</td>
<td>4</td>
<td>2<sup>4</sup></td>
<td>2*2<sup>4</sup>=2<sup>5</sup></td>
<td>2<sup>8</sup></td>
<td>2<sup>12</sup></td>
<td>2<sup>16</sup></td>
</tr>
<tr>
<td>256</td>
<td>3</td>
<td>8</td>
<td>2<sup>8</sup></td>
<td>8*2<sup>8</sup>=2<sup>11</sup></td>
<td>2<sup>16</sup></td>
<td>2<sup>24</sup></td>
<td>2<sup>256</sup></td>
</tr>
<tr>
<td>1024</td>
<td>3.3</td>
<td>10</td>
<td>2<sup>10</sup></td>
<td>10*2<sup>10</sup>=2<sup>13</sup></td>
<td>2<sup>20</sup></td>
<td>2<sup>30</sup></td>
<td>2<sup>1024</sup></td>
</tr>
<tr>
<td>64K</td>
<td>4</td>
<td>16</td>
<td>2<sup>16</sup></td>
<td>16*2<sup>16</sup>=2<sup>20</sup></td>
<td>2<sup>32</sup></td>
<td>2<sup>48</sup></td>
<td>2<sup>64K</sup></td>
</tr>
<tr>
<td>1M</td>
<td>4.3</td>
<td>20</td>
<td>2<sup>20</sup></td>
<td>20*2<sup>20</sup>=2<sup>24</sup></td>
<td>2<sup>40</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>1M</sup></td>
</tr>
<tr>
<td>1G</td>
<td>4.9</td>
<td>30</td>
<td>2<sup>30</sup></td>
<td>30*2<sup>30</sup>=2<sup>35</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>90</sup></td>
<td>2<sup>1G</sup></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>最差，最好，平均

<ul>
<li>例如顺序搜索

<ul>
<li>如果在第一个就搜到，那么就是最佳的case</li>
<li>如果搜到最后一个才搜到，那就是最差的case</li>
<li>（最佳+最差）/2为平均</li>
</ul>
</li>
<li>一般都是用平均的</li>
</ul>
</li>
<li>上界

<ul>
<li>大O表示

<ul>
<li>对一个非负的函数T(n)，T(n)是O(f(n))的当且仅当存在两个非负的c和k，使得T(n)&lt;=cf(n) 对所有n > k;

<ul>
<li>其中k为n的最小值</li>
</ul>
</li>
</ul>
</li>
<li>大omega

<ul>
<li>对一个非负的函数T(n)，T(n)是omega(g(n))当且存在两个非负的c和k，使得T(n)>=cg(n) 对所有n > k;</li>
</ul>
</li>
<li>大theta

<ul>
<li>当上界和下界被同一个常数影响。</li>
</ul>
</li>
</ul>
</li>
<li>例子</li>
<li><code>
sum1 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=n;j++)
      sum1++;
sum2 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=k;j++)
      sum2++;
</code>

<ul>
<li>第一个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了n次

<ul>
<li>那么复杂度为nlogn</li>
</ul>
</li>
</ul>
</li>
<li>第二个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了执行了k次，k=2<sup>i</sup>

<ul>
<li>那么复杂度为n</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用算法的时间复杂度</li>
<li><p><strong>搜索</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>二分搜索</td>
<td>数组查n个元素</td>
<td>logn|</td>
</tr>
<tr>
<td>顺序查找</td>
<td>数组查n个元素</td>
<td>n|</td>
</tr>
<tr>
<td>最短路（乱序数组）</td>
<td>V个点和E条边</td>
<td>V<sup>2</sup></td>
</tr>
<tr>
<td>最短路（bellman-ford）</td>
<td> V个点和E条边</td>
<td>V*E       </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p><strong>排序</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>归并排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>堆排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>插入排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>选择排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>桶排序</td>
<td>数组</td>
<td>n+k</td>
</tr>
<tr>
<td>计数排序</td>
<td>数组</td>
<td>n*k </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<h4>算法加速</h4>

<ul>
<li>focus on算法主要消耗时间的部分</li>
<li>先优化算法，再优化代码</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xapian omindex build index and search]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search/"/>
    <updated>2015-04-15T21:28:58-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search</id>
    <content type="html"><![CDATA[<h3>omega is a component that can be used with xapian</h3>

<ul>
<li>we can use omega to build index</li>
</ul>


<h4>build index</h4>

<ul>
<li><code>omindex --db index --url / ./index_file/</code>

<ul>
<li>&mdash;db 后面跟的是索引数据库的名字</li>
<li>&mdash;url 后面跟的是 / 然后再加上要建索引的数据的文件夹（含有那些要建索引的文件）</li>
</ul>
</li>
<li>运行之后，就会生成index文件夹，这个文件夹里面就是建好的索引</li>
</ul>


<h4>query</h4>

<ul>
<li>quest &mdash;db=index &ldquo;asd&rdquo;

<ul>
<li>&mdash;db 后面跟的是索引数据库</li>
<li>然后再加上要查询的关键字</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtual machine windows VS2010 UNC path not support]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/14/virtual-machine-windows-vs2010-unc-path-not-support/"/>
    <updated>2015-04-14T20:17:08-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/14/virtual-machine-windows-vs2010-unc-path-not-support</id>
    <content type="html"><![CDATA[<h3>解决UNC路径不受支持</h3>

<pre><code>在虚拟机的VS2010中编译出错
</code></pre>

<ul>
<li>错误提示：用作为当前目录的以上路径启动了 CMD.EXE。 UNC 路径不受支持。默认值设为 Windows 目录。系统找不到指定的文件。执行 c:\windows\system32\cmd.exe 时出错.</li>
<li>解决方法:

<ul>
<li>在注册表中,添加一个值即可.路径如下:

<ul>
<li>HKEY_CURRENT_USER\Software\Microsoft\Command Processor</li>
<li>添加值 DisableUNCCheck，类型为 REG_DWORD 并将该值设置为1 （十六进制）。</li>
</ul>
</li>
<li>或者，打开cmd.exe

<ul>
<li>把下面这行代码复制进去，按回车</li>
<li>reg add  &ldquo;HKEY_CURRENT_USER\Software\Microsoft\Command Processor&rdquo; /v DisableUNCCheck /t REG_DWORD /d 1 /f</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.net in mac MonoDevelop]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/14/asp-dot-net-in-mac-monodevelop/"/>
    <updated>2015-04-14T02:01:35-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/14/asp-dot-net-in-mac-monodevelop</id>
    <content type="html"><![CDATA[<h3>install asp.net environment in mac</h3>

<ul>
<li>we can use MonoDevelop IDE in mac to develop c# or VB program

<ul>
<li>also asp.net too</li>
</ul>
</li>
<li>download url: <a href="http://www.monodevelop.com/download/">http://www.monodevelop.com/download/</a>

<ul>
<li>download the Xamarin studio as development IDE</li>
</ul>
</li>
</ul>


<!--more-->


<h3>after install the environment</h3>

<ul>
<li>start a solution as ASP.NET project in C#</li>
<li>it will generate a project with some default page

<ul>
<li>The Default.aspx can be act as a html page</li>
<li>and Default.aspx.cs can act be a controller in c#</li>
<li>and Default.aspx.designer.cs can act be a model in MVC</li>
</ul>
</li>
</ul>


<h3>connect to mysql</h3>

<ul>
<li>remember to add System.Data in the Reference</li>
<li>add a MyDql.Data in Packages</li>
<li>add a <code>using MySql.Data.MySqlClient;</code> in the cs code</li>
</ul>


<h3>code for mysql connection</h3>

<ul>
<li>front end page</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;%@ Page Language="C#" Inherits="test1.Default" %&gt;
</span><span class='line'>&lt;!DOCTYPE html&gt;
</span><span class='line'>&lt;html&gt;
</span><span class='line'>&lt;head runat="server"&gt;
</span><span class='line'>  &lt;title&gt;Default&lt;/title&gt;
</span><span class='line'>  &lt;style&gt;
</span><span class='line'>  table, th, td {
</span><span class='line'>      border: 1px solid black;
</span><span class='line'>      border-collapse: collapse;
</span><span class='line'>  }
</span><span class='line'>  th, td {
</span><span class='line'>      padding: 15px;
</span><span class='line'>  }
</span><span class='line'>  &lt;/style&gt;
</span><span class='line'>&lt;/head&gt;
</span><span class='line'>&lt;body&gt;
</span><span class='line'>  &lt;form id="form1" runat="server"&gt;
</span><span class='line'>      &lt;asp:button id="clickMeButton" runat="server" text="Click Me" onClick="clickMeButton_Click" /&gt;
</span><span class='line'>      &lt;asp:label id="outputlabel" runat="server" /&gt;
</span><span class='line'>  &lt;/form&gt;
</span><span class='line'>&lt;/body&gt;
</span><span class='line'>&lt;/html&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>backend</li>
<li>cs file 1</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;code&gt;
</span><span class='line'>using System; 
</span><span class='line'>using System.Data; 
</span><span class='line'>using System.Configuration; 
</span><span class='line'>using System.Collections; 
</span><span class='line'>using System.Web; 
</span><span class='line'>using System.Web.Security; 
</span><span class='line'>using System.Web.UI; 
</span><span class='line'>using System.Web.UI.WebControls; 
</span><span class='line'>using System.Web.UI.WebControls.WebParts; 
</span><span class='line'>using System.Web.UI.HtmlControls; 
</span><span class='line'>using MySql.Data.MySqlClient; 
</span><span class='line'>namespace test1
</span><span class='line'>{
</span><span class='line'>  public partial class Default : System.Web.UI.Page
</span><span class='line'>  {
</span><span class='line'>      public void clickMeButton_Click (object sender, EventArgs e)
</span><span class='line'>      {
</span><span class='line'>          object val = ViewState["ButtonClickCount"];
</span><span class='line'>          int i = (val == null)? 1 : (int)val + 1;
</span><span class='line'>          outputlabel.Text = string.Format ("You clicked me {0} {1}", i, i==1?"time":"times");
</span><span class='line'>          ViewState["ButtonClickCount"] = i;
</span><span class='line'>          string query = "select * from reference limit 10"; 
</span><span class='line'>          MySqlConnection myConnection = new MySqlConnection("server=localhost;user id=root;password=root;database=reference_db"); 
</span><span class='line'>          MySqlCommand myCommand=new MySqlCommand(query,myConnection); 
</span><span class='line'>          myConnection.Open(); 
</span><span class='line'>          myCommand.ExecuteNonQuery(); 
</span><span class='line'>          MySqlDataReader myDataReader = myCommand.ExecuteReader(); 
</span><span class='line'>          string bookres=""; 
</span><span class='line'>          bookres += "&lt;table style=\"width:100%\"&gt;";
</span><span class='line'>          while (myDataReader.Read()==true) 
</span><span class='line'>          { 
</span><span class='line'>              bookres += "&lt;tr&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["id"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["ReferenceType"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["Record_Number"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;/tr&gt;";
</span><span class='line'>          } 
</span><span class='line'>          bookres += "&lt;/table&gt;";
</span><span class='line'>          myDataReader.Close(); 
</span><span class='line'>          myConnection.Close(); 
</span><span class='line'>          outputlabel.Text = bookres;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>cs file 2</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;code&gt;
</span><span class='line'>using System;
</span><span class='line'>using System.Web;
</span><span class='line'>using System.Web.UI;
</span><span class='line'>namespace test1
</span><span class='line'>{
</span><span class='line'>  public partial class Default
</span><span class='line'>  {
</span><span class='line'>      protected System.Web.UI.WebControls.Button button1;
</span><span class='line'>      protected System.Web.UI.WebControls.Label outputlabel;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java spring tutorial part1]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/11/java-spring-tutorial-part1/"/>
    <updated>2015-04-11T14:41:46-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/11/java-spring-tutorial-part1</id>
    <content type="html"><![CDATA[<h3>maven</h3>

<ul>
<li>make sure &lsquo;mvn -v&rsquo; return the current version in you computer</li>
<li>otherwise, install the maven first</li>
</ul>


<h3>Hello world</h3>

<ul>
<li>project hierarchy

<ul>
<li>helloworld (folder)

<ul>
<li>(root directory)</li>
<li>src

<ul>
<li>main

<ul>
<li>java

<ul>
<li>hello

<ul>
<li>Greeter.java</li>
<li>HelloWorld.java</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>target(auto generate after mvn install)

<ul>
<li>helloworld-0.1.0.jar</li>
</ul>
</li>
<li>pom.xml</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>class</h4>

<ul>
<li><code>mkdir -p src/main/java/hello</code>

<ul>
<li>make a directory to put the java class</li>
</ul>
</li>
<li>create two class <code>HelloWorld.java</code> and <code>Greeter.java</code>

<ul>
<li><p>HelloWorld.java</p>

<ul>
<li><p>&#8220;`
  package hello;</p>

<p>  import org.joda.time.LocalTime;</p>

<p>  public class HelloWorld{
      public static void main(String[] args){
          LocalTime currentTime = new LocalTime();
          System.out.println(&ldquo;The currentTime local time is &rdquo; + currentTime);
          Greeter greeter = new Greeter();
          System.out.println(greeter.sayHello());
      }
  }</p></li>
</ul>


<p>  &#8220;`</p></li>
<li><p>Greeter.java</p>

<ul>
<li><p>&#8220;`
  package hello;</p>

<p>  public class Greeter {
      public String sayHello() {
          return &ldquo;Hello world!&rdquo;;
      }
  }
&#8220;`</p></li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>configuration</h4>

<ul>
<li>pom.xml

<ul>
<li>put the file in the root of the project</li>
<li><p>&#8220;`
  &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <groupId>org.springframework</groupId>
      <artifactId>helloworld</artifactId>
      <packaging>jar</packaging>
      <version>0.1.0</version></p>

<pre><code>  &lt;!--- 插件 --&gt;
  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;joda-time&lt;/groupId&gt;
          &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
          &lt;version&gt;2.2&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
              &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
              &lt;version&gt;2.1&lt;/version&gt;
              &lt;executions&gt;
                  &lt;execution&gt;
                      &lt;phase&gt;package&lt;/phase&gt;
                      &lt;goals&gt;
                          &lt;goal&gt;shade&lt;/goal&gt;
                      &lt;/goals&gt;
                      &lt;configuration&gt;
                          &lt;transformers&gt;
                              &lt;transformer
                                  implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;
                                  &lt;mainClass&gt;hello.HelloWorld&lt;/mainClass&gt;
                              &lt;/transformer&gt;
                          &lt;/transformers&gt;
                      &lt;/configuration&gt;
                  &lt;/execution&gt;
              &lt;/executions&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>

<p>  </project>
&#8220;`</p></li>
</ul>
</li>
</ul>


<h4>run the maven project</h4>

<ul>
<li>compile

<ul>
<li>mvn compile</li>
</ul>
</li>
<li>install

<ul>
<li>mvn install</li>
</ul>
</li>
<li>two ways to run

<ul>
<li>java -jar helloworld-0.1.0.jar</li>
<li>mvn exec:java -Dexec.mainClass=&ldquo;hello.HelloWorld&rdquo;</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[install tomcat in mac]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/03/install-tomcat-in-mac/"/>
    <updated>2015-04-03T02:28:36-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/03/install-tomcat-in-mac</id>
    <content type="html"><![CDATA[<h3>install tomcat in mac</h3>

<ul>
<li>1.go to <a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and download the zip file of tomcat</li>
<li>2.then unzip the zip file into /Library and rename into &ldquo;Tomcat&rdquo;</li>
<li>3.then <code>sudo chmod 755 /Library/Tomcat/bin/*.sh</code></li>
<li>4.if you want to start tomcat

<ul>
<li><code>sudo sh startup.sh</code></li>
<li>if want to stop

<ul>
<li><code>sudo sh /Library/Tomcat/bin/shutdown.sh</code></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
