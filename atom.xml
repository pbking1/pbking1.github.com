<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[KING]]></title>
  <link href="http://pbking1.github.com/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-04-23T22:38:29-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[c++ reference and pointer]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer/"/>
    <updated>2015-04-22T12:15:07-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer</id>
    <content type="html"><![CDATA[<h3>what is pointer</h3>

<ul>
<li>形参

<ul>
<li>formal parameter</li>
<li>定义时函数里面的变量

<ul>
<li>e.g int swao(int a, int b)</li>
<li>a和b就是形参</li>
</ul>
</li>
</ul>
</li>
<li>实参

<ul>
<li>actual parameter</li>
<li>在主函数里面引用的

<ul>
<li>e.g swap(x,y)</li>
<li>x和y就是实参，实际的值</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>指针</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part1(){
</span><span class='line'>  //basic
</span><span class='line'>  //p指向变量，对p的重新复制就会改变p所指向的变量的值。
</span><span class='line'>  //同样对p指向的变量重新复制也会改变*p的值
</span><span class='line'>  int ptmp = 50;
</span><span class='line'>  int *p;
</span><span class='line'>  p = &ptmp;
</span><span class='line'>  cout&lt;&lt;p&lt;&lt;endl;
</span><span class='line'>  //p存放的是ptmp变量所在的地址值 
</span><span class='line'>  cout&lt;&lt;*p&lt;&lt;endl;
</span><span class='line'>  //50，是指储存在指针的内存地址中的值，也就是ptmp的值
</span><span class='line'>  cout&lt;&lt;&p&lt;&lt;endl; 
</span><span class='line'>  //p指针本身的地址值
</span><span class='line'>  cout&lt;&lt;&ptmp; 
</span><span class='line'>  //ptmp变量所在的地址值
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>指针控制循环</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part2(){
</span><span class='line'>  //用指针来控制循环条件
</span><span class='line'>  //针对数组
</span><span class='line'>  int array[20];
</span><span class='line'>  int *p = array;
</span><span class='line'>  int i;
</span><span class='line'>  for(int j = 0; j &lt; 20; j++)
</span><span class='line'>      array[j] = j;
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  for(i = 0; i &lt; 20; i++){
</span><span class='line'>      cout&lt;&lt;p&lt;&lt;" "&lt;&lt;(*p)&lt;&lt;" ";
</span><span class='line'>      p++; //指针加一
</span><span class='line'>      (*p)++; //指针指向内容加一
</span><span class='line'>  }
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  //针对字符串
</span><span class='line'>  char *str = "abc";
</span><span class='line'>  while(*p){
</span><span class='line'>      cout&lt;&lt;*p&lt;&lt;" ";
</span><span class='line'>      p++;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>引用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part3(){
</span><span class='line'>  //引用
</span><span class='line'>  int a = 20;
</span><span class='line'>  int b = 10;
</span><span class='line'>  int &p = a;
</span><span class='line'>  //p引用a,所以p是a的另外一个名字
</span><span class='line'>  cout&lt;&lt;p&lt;&lt;endl;
</span><span class='line'>  //p的值改变了
</span><span class='line'>  p = b;
</span><span class='line'>  //a的值也会改变
</span><span class='line'>  cout&lt;&lt;a&lt;&lt;endl;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>传参</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap1(int x, int y){
</span><span class='line'>  cout&lt;&lt;"in function before swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
</span><span class='line'>  int temp = x;
</span><span class='line'>  x = y;
</span><span class='line'>  y = temp;
</span><span class='line'>  cout&lt;&lt;"in fuction after swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
</span><span class='line'>}
</span><span class='line'>void swap2(int *a, int *b){
</span><span class='line'>  //temp用来存a得值
</span><span class='line'>  //所以其实这里是在交换值
</span><span class='line'>  int temp = *a;
</span><span class='line'>  *a = *b;
</span><span class='line'>  *b = temp;
</span><span class='line'>}
</span><span class='line'>void swap3(int &a, int &b){
</span><span class='line'>  //因为这里是传引用，所以任何的改变都会改变
</span><span class='line'>  int temp = a;
</span><span class='line'>  a = b;
</span><span class='line'>  b = temp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>注意事项</h4>

<ul>
<li>在可以使用引用的情况下，不要用指针</li>
<li>引用不能为空，当对象为NULL时，必须使用指针</li>
<li>引用不允许重新赋值，当使用一个变量指向不同的对象的时候，必须使用指针</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part3]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3/"/>
    <updated>2015-04-22T01:27:20-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h3>图论</h3>

<h4>图的实现</h4>

<ul>
<li>V为点的个数 E边的个数</li>
<li>邻接矩阵

<ul>
<li>用一个n*n的矩阵

<ul>
<li>第一列第二个为1的意思是

<ul>
<li>第一个点和第二个点相连</li>
<li>1为权值</li>
</ul>
</li>
</ul>
</li>
<li>O(V<sup>2</sup>)</li>
<li>用一个二维数组实现</li>
</ul>
</li>
<li>邻接表

<ul>
<li>用一个n长度的数组

<ul>
<li>然后每一个数组后面接的链表里面存着

<ul>
<li>这个数组index对应的点和哪些点相连

<ul>
<li>这些点存在链表里面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>O(V+E)</li>
<li>stl实现</li>
<li>用vector<Node> list

<ul>
<li>然后Node就是每个点

<ul>
<li>如果有别的点和这个Node相连，就list.push_back(别的点)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>图搜索</h4>

<h5>广度优先搜索</h5>

<ul>
<li>使用的数据结构是queue</li>
<li>相当于先把第一层的所有点入队

<ul>
<li>然后把每个点的相邻的节点入队

<ul>
<li>e.g

<ul>
<li>假设第一层的节点为A, 第二层为B，第三层为C

<ul>
<li>那么队列中的情况就是

<ul>
<li>A,B,C,A1,A2,A3,B1,C2</li>
<li>这样访问下来，就相当于一层一层的遍历了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>伪代码</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function bfs(vertex v){
</span><span class='line'>  create a queue Q
</span><span class='line'>  enqueue v into Q
</span><span class='line'>  mark v as visited
</span><span class='line'>  while Q is not empty{
</span><span class='line'>      use temp to store Q.top
</span><span class='line'>      dequeue the top vertex from Q
</span><span class='line'>      for each adjacent w in temp{
</span><span class='line'>          mark w as visited
</span><span class='line'>          enqueue w into Q
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>深度优先搜索</h5>

<ul>
<li>使用的数据结构是stack</li>
<li>伪代码</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function dfs(vertex v){
</span><span class='line'>  mark v as visited //把点标记为已经访问过了
</span><span class='line'>  for each node adjacent to v //对这个点的所有邻接点进行搜索
</span><span class='line'>      if node is unvisited  //如果从左到右，找到这个点没有被访问过
</span><span class='line'>          dfs(node) //递归调用
</span><span class='line'>      //如果这个点访问过了
</span><span class='line'>          //那么向右移，继续搜索
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>二叉树的BFS和DFS</h5>

<ul>
<li>首先递归建树

<ul>
<li>再用bfs和dfs</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define Element char
</span><span class='line'>typedef struct Node{
</span><span class='line'>  Element data;
</span><span class='line'>  struct Node *left;
</span><span class='line'>  struct Node *right;
</span><span class='line'>}*Tree;
</span><span class='line'>int i = 0;
</span><span class='line'>//按照先序遍历建树
</span><span class='line'>void construct_tree(Tree &root, Element data[]){
</span><span class='line'>  Element e = data[i++];
</span><span class='line'>  if(e == '#')
</span><span class='line'>      root = NULL;
</span><span class='line'>  else{
</span><span class='line'>      root = new Node();
</span><span class='line'>      root -&gt; data = e;
</span><span class='line'>      construct_tree(root -&gt; left, data); //递归建立左子树
</span><span class='line'>      construct_tree(root -&gt; right, data); //递归建立右子树
</span><span class='line'>  }   
</span><span class='line'>}
</span><span class='line'>void bfs(Tree root){  
</span><span class='line'>  queue&lt;Node *&gt; q;
</span><span class='line'>  q.push(root);
</span><span class='line'>  while(!q.empty()){
</span><span class='line'>      Node *temp = q.front();
</span><span class='line'>      q.pop();
</span><span class='line'>      cout&lt;&lt;temp -&gt; data;
</span><span class='line'>      if(temp -&gt; left)
</span><span class='line'>          q.push(temp -&gt; left);
</span><span class='line'>      if(temp -&gt; right)
</span><span class='line'>          q.push(temp -&gt; right);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>void dfs(Tree root){
</span><span class='line'>  stack&lt;Node *&gt; s;
</span><span class='line'>  s.push(root);
</span><span class='line'>  while(!s.empty()){
</span><span class='line'>      Node *temp = s.top();
</span><span class='line'>      s.pop();
</span><span class='line'>      cout&lt;&lt;temp -&gt; data;
</span><span class='line'>      //因为stack是先进后出，所以先把right压进去
</span><span class='line'>      if(temp -&gt; right)
</span><span class='line'>          s.push(temp -&gt; right);
</span><span class='line'>      if(temp -&gt; left)
</span><span class='line'>          s.push(temp -&gt; left);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  //#表示没有左子树或者右子树
</span><span class='line'>  //             A
</span><span class='line'>  //           /   \
</span><span class='line'>  //          B     C
</span><span class='line'>  //        /  \   /  \
</span><span class='line'>  //      D    E   F   G
</span><span class='line'>  Element data[15] = {'A','B','D','#','#','E','#','#','C','F','#','#','G','#','#'};
</span><span class='line'>  Tree tree;
</span><span class='line'>  construct_tree(tree, data);
</span><span class='line'>  //bfs
</span><span class='line'>  cout&lt;&lt;"result of bfs: ";
</span><span class='line'>  bfs(tree);
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  //dfs
</span><span class='line'>  cout&lt;&lt;"result of dfs: ";
</span><span class='line'>  dfs(tree);
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>拓扑排序</h5>

<ul>
<li>方法

<ul>
<li>用在有向图里面</li>
<li>选择一个入度为0的点，输出

<ul>
<li>然后删除这个点和所有和他相连的出去的边</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>最短路径</h4>

<ul>
<li>单源最短路</li>
<li>Dijkstra算法

<ul>
<li>首先把起点加入集合</li>
<li>每次查询的时候

<ul>
<li>把和这个集合最近的那个点加入集合</li>
<li>然后递归</li>
</ul>
</li>
</ul>
</li>
<li>floyd算法

<ul>
<li>原理是动态规划</li>
<li>首先得出图的邻接矩阵

<ul>
<li>然后如果i==j那么为0，因为自己到自己的距离为0</li>
<li>如果两个点不邻接，那么为INF(很大的数字)</li>
</ul>
</li>
<li>其次，如果有N个点，那么就要对矩阵进行n次更新

<ul>
<li>依次把距离当前集合距离最小的点加入集合</li>
<li>并且更新矩阵数据</li>
<li>如果a[i][j] > a[i][k] + a[k][j]

<ul>
<li>则a[i][j] = a[i][k] + a[k][j]</li>
</ul>
</li>
</ul>
</li>
<li>最后得出的矩阵就是包含所有点到所有点的最短距离</li>
</ul>
</li>
</ul>


<h4>最小生成树(todo)</h4>

<ul>
<li>Prim</li>
<li>Kruskal</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part2]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2/"/>
    <updated>2015-04-22T01:22:30-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h4>树</h4>

<ul>
<li>trie树

<ul>
<li>特点

<ul>
<li>根节点没有字符，除此之外，所有节点都只有一个字符</li>
<li>从根节点到任意叶子节点，都是一个独立的单词</li>
<li>每个节点的子节点包含的后续字符串都是不一样的</li>
</ul>
</li>
<li>但是hash表不能一边建立索引一边查数据

<ul>
<li>trie树可以

<ul>
<li>因为只要之前建立过的，再次出现的时候，就不会再增加</li>
</ul>
</li>
<li>而hash表建立的时候，不知道之前这个单词出现过，所以还是要建完表

<ul>
<li>再搜索</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>内排序</h4>

<ul>
<li><p>O(n<sup>2</sup>)</p>

<ul>
<li>主要是交换那个动作耗时</li>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
</ul>
</li>
<li><p>快速排序</p>

<ul>
<li>时间复杂度：nlogn</li>
<li>最坏：n<sup>2</sup>

<ul>
<li>把区域划分成n-1和1</li>
</ul>
</li>
<li>空间复杂度：nlogn</li>
<li>所以其实要解释快排是什么

<ul>
<li>就是选一个中间值

<ul>
<li>把比这个中间值小的放到左边</li>
<li>把比这个中间值大的放到右边</li>
<li>然后分别对这两个子数组递归调用快速排序</li>
<li>最后的出来的就是排序好的</li>
</ul>
</li>
</ul>
</li>
<li>思想：

<ul>
<li>对于A[p&hellip;.r]</li>
<li>基于分而治之</li>
<li>首先

<ul>
<li>A[p&hellip;.r]被分解成两个子数组

<ul>
<li>一个是A[p&hellip;.q-1]，一个是A[q+1&hellip;..r]</li>
<li>然后递归调用对A[p&hellip;q-1]和A[q+1&hellip;..r]排序</li>
</ul>
</li>
<li>最后合并子数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void quicksort(int *a, int low, int upp){
</span><span class='line'>  //low和upp为数组的上界和下界
</span><span class='line'>  int i = low;
</span><span class='line'>  int j = upp;
</span><span class='line'>  int mid = (low + upp)/2;
</span><span class='line'>  //设置pivot用作对比
</span><span class='line'>  int pivot = a[mid];
</span><span class='line'>  int temp;
</span><span class='line'>  //partition
</span><span class='line'>  do{
</span><span class='line'>      while(a[i] &lt; pivot)
</span><span class='line'>          i++;
</span><span class='line'>      while(a[j] &gt; pivot)
</span><span class='line'>          j--;
</span><span class='line'>      if(i &lt;= j){
</span><span class='line'>          swap(a[i], a[j]);
</span><span class='line'>          i++;
</span><span class='line'>          j--;
</span><span class='line'>      }
</span><span class='line'>  }while(i &lt; j);
</span><span class='line'>  //递归调用解决子问题
</span><span class='line'>  if(low &lt; j)
</span><span class='line'>      quicksort(a, low, j);
</span><span class='line'>  if(i &lt; upp)
</span><span class='line'>      quicksort(a, i, upp);
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  int a[10] = {1,5,4,3,6,5,3,4,5,3};
</span><span class='line'>  for(int i = 0; i &lt; 10; i++){
</span><span class='line'>      cout&lt;&lt;a[i]&lt;&lt;" ";
</span><span class='line'>  }
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  quicksort(a, 0, 9);
</span><span class='line'>  for(int i = 0; i &lt; 10; i++){
</span><span class='line'>      cout&lt;&lt;a[i]&lt;&lt;" ";
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>归并排序</li>
<li>基本思想：

<ul>
<li>分而治之</li>
<li>先通过递归分解数组，然后再合并数组完成归并排序</li>
</ul>
</li>
<li>如何合并两个有序数组

<ul>
<li>比较两个数列的第一个数，把小的那个加入到结果数组中，然后从原来的数组删掉</li>
<li>然后一直循环比较到全部数据都取出来为止
&#8220;`</li>
</ul>
</li>
</ul>


<p>&#8220;`</p>

<h4>归并和快排的区别</h4>

<ul>
<li>快排分解之后不需要合并就能得到最终答案</li>
<li>归并分解之后还要对比两个子数组然后合并的到答案</li>
</ul>


<h3>外排序</h3>

<h4>哈希表</h4>

<ul>
<li>建立hash表

<ul>
<li>用hash函数把key转换成一个整型数字，这个整型数字对数组长度求模之后就是数组的下标

<ul>
<li>那么value就存在这个下表的数组空间里面</li>
</ul>
</li>
</ul>
</li>
<li><p>查询hash表</p>

<ul>
<li>把要查询的key用hash函数转换成数组下标，再去数组里面提取</li>
<li>O(N)非常快</li>
</ul>
</li>
<li><p>假设有1000万个记录，有重复，去除重复之后大约300万</p>

<ul>
<li>求top 10出现率的记录</li>
<li>解答：

<ul>
<li>用hash表

<ul>
<li>维护一个&lt;记录，出现次数>的hash表

<ul>
<li>这样就有一个300万条左右记录的hash表</li>
<li>再找前十就行了</li>
</ul>
</li>
</ul>
</li>
<li>找前10可以用部分排序

<ul>
<li>也就是用一个10个大小的数组

<ul>
<li>然后搜hash表，每次都和数组最后的那个比

<ul>
<li>如果比他大，就交换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>把key变成下表的方法</p>

<ul>
<li>1.对key求模

<ul>
<li>index = value % 16</li>
</ul>
</li>
<li>2.平方散列

<ul>
<li>index = (value * value) >> 28

<ul>
<li>右移28bit是指除以2<sup>28</sup></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果两个value在hash表中对应同一个index怎么办？

<ul>
<li>可以用链表解决

<ul>
<li>这样就不会有冲突产生</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>索引</h4>

<ul>
<li><p>线性索引</p>

<ul>
<li>索引文件是一个线性的列表</li>
<li>并且列表中的每个元素都对应者数据库中的一个元素

<ul>
<li>或者数据库的某个位置</li>
</ul>
</li>
<li>但是有时候索引文件太大，装不进内存

<ul>
<li>那么解决方案就是用二级索引

<ul>
<li>这个二级索引是索引文件的索引</li>
</ul>
</li>
</ul>
</li>
<li>但是每个数据库更新的时候

<ul>
<li>所有的索引文件都要更新，但是线性索引的代价很大</li>
</ul>
</li>
</ul>
</li>
<li><p>ISAM</p></li>
<li>树状索引

<ul>
<li>B树

<ul>
<li>balance tree</li>
<li>b树的搜索

<ul>
<li>对根节点进行二分查找</li>
</ul>
</li>
</ul>
</li>
<li>B+树

<ul>
<li>B树的变种</li>
<li>叶子节点存数据</li>
<li>非叶子节点存索引</li>
<li>好处

<ul>
<li>因为B+树内部只是存索引，不像B树是存数据的

<ul>
<li>因此B+树I/O读写次数降低了</li>
</ul>
</li>
<li>查找效率稳定

<ul>
<li>因为所有非叶子节点都是索引</li>
<li>因此数据都在叶子节点上，因此关键字查询的路径相同</li>
<li>因此每一个数据的查找效率相当</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[string processing function implementation]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation/"/>
    <updated>2015-04-21T01:56:01-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation</id>
    <content type="html"><![CDATA[<h3>string function in c</h3>

<h4>strcpy</h4>

<ul>
<li>使用一个临时变量保存串的首地址，然后最后返回这个地址</li>
<li>然后在最后判断是否遇到&#8217;\0&#8217;来结束复制</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char *strcpy1(char *des, const char*src){
</span><span class='line'>  char *address = des;
</span><span class='line'>  while((*des++ = *src++) != '\0');
</span><span class='line'>  return address;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *des;
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  char *result;
</span><span class='line'>  result = strcpy1(des, src);
</span><span class='line'>  cout&lt;&lt;result;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<hr />

<h4>strlen</h4>

<ul>
<li>一直累加直到判断是否遇到&#8217;\0&#8217;来结束计数</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int strlen1(const char*src){
</span><span class='line'>  int count = 0;
</span><span class='line'>  while((*src++) != '\0')
</span><span class='line'>      count++;
</span><span class='line'>  return count;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  int result;
</span><span class='line'>  result = strlen1(src);
</span><span class='line'>  cout&lt;&lt;result;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>strcat</h4>

<ul>
<li>把指针移到最后，然后把b字符串的内容复制到a字符串最后</li>
<li>但是要注意a字符串要有足够的空间来支持b字符串内容的大小</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char *strcat1(char *des, const char*src){
</span><span class='line'>  char *address = des;
</span><span class='line'>  while(*address)
</span><span class='line'>      address++;
</span><span class='line'>
</span><span class='line'>  while((*address++ = *src++) !='\0');
</span><span class='line'>  return des;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char des[10] = "";
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  char *result;
</span><span class='line'>  result = strcat1(des, src);
</span><span class='line'>  printf("%s", result);
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>strcmp</h4>

<ul>
<li>如果字符串一样，那么返回0</li>
<li>如果a>b那么返回正数，否则返回负数</li>
<li>比较方法是用asc码来比较，然后最后返回相减的结果

<ul>
<li>从左到右比较，知道出现不一样的字符或者出现&#8217;\0&#8217;为止</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int strcmp1(const char *s1, const char*s2){
</span><span class='line'>  while(*s1 == *s2){
</span><span class='line'>      if(*s1 == '\0'){
</span><span class='line'>          return 0;
</span><span class='line'>      }
</span><span class='line'>      ++s1;
</span><span class='line'>      ++s2;
</span><span class='line'>  }
</span><span class='line'>  return *s1 - *s2;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *des = "aaa";
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  int result;
</span><span class='line'>  result = strcmp1(des, src);
</span><span class='line'>  if(result == 0)
</span><span class='line'>      cout&lt;&lt;"the string are the same";
</span><span class='line'>  else
</span><span class='line'>      cout&lt;&lt;"the string are not the same";
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T22:04:11-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<h4>little review about c++ object oriented</h4>

<ul>
<li>虚函数

<ul>
<li>核心理念就是基类访问派生类定义的函数</li>
<li>动态联编</li>
<li>一个函数的调用不是在编译的时候确定的，而是在运行的时候确定的，并且因为写代码的时候不能确定被调用的函数是基类的函数还是派生类的函数，所以这个函数又叫做“虚函数“</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A{
</span><span class='line'>    public:
</span><span class='line'>        virtual void test(){
</span><span class='line'>            cout&lt;&lt;"A:test() is called";
</span><span class='line'>        }        
</span><span class='line'>};
</span><span class='line'>class B: public A{
</span><span class='line'>    public:
</span><span class='line'>        virtual void test(){
</span><span class='line'>            cout&lt;&lt;"B:test() is called";
</span><span class='line'>        }
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>    A *a = new B();
</span><span class='line'>    a -&gt; test();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!--more-->


<ul>
<li><p>虚函数表</p>

<ul>
<li>实现多态的主要功能</li>
<li><strong>编译器</strong>会为每一个有虚函数的类的实例创建一个虚函数表</li>
<li>用来存虚函数的table

<ul>
<li>table的每个slot（槽）里面存放虚函数的地址</li>
</ul>
</li>
<li>但是我们可以用函数指针来看虚函数表的地址

<ul>
<li>并且虚函数表在继承中，如果派生类没有重写基类的某个函数，他就会在基类中查那个函数，然后引用的时候就会引用基类的</li>
<li>并且如果子类如果增加了函数，就会在基类的虚函数表中增加</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数</p>

<ul>
<li><code>virtual void test() = 0</code></li>
<li>意思是抽象类，也可以说是接口，用来规范派生类的行为

<ul>
<li>告诉使用者我的派生类都会有这个函数</li>
</ul>
</li>
<li>虚构析函数

<ul>
<li>当一个类要被其他的类当基类使用的时候，必须是纯虚的</li>
<li>如果有两个class A和B

<ul>
<li>B继承A，但是A的构析函数没有设置成虚函数</li>
<li>那么在delete B的实例的时候，只有A的实例被delete， B的不会被delete。。。那这不是坑爹吗。。。。</li>
<li>但是再A的构析函数前面加上virtual，这样就能保证在delete B的实例的时候，两个类的构析函数都会被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>但是构造函数不能使虚函数</p></li>
</ul>


<hr />

<h4>链表</h4>

<ul>
<li>链表ADT</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class List{
</span><span class='line'>  private:
</span><span class='line'>      void operator = (const List &){}
</span><span class='line'>      List(const List&){}
</span><span class='line'>  public:
</span><span class='line'>      List(){}
</span><span class='line'>      virtual ~List(){}
</span><span class='line'>      virtual void clear() = 0;
</span><span class='line'>      virtual void insert(const E& item) = 0;
</span><span class='line'>      virtual void append(const E& item) = 0;
</span><span class='line'>      virtual E remove() = 0;
</span><span class='line'>      //move the pointer to start
</span><span class='line'>      virtual void moveToStart() = 0;
</span><span class='line'>      //move the pointer to end
</span><span class='line'>      virtual void moveToEnd() = 0;
</span><span class='line'>      virtual void prev() = 0;
</span><span class='line'>      virtual void next() = 0;
</span><span class='line'>      virtual int length() const = 0;
</span><span class='line'>      virtual int currPos() const = 0;
</span><span class='line'>      virtual void moveToPos(int pos) = 0;
</span><span class='line'>      virtual const E& getValue() const = 0;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class AList: public List&lt;E&gt;{
</span><span class='line'>private:
</span><span class='line'>  int maxSize;
</span><span class='line'>  int listSize;
</span><span class='line'>  int curr;
</span><span class='line'>  E* listArray;   
</span><span class='line'>public:
</span><span class='line'>    //初始化列表
</span><span class='line'>  AList(int size = 100){
</span><span class='line'>      maxSize = size;
</span><span class='line'>      listSize = 0;
</span><span class='line'>      curr = 0;
</span><span class='line'>      listArray = new E[maxSize];
</span><span class='line'>  }
</span><span class='line'>  //构析函数，删掉数组，释放空间
</span><span class='line'>  ~AList(){
</span><span class='line'>      delete []listArray;
</span><span class='line'>  }
</span><span class='line'>  void clear(){
</span><span class='line'>      delete []listArray;
</span><span class='line'>      listSize = 0;
</span><span class='line'>      curr = 0;
</span><span class='line'>      listArray = new E[maxSize];
</span><span class='line'>  }
</span><span class='line'>  //把当前位置之后的数组向后移动一位，再插入
</span><span class='line'>  void insert(const E& it){
</span><span class='line'>      for(int i = listSize; i &gt; curr; i--)
</span><span class='line'>          listArray[i] = listArray[i-1];
</span><span class='line'>      //move back the array from the current position
</span><span class='line'>      listArray[curr] = it;
</span><span class='line'>      listSize++;
</span><span class='line'>  }
</span><span class='line'>  //直接在最后增加item
</span><span class='line'>  void append(const E& it){
</span><span class='line'>      listArray[listSize++] = it;
</span><span class='line'>  }
</span><span class='line'>  //记录当前的数组索引的指向的数据，把数组向前移动一位
</span><span class='line'>  E remove(){
</span><span class='line'>      E it = listArray[curr];
</span><span class='line'>      for(int i = curr; i &lt; listSize - 1; i++){
</span><span class='line'>          listArray[i] = listArray[i + 1];
</span><span class='line'>      }
</span><span class='line'>      listSize--;
</span><span class='line'>      return it;
</span><span class='line'>  }
</span><span class='line'>  void moveToStart(){
</span><span class='line'>      curr = 0;
</span><span class='line'>  }
</span><span class='line'>  void moveToEnd(){
</span><span class='line'>      curr = listSize;
</span><span class='line'>  }
</span><span class='line'>  void prev(){
</span><span class='line'>      if(curr &gt; 0)
</span><span class='line'>          curr--;
</span><span class='line'>  }
</span><span class='line'>  void next(){
</span><span class='line'>      if(curr &lt; listSize)
</span><span class='line'>          curr++;
</span><span class='line'>  }
</span><span class='line'>  int length(){
</span><span class='line'>      return listSize;
</span><span class='line'>  }
</span><span class='line'>  int currPos() const{
</span><span class='line'>      return curr;
</span><span class='line'>  }
</span><span class='line'>  void moveToPos(int pos){
</span><span class='line'>      pos = curr;
</span><span class='line'>  }
</span><span class='line'>  const E& getValue() const{
</span><span class='line'>      return listArray[curr];
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>链式实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class Link{
</span><span class='line'>public:
</span><span class='line'>  E element;
</span><span class='line'>  Link *next;
</span><span class='line'>  Link(const E& elemval, Link *nextval = NULL){
</span><span class='line'>      element = elemval;
</span><span class='line'>      next = nextval;
</span><span class='line'>  }
</span><span class='line'>  Link(Link *nextval = NULL){
</span><span class='line'>      next = nextval;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>template &lt;typename E&gt; class LList: public List&lt;E&gt;{
</span><span class='line'>private:
</span><span class='line'>  Link&lt;E&gt; *head;
</span><span class='line'>  Link&lt;E&gt; *tail;
</span><span class='line'>  Link&lt;E&gt; *curr;
</span><span class='line'>  int count;
</span><span class='line'>  void init(){
</span><span class='line'>      curr = tail = head = new Link&lt;E&gt;;
</span><span class='line'>      count = 0;
</span><span class='line'>  }
</span><span class='line'>  void removeall(){
</span><span class='line'>      while(head != NULL){
</span><span class='line'>          curr = head;
</span><span class='line'>          head = head -&gt; next;
</span><span class='line'>          delete curr;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>public:
</span><span class='line'>  LList(int size=100){
</span><span class='line'>      init();
</span><span class='line'>  }
</span><span class='line'>  ~LList(){
</span><span class='line'>      removeall();
</span><span class='line'>  }
</span><span class='line'>  void clear(){
</span><span class='line'>      removeall();
</span><span class='line'>      init();
</span><span class='line'>  }
</span><span class='line'>  void insert(const E& it){
</span><span class='line'>      //给要增加的节点初始化
</span><span class='line'>      curr -&gt; next = new Link&lt;E&gt;(it, curr -&gt; next);
</span><span class='line'>      //如果要curr指针就是再末尾
</span><span class='line'>      //那么把curr的下一个赋给tail
</span><span class='line'>      if(tail == curr)
</span><span class='line'>          tail = curr -&gt; next;
</span><span class='line'>      count++;
</span><span class='line'>  }
</span><span class='line'>  void append(const E& it){
</span><span class='line'>      //直接把末尾指针的next指向新建的link
</span><span class='line'>      tail = tail -&gt; next = new Link&lt;E&gt;(it, NULL);
</span><span class='line'>      count++;
</span><span class='line'>  }
</span><span class='line'>  //注意，这里要删除的节点叫做curr-&gt;next
</span><span class='line'>  E remove(){
</span><span class='line'>      //先把要删除的node的值存起来
</span><span class='line'>      E it = curr -&gt; next -&gt; element;
</span><span class='line'>      //用temp存一下要删除的节点
</span><span class='line'>      Link&lt;E&gt; *temp = curr -&gt; next;
</span><span class='line'>      //如果这个要删除的点是末尾，那么把末尾前一个节点赋给tail
</span><span class='line'>      if(tail == curr -&gt; next)
</span><span class='line'>          tail = curr;
</span><span class='line'>      //否则，把要删除的节点的前一个节点的next指向要删除节点的下一个
</span><span class='line'>      curr -&gt; next = curr -&gt; next -&gt; next;
</span><span class='line'>      delete temp;
</span><span class='line'>      count--;
</span><span class='line'>      return it;
</span><span class='line'>  }
</span><span class='line'>  void moveToStart(){
</span><span class='line'>      curr = head;
</span><span class='line'>  }
</span><span class='line'>  void moveToEnd(){
</span><span class='line'>      curr = tail;
</span><span class='line'>  }
</span><span class='line'>  void prev(){
</span><span class='line'>      if(curr == head)
</span><span class='line'>          return ;
</span><span class='line'>      Link&lt;E&gt; *temp = head;
</span><span class='line'>      //向左移动一个单位
</span><span class='line'>      //做法是先用temp存一个head，然后向右找，直到找到curr的前一个，然后把curr的前一个赋给curr
</span><span class='line'>      while(temp -&gt; next != curr)
</span><span class='line'>          temp = temp -&gt; next;
</span><span class='line'>      curr = temp;
</span><span class='line'>  }
</span><span class='line'>  void next(){
</span><span class='line'>      //只要curr指针不是tail，那么就向后移动
</span><span class='line'>      if(curr != tail)
</span><span class='line'>          curr = curr -&gt; next;
</span><span class='line'>  }
</span><span class='line'>  int length(){
</span><span class='line'>      return count;
</span><span class='line'>  }
</span><span class='line'>  int currPos() const{
</span><span class='line'>      Link&lt;E&gt; *temp = head;
</span><span class='line'>      //用temp指针存head，然后依次向后遍历，并且每次后移count+1
</span><span class='line'>      int i;
</span><span class='line'>      for(i = 0; i &lt; count; i++){
</span><span class='line'>          temp = temp -&gt; next;
</span><span class='line'>      }
</span><span class='line'>      return i;
</span><span class='line'>  }
</span><span class='line'>  void moveToPos(int pos){
</span><span class='line'>      curr = head;
</span><span class='line'>      //先把current的指针指向head
</span><span class='line'>      //然后一直向后移动，直到pos次
</span><span class='line'>      for(int i = 0; i &lt; pos; i++){
</span><span class='line'>          curr = curr -&gt; next;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  const E& getValue() const{
</span><span class='line'>      return curr -&gt; next -&gt; element;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>栈</h4>

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Astack{
</span><span class='line'>  private:
</span><span class='line'>      int maxSize;
</span><span class='line'>      int top;
</span><span class='line'>      int *array;
</span><span class='line'>  public:
</span><span class='line'>      Astack(int size = 100){
</span><span class='line'>          maxSize = size;
</span><span class='line'>          top = 0;
</span><span class='line'>          array = new int[size];
</span><span class='line'>      }
</span><span class='line'>      ~Astack(){
</span><span class='line'>          delete []array;
</span><span class='line'>      }
</span><span class='line'>      void clear(){
</span><span class='line'>          top = 0;
</span><span class='line'>      }
</span><span class='line'>      void push(int item){
</span><span class='line'>          array[top++] = item;
</span><span class='line'>      }
</span><span class='line'>      int pop(){
</span><span class='line'>          int temp = array[top];
</span><span class='line'>          return array[--top];
</span><span class='line'>      }
</span><span class='line'>      int getTop(){
</span><span class='line'>          return array[top - 1];
</span><span class='line'>      }   
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>  Astack a;
</span><span class='line'>  a.push(1);
</span><span class='line'>  cout&lt;&lt;a.getTop();
</span><span class='line'>  a.pop();
</span><span class='line'>  cout&lt;&lt;a.getTop();
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>队列</h4>

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Aqueue{
</span><span class='line'>  private:
</span><span class='line'>      int front;
</span><span class='line'>      int rear;
</span><span class='line'>      int maxSize;
</span><span class='line'>      int *array;
</span><span class='line'>  public:
</span><span class='line'>      Aqueue(int size = 100){
</span><span class='line'>          maxSize = size;
</span><span class='line'>          front = rear = 0;
</span><span class='line'>          array = new int[size];
</span><span class='line'>      }
</span><span class='line'>      ~Aqueue(){
</span><span class='line'>          delete [] array;
</span><span class='line'>      }
</span><span class='line'>      void enqueue(int item){
</span><span class='line'>          array[rear] = item;
</span><span class='line'>          rear = (rear + 1)%maxSize;
</span><span class='line'>      }
</span><span class='line'>      int dequeue(){
</span><span class='line'>          int temp = array[front];
</span><span class='line'>          front = (front + 1)%maxSize;
</span><span class='line'>          array[front] = 0;
</span><span class='line'>          return temp;
</span><span class='line'>      }
</span><span class='line'>      const int getFrontValue(){
</span><span class='line'>          return array[front];
</span><span class='line'>      }
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>  Aqueue q;
</span><span class='line'>  q.enqueue(1);
</span><span class='line'>  cout&lt;&lt;q.getFrontValue()&lt;&lt;endl;
</span><span class='line'>  q.dequeue();
</span><span class='line'>  cout&lt;&lt;q.getFrontValue();
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>二叉树</h4>

<ul>
<li>遍历</li>
<li>前序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void preorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        cout&lt;&lt;root-&gt;value;
</span><span class='line'>        preorder(root -&gt; left);
</span><span class='line'>        preorder(root -&gt; right);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>中序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void inorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        inorder(root -&gt; left);
</span><span class='line'>        cout&lt;&lt;root -&gt; value;
</span><span class='line'>        inorder(root -&gt; right);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>后序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void postorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        postorder(root -&gt; left);
</span><span class='line'>        postorder)root -&gt; right);
</span><span class='line'>        cout&lt;&lt;root -&gt; value;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ program run time]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time/"/>
    <updated>2015-04-20T20:52:22-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time</id>
    <content type="html"><![CDATA[<h4>时间复杂度</h4>

<ul>
<li>costs for growth rate representative of most computer algorithm

<ul>
<li><table>
<thead>
<tr>
<th>n</th>
<th>loglogn</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n<sup>2</sup></th>
<th>n<sup>3</sup></th>
<th>2<sup>n</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2</td>
<td>4</td>
<td>2<sup>4</sup></td>
<td>2*2<sup>4</sup>=2<sup>5</sup></td>
<td>2<sup>8</sup></td>
<td>2<sup>12</sup></td>
<td>2<sup>16</sup></td>
</tr>
<tr>
<td>256</td>
<td>3</td>
<td>8</td>
<td>2<sup>8</sup></td>
<td>8*2<sup>8</sup>=2<sup>11</sup></td>
<td>2<sup>16</sup></td>
<td>2<sup>24</sup></td>
<td>2<sup>256</sup></td>
</tr>
<tr>
<td>1024</td>
<td>3.3</td>
<td>10</td>
<td>2<sup>10</sup></td>
<td>10*2<sup>10</sup>=2<sup>13</sup></td>
<td>2<sup>20</sup></td>
<td>2<sup>30</sup></td>
<td>2<sup>1024</sup></td>
</tr>
<tr>
<td>64K</td>
<td>4</td>
<td>16</td>
<td>2<sup>16</sup></td>
<td>16*2<sup>16</sup>=2<sup>20</sup></td>
<td>2<sup>32</sup></td>
<td>2<sup>48</sup></td>
<td>2<sup>64K</sup></td>
</tr>
<tr>
<td>1M</td>
<td>4.3</td>
<td>20</td>
<td>2<sup>20</sup></td>
<td>20*2<sup>20</sup>=2<sup>24</sup></td>
<td>2<sup>40</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>1M</sup></td>
</tr>
<tr>
<td>1G</td>
<td>4.9</td>
<td>30</td>
<td>2<sup>30</sup></td>
<td>30*2<sup>30</sup>=2<sup>35</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>90</sup></td>
<td>2<sup>1G</sup></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>最差，最好，平均

<ul>
<li>例如顺序搜索

<ul>
<li>如果在第一个就搜到，那么就是最佳的case</li>
<li>如果搜到最后一个才搜到，那就是最差的case</li>
<li>（最佳+最差）/2为平均</li>
</ul>
</li>
<li>一般都是用平均的</li>
</ul>
</li>
<li>上界

<ul>
<li>大O表示

<ul>
<li>对一个非负的函数T(n)，T(n)是O(f(n))的当且仅当存在两个非负的c和k，使得T(n)&lt;=cf(n) 对所有n > k;

<ul>
<li>其中k为n的最小值</li>
</ul>
</li>
</ul>
</li>
<li>大omega

<ul>
<li>对一个非负的函数T(n)，T(n)是omega(g(n))当且存在两个非负的c和k，使得T(n)>=cg(n) 对所有n > k;</li>
</ul>
</li>
<li>大theta

<ul>
<li>当上界和下界被同一个常数影响。</li>
</ul>
</li>
</ul>
</li>
<li>例子</li>
<li><code>
sum1 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=n;j++)
      sum1++;
sum2 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=k;j++)
      sum2++;
</code>

<ul>
<li>第一个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了n次

<ul>
<li>那么复杂度为nlogn</li>
</ul>
</li>
</ul>
</li>
<li>第二个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了执行了k次，k=2<sup>i</sup>

<ul>
<li>那么复杂度为n</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用算法的时间复杂度</li>
<li><p><strong>搜索</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>二分搜索</td>
<td>数组查n个元素</td>
<td>logn|</td>
</tr>
<tr>
<td>顺序查找</td>
<td>数组查n个元素</td>
<td>n|</td>
</tr>
<tr>
<td>最短路（乱序数组）</td>
<td>V个点和E条边</td>
<td>V<sup>2</sup></td>
</tr>
<tr>
<td>最短路（bellman-ford）</td>
<td> V个点和E条边</td>
<td>V*E       </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p><strong>排序</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>归并排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>堆排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>插入排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>选择排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>桶排序</td>
<td>数组</td>
<td>n+k</td>
</tr>
<tr>
<td>计数排序</td>
<td>数组</td>
<td>n*k </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<h4>算法加速</h4>

<ul>
<li>focus on算法主要消耗时间的部分</li>
<li>先优化算法，再优化代码</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xapian omindex build index and search]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search/"/>
    <updated>2015-04-15T22:28:58-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search</id>
    <content type="html"><![CDATA[<h3>omega is a component that can be used with xapian</h3>

<ul>
<li>we can use omega to build index</li>
</ul>


<h4>build index</h4>

<ul>
<li><code>omindex --db index --url / ./index_file/</code>

<ul>
<li>&mdash;db 后面跟的是索引数据库的名字</li>
<li>&mdash;url 后面跟的是 / 然后再加上要建索引的数据的文件夹（含有那些要建索引的文件）</li>
</ul>
</li>
<li>运行之后，就会生成index文件夹，这个文件夹里面就是建好的索引</li>
</ul>


<h4>query</h4>

<ul>
<li>quest &mdash;db=index &ldquo;asd&rdquo;

<ul>
<li>&mdash;db 后面跟的是索引数据库</li>
<li>然后再加上要查询的关键字</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtual machine windows VS2010 UNC path not support]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/14/virtual-machine-windows-vs2010-unc-path-not-support/"/>
    <updated>2015-04-14T21:17:08-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/14/virtual-machine-windows-vs2010-unc-path-not-support</id>
    <content type="html"><![CDATA[<h3>解决UNC路径不受支持</h3>

<pre><code>在虚拟机的VS2010中编译出错
</code></pre>

<ul>
<li>错误提示：用作为当前目录的以上路径启动了 CMD.EXE。 UNC 路径不受支持。默认值设为 Windows 目录。系统找不到指定的文件。执行 c:\windows\system32\cmd.exe 时出错.</li>
<li>解决方法:

<ul>
<li>在注册表中,添加一个值即可.路径如下:

<ul>
<li>HKEY_CURRENT_USER\Software\Microsoft\Command Processor</li>
<li>添加值 DisableUNCCheck，类型为 REG_DWORD 并将该值设置为1 （十六进制）。</li>
</ul>
</li>
<li>或者，打开cmd.exe

<ul>
<li>把下面这行代码复制进去，按回车</li>
<li>reg add  &ldquo;HKEY_CURRENT_USER\Software\Microsoft\Command Processor&rdquo; /v DisableUNCCheck /t REG_DWORD /d 1 /f</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.net in mac MonoDevelop]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/14/asp-dot-net-in-mac-monodevelop/"/>
    <updated>2015-04-14T03:01:35-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/14/asp-dot-net-in-mac-monodevelop</id>
    <content type="html"><![CDATA[<h3>install asp.net environment in mac</h3>

<ul>
<li>we can use MonoDevelop IDE in mac to develop c# or VB program

<ul>
<li>also asp.net too</li>
</ul>
</li>
<li>download url: <a href="http://www.monodevelop.com/download/">http://www.monodevelop.com/download/</a>

<ul>
<li>download the Xamarin studio as development IDE</li>
</ul>
</li>
</ul>


<!--more-->


<h3>after install the environment</h3>

<ul>
<li>start a solution as ASP.NET project in C#</li>
<li>it will generate a project with some default page

<ul>
<li>The Default.aspx can be act as a html page</li>
<li>and Default.aspx.cs can act be a controller in c#</li>
<li>and Default.aspx.designer.cs can act be a model in MVC</li>
</ul>
</li>
</ul>


<h3>connect to mysql</h3>

<ul>
<li>remember to add System.Data in the Reference</li>
<li>add a MyDql.Data in Packages</li>
<li>add a <code>using MySql.Data.MySqlClient;</code> in the cs code</li>
</ul>


<h3>code for mysql connection</h3>

<ul>
<li>front end page</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;%@ Page Language="C#" Inherits="test1.Default" %&gt;
</span><span class='line'>&lt;!DOCTYPE html&gt;
</span><span class='line'>&lt;html&gt;
</span><span class='line'>&lt;head runat="server"&gt;
</span><span class='line'>  &lt;title&gt;Default&lt;/title&gt;
</span><span class='line'>  &lt;style&gt;
</span><span class='line'>  table, th, td {
</span><span class='line'>      border: 1px solid black;
</span><span class='line'>      border-collapse: collapse;
</span><span class='line'>  }
</span><span class='line'>  th, td {
</span><span class='line'>      padding: 15px;
</span><span class='line'>  }
</span><span class='line'>  &lt;/style&gt;
</span><span class='line'>&lt;/head&gt;
</span><span class='line'>&lt;body&gt;
</span><span class='line'>  &lt;form id="form1" runat="server"&gt;
</span><span class='line'>      &lt;asp:button id="clickMeButton" runat="server" text="Click Me" onClick="clickMeButton_Click" /&gt;
</span><span class='line'>      &lt;asp:label id="outputlabel" runat="server" /&gt;
</span><span class='line'>  &lt;/form&gt;
</span><span class='line'>&lt;/body&gt;
</span><span class='line'>&lt;/html&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>backend</li>
<li>cs file 1</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;code&gt;
</span><span class='line'>using System; 
</span><span class='line'>using System.Data; 
</span><span class='line'>using System.Configuration; 
</span><span class='line'>using System.Collections; 
</span><span class='line'>using System.Web; 
</span><span class='line'>using System.Web.Security; 
</span><span class='line'>using System.Web.UI; 
</span><span class='line'>using System.Web.UI.WebControls; 
</span><span class='line'>using System.Web.UI.WebControls.WebParts; 
</span><span class='line'>using System.Web.UI.HtmlControls; 
</span><span class='line'>using MySql.Data.MySqlClient; 
</span><span class='line'>namespace test1
</span><span class='line'>{
</span><span class='line'>  public partial class Default : System.Web.UI.Page
</span><span class='line'>  {
</span><span class='line'>      public void clickMeButton_Click (object sender, EventArgs e)
</span><span class='line'>      {
</span><span class='line'>          object val = ViewState["ButtonClickCount"];
</span><span class='line'>          int i = (val == null)? 1 : (int)val + 1;
</span><span class='line'>          outputlabel.Text = string.Format ("You clicked me {0} {1}", i, i==1?"time":"times");
</span><span class='line'>          ViewState["ButtonClickCount"] = i;
</span><span class='line'>          string query = "select * from reference limit 10"; 
</span><span class='line'>          MySqlConnection myConnection = new MySqlConnection("server=localhost;user id=root;password=root;database=reference_db"); 
</span><span class='line'>          MySqlCommand myCommand=new MySqlCommand(query,myConnection); 
</span><span class='line'>          myConnection.Open(); 
</span><span class='line'>          myCommand.ExecuteNonQuery(); 
</span><span class='line'>          MySqlDataReader myDataReader = myCommand.ExecuteReader(); 
</span><span class='line'>          string bookres=""; 
</span><span class='line'>          bookres += "&lt;table style=\"width:100%\"&gt;";
</span><span class='line'>          while (myDataReader.Read()==true) 
</span><span class='line'>          { 
</span><span class='line'>              bookres += "&lt;tr&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["id"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["ReferenceType"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["Record_Number"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;/tr&gt;";
</span><span class='line'>          } 
</span><span class='line'>          bookres += "&lt;/table&gt;";
</span><span class='line'>          myDataReader.Close(); 
</span><span class='line'>          myConnection.Close(); 
</span><span class='line'>          outputlabel.Text = bookres;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>cs file 2</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;code&gt;
</span><span class='line'>using System;
</span><span class='line'>using System.Web;
</span><span class='line'>using System.Web.UI;
</span><span class='line'>namespace test1
</span><span class='line'>{
</span><span class='line'>  public partial class Default
</span><span class='line'>  {
</span><span class='line'>      protected System.Web.UI.WebControls.Button button1;
</span><span class='line'>      protected System.Web.UI.WebControls.Label outputlabel;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java spring tutorial part1]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/11/java-spring-tutorial-part1/"/>
    <updated>2015-04-11T15:41:46-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/11/java-spring-tutorial-part1</id>
    <content type="html"><![CDATA[<h3>maven</h3>

<ul>
<li>make sure &lsquo;mvn -v&rsquo; return the current version in you computer</li>
<li>otherwise, install the maven first</li>
</ul>


<h3>Hello world</h3>

<ul>
<li>project hierarchy

<ul>
<li>helloworld (folder)

<ul>
<li>(root directory)</li>
<li>src

<ul>
<li>main

<ul>
<li>java

<ul>
<li>hello

<ul>
<li>Greeter.java</li>
<li>HelloWorld.java</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>target(auto generate after mvn install)

<ul>
<li>helloworld-0.1.0.jar</li>
</ul>
</li>
<li>pom.xml</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>class</h4>

<ul>
<li><code>mkdir -p src/main/java/hello</code>

<ul>
<li>make a directory to put the java class</li>
</ul>
</li>
<li>create two class <code>HelloWorld.java</code> and <code>Greeter.java</code>

<ul>
<li><p>HelloWorld.java</p>

<ul>
<li><p>&#8220;`
  package hello;</p>

<p>  import org.joda.time.LocalTime;</p>

<p>  public class HelloWorld{
      public static void main(String[] args){
          LocalTime currentTime = new LocalTime();
          System.out.println(&ldquo;The currentTime local time is &rdquo; + currentTime);
          Greeter greeter = new Greeter();
          System.out.println(greeter.sayHello());
      }
  }</p></li>
</ul>


<p>  &#8220;`</p></li>
<li><p>Greeter.java</p>

<ul>
<li><p>&#8220;`
  package hello;</p>

<p>  public class Greeter {
      public String sayHello() {
          return &ldquo;Hello world!&rdquo;;
      }
  }
&#8220;`</p></li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>configuration</h4>

<ul>
<li>pom.xml

<ul>
<li>put the file in the root of the project</li>
<li><p>&#8220;`
  &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <groupId>org.springframework</groupId>
      <artifactId>helloworld</artifactId>
      <packaging>jar</packaging>
      <version>0.1.0</version></p>

<pre><code>  &lt;!--- 插件 --&gt;
  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;joda-time&lt;/groupId&gt;
          &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
          &lt;version&gt;2.2&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
              &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
              &lt;version&gt;2.1&lt;/version&gt;
              &lt;executions&gt;
                  &lt;execution&gt;
                      &lt;phase&gt;package&lt;/phase&gt;
                      &lt;goals&gt;
                          &lt;goal&gt;shade&lt;/goal&gt;
                      &lt;/goals&gt;
                      &lt;configuration&gt;
                          &lt;transformers&gt;
                              &lt;transformer
                                  implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;
                                  &lt;mainClass&gt;hello.HelloWorld&lt;/mainClass&gt;
                              &lt;/transformer&gt;
                          &lt;/transformers&gt;
                      &lt;/configuration&gt;
                  &lt;/execution&gt;
              &lt;/executions&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>

<p>  </project>
&#8220;`</p></li>
</ul>
</li>
</ul>


<h4>run the maven project</h4>

<ul>
<li>compile

<ul>
<li>mvn compile</li>
</ul>
</li>
<li>install

<ul>
<li>mvn install</li>
</ul>
</li>
<li>two ways to run

<ul>
<li>java -jar helloworld-0.1.0.jar</li>
<li>mvn exec:java -Dexec.mainClass=&ldquo;hello.HelloWorld&rdquo;</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[install tomcat in mac]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/03/install-tomcat-in-mac/"/>
    <updated>2015-04-03T03:28:36-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/03/install-tomcat-in-mac</id>
    <content type="html"><![CDATA[<h3>install tomcat in mac</h3>

<ul>
<li>1.go to <a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and download the zip file of tomcat</li>
<li>2.then unzip the zip file into /Library and rename into &ldquo;Tomcat&rdquo;</li>
<li>3.then <code>sudo chmod 755 /Library/Tomcat/bin/*.sh</code></li>
<li>4.if you want to start tomcat

<ul>
<li><code>sudo sh startup.sh</code></li>
<li>if want to stop

<ul>
<li><code>sudo sh /Library/Tomcat/bin/shutdown.sh</code></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compile qtox on OSX]]></title>
    <link href="http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx/"/>
    <updated>2015-03-03T23:49:35-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx</id>
    <content type="html"><![CDATA[<h3>Problems when compile qtox on mac</h3>

<ul>
<li>first is the modification of the qtox.pro file</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CONFIG += c++11
</span><span class='line'>CONFIG += x86_64
</span><span class='line'>CONFIG -= x86
</span><span class='line'>contains(JENKINS,YES) {
</span><span class='line'>  INCLUDEPATH += ./libs/include/
</span><span class='line'>} else {
</span><span class='line'>  INCLUDEPATH += libs/include
</span><span class='line'>    # add head path
</span><span class='line'>    INCLUDEPATH += /usr/include
</span><span class='line'>    INCLUDEPATH += /usr/local/include
</span><span class='line'>    INCLUDEPATH += /opt/local/include
</span><span class='line'>}
</span><span class='line'>macx {
</span><span class='line'>    BUNDLEID = im.tox.qtox
</span><span class='line'>    ICON = img/icons/qtox.icns
</span><span class='line'>    QMAKE_INFO_PLIST = osx/info.plist
</span><span class='line'>    QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9
</span><span class='line'>    # add libtoxav
</span><span class='line'>    LIBS += -L/usr/local/opt/libtoxcore/lib -ltoxav -ltoxcore
</span><span class='line'>    LIBS += -L/usr/local/opt/libsodium/lib -lsodium
</span><span class='line'>    LIBS += -L/usr/local/opt/libvpx/lib -lvpx
</span><span class='line'>    LIBS += -L/usr/local/lib -lopus
</span><span class='line'>    LIBS += -L/usr/local/lib -lopencv_core -lopencv_highgui
</span><span class='line'>    #LIBS += -L/opt/local/lib -lopencv_core -lopencv_highgui
</span><span class='line'>    LIBS += -L$$PWD/libs/lib/ -framework OpenAL -mmacosx-version-min=10.9
</span><span class='line'>    #LIBS += -L$$PWD/libs/lib/ -ltoxcore -ltoxav -ltoxencryptsave -ltoxdns -lsodium -lvpx -lopus -framework OpenAL -lopencv_core -lopencv_highgui -mmacosx-version-min=10.7
</span><span class='line'>    contains(DEFINES, QTOX_PLATFORM_EXT) { LIBS += -framework IOKit -framework CoreFoundation }
</span><span class='line'>    contains(DEFINES, QTOX_FILTER_AUDIO) { LIBS += -lfilteraudio }</span></code></pre></td></tr></table></div></figure>




<!--more-->


<ul>
<li><p>1.-ltoxcore can not found</p>

<ul>
<li>install the toxcore library

<ul>
<li>and remember to add the library path</li>
</ul>
</li>
</ul>
</li>
<li><p>2.can not find -lopus</p>

<ul>
<li>install the libogg first and then install the opus library</li>
</ul>
</li>
<li><ol>
<li>“Project ERROR: Could not resolve SDK path for ‘macosx10.8′”.</li>
<li><code>cd /Users/Mark/Qt/5.3/clang_64/mkspecs/</code>

<ul>
<li>modify <code>!host_build:QMAKE_MAC_SDK = macosx10.9</code></li>
</ul>
</li>
</ol>
</li>
<li><p>4.&ldquo;Undefined symbols for architecture x86_64&rdquo;</p>

<ul>
<li><strong>not solved</strong>

<ul>
<li>one way on the Internet(did not solve)

<ul>
<li>change <code>../Qt5.4.0/5.4.0-rc1/clang_64/mkspecs/macx-clang/qmake.conf</code>

<ul>
<li>from <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.6</code></li>
<li>into <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9</code>

<ul>
<li>and remember to clean the project before rebuild</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.&lsquo;#include &lt;>&rsquo; and &lsquo;#include &ldquo;&rdquo;&rsquo;</p>

<ul>
<li>&lsquo;#include &lt;>&rsquo;

<ul>
<li>find the header in particular path

<ul>
<li>/usr/include</li>
<li>for exmaple: /usr/include/stdio.h</li>
</ul>
</li>
</ul>
</li>
<li>&lsquo;#include &ldquo;&rdquo;&rsquo;

<ul>
<li>find the header in absolute path</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CLEP microeconomic practise exam]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/28/clep-microeconomic-practise-exam/"/>
    <updated>2015-02-28T15:03:29-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/28/clep-microeconomic-practise-exam</id>
    <content type="html"><![CDATA[<h3>exam 1</h3>

<ul>
<li>1.If a producing firm does not have enough time to expand its plant capacity生产规模, it is:

<ul>
<li><strong>operating in the short run</strong></li>
<li>因为没时间，所以要赶紧做事，以免被别人打败

<ul>
<li>所以只能进行短期运营</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>2.Economic costs of production differ from accounting costs of production in that:

<ul>
<li><strong>economic costs add the opportunity cost of a firm using its own resources.</strong></li>
<li>经济利润和会计利润

<ul>
<li>会计利润：总收入减总成本</li>
<li>经济利润：总收入减总成本减机会成本</li>
</ul>
</li>
</ul>
</li>
<li><p>3.An example of a long run adjustment is:</p>

<ul>
<li><strong>Walmart builds another Supercenter.</strong></li>
<li>长期运营的话就要扩大规模</li>
</ul>
</li>
<li><p>4.The reason the marginal product of labor in the short run increases at first and then falls is because:</p>

<ul>
<li><strong>there are fewer opportunities for division of labor and specialization.</strong></li>
<li>边际产量：增加一个劳动力增加的产量</li>
<li>边际产量递减规律

<ul>
<li>边际产量递减，所以边际成本递增</li>
</ul>
</li>
<li>一开始效果明显，到后来基数大了所以就不明显了

<ul>
<li>工人少，人数增加效率增加</li>
<li>工人越多，就会存在协调问题，所以效率就会下降</li>
</ul>
</li>
</ul>
</li>
<li><p>5.If 11 workers can produce a total of 54 units of a product and another worker has a marginal product of six, then the average product of 12 workers is:</p>

<ul>
<li><strong>(54 + 6)/12 = 5</strong></li>
</ul>
</li>
<li><p>6.Economies of scale exist because as a firm increases its size in the long run长期:</p>

<ul>
<li><strong>labor and management can specialize their activities more.</strong></li>
<li><strong>as a larger input buyer the firm can purchase inputs at a lower per unit cost.</strong></li>
<li><strong>the firm can afford more sophisticated technology in production.</strong></li>
<li>规模经济：

<ul>
<li>短期无法改变固定成本，只有长期才能改变固定成本。

<ul>
<li>长期的曲线是由很多短期的曲线</li>
<li>随着产量增加，平均总成本下降(这一段就叫规模经济)</li>
<li>平均总成本上升的(这一段叫规模不经济)</li>
</ul>
</li>
<li>固定成本：器材(本来就有的)

<ul>
<li>固有资产</li>
</ul>
</li>
<li>可变成本：劳动力（可以增加可以减少）

<ul>
<li>会随着产量变动而变动的成本</li>
</ul>
</li>
<li>平均固定成本：固有资产平均分到课本成本上

<ul>
<li>随着产量的增加，递减的</li>
</ul>
</li>
<li>平均可变成本：例如原材料

<ul>
<li>随着产量的增加，递增的</li>
</ul>
</li>
<li>平均总成本：平均可变成本 + 平均固定成本

<ul>
<li>一开始是平均固定成本起主导作用，所以下降</li>
<li>然后是平均可变成本起主导作用，所以增加</li>
<li>斜率就为边际成本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>7.In natural monopolies自然垄断 such as the generation of electricity, long-run average costs continue to decrease as the plant size gets larger, because:</p>

<ul>
<li><strong>diseconomies of scale are very minor but economies of scale continue.规模经济持续</strong></li>
<li>由于规模经济造成的垄断，叫自然垄断

<ul>
<li>因为企业应为规模经济成本比较低。 所以比其他新来的企业更有竞争力</li>
</ul>
</li>
</ul>
</li>
<li><p>8.In figure 10.2, the difference between average total costs and average variable costs is:</p></li>
<li><img src="http://pbking1.github.com/images/econ/1.png" alt="Image" /></li>
<li><img src="http://pbking1.github.com/images/econ/">

<ul>
<li><strong>average fixed costs.</strong></li>
<li>平均总成本 = 平均可变成本 + 平均固定成本</li>
</ul>
</li>
<li>9.In figure 10.2, average variable costs approach average total costs as output rises because:

<ul>
<li><strong>average fixed costs are falling.</strong></li>
</ul>
</li>
<li>10.In figure 10.2, when marginal costs are rising:

<ul>
<li><strong>marginal product of labor（劳动边际产量） is declining.</strong></li>
<li>边际产量递减</li>
</ul>
</li>
<li><p>11.Both individual buyers and sellers in perfect competition:</p>

<ul>
<li><strong>have to take the market price as a given.</strong></li>
<li>都是价格接受者</li>
<li>完全竞争市场：卖家很多，买家很多，而且市场物品一样。企业能够只有进出。

<ul>
<li>当价格高于成本时，就会有新的企业进入

<ul>
<li>这时候供给多了，价格下降</li>
<li>然后变回原来的价格。然后企业就退出</li>
<li>然后价格有上升</li>
<li>所有都是价格接受者（价格就是边际成本）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>12.If a perfectly competitive seller is producing at an output where price is $11 and the marginal cost is $14.54, then to maximise profits the firm should:</p>

<ul>
<li><strong>produce a smaller level of output.</strong></li>
<li>边际成本比市场价格高

<ul>
<li>无利可图， 所以压缩产量</li>
</ul>
</li>
</ul>
</li>
<li><p>13.A very large number of small sellers who sell identical products implies:</p>

<ul>
<li><strong>the inability of one seller to influence price.</strong></li>
<li>很多卖家卖相同产品，所以都是价格接受者</li>
<li>所以不能调价，不然买家就会跑到别的市场买</li>
<li>完全竞争</li>
</ul>
</li>
<li><p><img src="http://pbking1.github.com/images/econ/2.png" alt="Image" /></p></li>
<li><img src="http://pbking1.github.com/images/econ/"></li>
<li><p>14.At price P1, the firm in figure 11.1 would produce:</p>

<ul>
<li><strong>zero</strong></li>
<li>这种图都是短期的，长期的只有一个u型曲线</li>
<li>因为固定成本是已经付出的成本</li>
<li>市场价格P1低于平均可变成本，说明成本比较高了，所以无利可图，所以不生产</li>
</ul>
</li>
<li><p>15.At price P2, the firm in figure 11.1 would produce:</p>

<ul>
<li><strong>Q5</strong></li>
<li>在Q5这个交点，如果产量低于这个交点，所以成本低于市场价格，所以有利可图</li>
<li>如果高，则成本高于市场价格，所以无利可图，不生产</li>
</ul>
</li>
<li><p>16.At price P1, the firm in figure 11.1 would:</p>

<ul>
<li><strong>lose fixed costs.</strong></li>
<li>因为不生产，所以损失掉了固定成本</li>
</ul>
</li>
<li><p>17.At price P3, the firm in figure 11.1 would:</p>

<ul>
<li><strong>break even损益均衡的</strong></li>
<li>因为MC和ATC在P3相交，所以收益和成本一样，所以没赚没亏</li>
</ul>
</li>
<li><p>18.At price P4 in the long run, the industry including the firm in figure 11.1 would:</p>

<ul>
<li><strong>have entry of new firms.</strong></li>
<li>边际收益大于平均总成本，所以会有新的企业进入赚钱</li>
</ul>
</li>
<li><p>19.At price P2 in the long run, the industry including the firm in figure 11.1 would:</p>

<ul>
<li><strong>have exit（退出） of some existing firms.</strong></li>
<li>因为长期的话,要算上平均固定成本。</li>
<li>因此所以要看平均总成本曲线，在P2，平均总成本曲线高于MC曲线，所以要退出市场。</li>
</ul>
</li>
<li><p>20.When a competitive firm finds that the market price is below its minimum average variable cost level, it will sell:</p>

<ul>
<li><strong>nothing at all, the firm shuts down.</strong></li>
<li>因为再完全竞争市场下，短期只考虑平均可变成本，当市场价格低于平均可变成本的时候，无利可图，企业关门</li>
</ul>
</li>
<li><p>21.If, as the industry expands, a competitive industry can supply larger quantities at the same long-run market price, it is:</p>

<ul>
<li><strong>a constant-cost industry.</strong></li>
<li>在一个完全市场竞争中，由于允许企业自由进出，市场价格不受买者和卖者的影响，他们都是价格接受者，所以企业成本是不会变的</li>
<li>也就是说企业的供给曲线是一条横线，企业无论供给多少，市场价格都不会变</li>
</ul>
</li>
<li><p>22.A local electricity-generating company has a monopoly that is protected by a barrier to entry that takes the form of:</p>

<ul>
<li><strong>economies of scale.</strong></li>
<li>自然垄断是因为规模经济而形成的垄断</li>
<li>规模经济是指企业产量增大而成本不断降低的阶段，其他企业想要进入，成本比该企业高，竞争力低，最终只有一家企业在做：例如自来水，电力的企业</li>
</ul>
</li>
<li><p><img src="http://pbking1.github.com/images/econ/3.png" alt="Image" /></p></li>
<li><img src="http://pbking1.github.com/images/econ/"></li>
<li><strong>这个图是垄断的成本曲线，因为边际收益MR在需求曲线下面（？）</strong></li>
<li><p>23.To profit maximize the firm in figure 14.1 will produce:</p>

<ul>
<li><strong>Q2</strong>.</li>
<li>垄断企业是价格影响者，在一定产量的前提下，增加一单位产品，想要卖出，就要降低价格，增加一个单位产品的销售，增加的利润是低于当时市场价格的，所以边际收益曲线在需求曲线之下。</li>
<li>垄断要达到最大的利润，必须边际收益等于边际成本，也就是MR=MC（Q2,P1），这个时候增加以单位产品，所得到的利益和成本相同，相互抵消不赚不亏。利用MR=MC，可以确定产量，但相应的价格，应该要在该产量下，投影到需求曲线上，这个需求曲线上的价格才是对应的价格。</li>
</ul>
</li>
<li><p>24.The profit maximize price for the firm in figure 14.1 is:</p>

<ul>
<li><strong>P3</strong></li>
<li>(?)对垄断行业（MR再需求曲线下），确定利润最大化对应的产量和价格的步骤

<ul>
<li>MR=MC(边际收益等于边际成本) &ndash;> 确定产量 &ndash;> 产量投影到需求曲线 &ndash;> 确定价格</li>
</ul>
</li>
</ul>
</li>
<li><p>25.If average total costs are ATC1, the firm in figure 14.1 will:</p>

<ul>
<li><strong>make a profit</strong></li>
<li>总成本=平均总成本*产量</li>
<li>总收益=单价*产量</li>
<li>把公式在图上表示为矩形面积，比较两个矩形，总收益大于总成本，有利润</li>
</ul>
</li>
<li><p>26.In figure 14.1, the difference between the monopoly output and the competitive output is:</p>

<ul>
<li><strong>Q3-Q2</strong></li>
<li>完全竞争市场和垄断市场，最大区别在于一个是价格接受者，一个是价格影响者</li>
<li>完全竞争市场：价格接受者，其边际收益曲线和市场需求曲线完全重合，利润最大的条件

<ul>
<li>利润最大化的条件：边际收益=边际成本（MR=MC）也就是市场需求曲线（也就是边际收益曲线）和边际成本曲线相交的点</li>
</ul>
</li>
<li>垄断市场：价格影响者，其边际收益曲线和市场需求曲线不同，比市场需求曲线低。

<ul>
<li>利润最大化的条件：边际收益=边际成本（MR=MC）也就是边际收益曲线和边际成本曲线的交点。</li>
</ul>
</li>
</ul>
</li>
<li><p>27.A profit maximizing monopolistʹs price is:</p>

<ul>
<li><strong>greater than what the price would be if the mononoplistʹs industry were competitive.</strong></li>
<li>(?)垄断市场和完全竞争市场相比，产量少，价格高</li>
</ul>
</li>
<li><p>28.The important economic concept illustrated by increasing opportunity costs is:</p>

<ul>
<li><strong>the more resources devoted to any activity, the smaller the payoff of devoting more resources to that activity.</strong></li>
<li>机会成本的根本原因是资源有限</li>
<li>所以你把资源投入到一个活动中，其他方面的活动能用的资源就变少了，这种损失的所有可能收益称为机会成本</li>
</ul>
</li>
<li><p>29.A production possibilities frontier model shows that:</p>

<ul>
<li><strong>if all resources are fully and efficiently utilized, more output of good X can only be achieved by producing less of another good.</strong></li>
<li>生产可能性边界模型，在线上的每一点都表示在充分利用资源的前提下所能生产的两种产品的产量分产品的产量组合。</li>
<li>可以想象，要增加一种产品的产量，必然要减少另外一种产品的产量，所以其曲线是斜向下的直线或者是斜向下的曲线</li>
</ul>
</li>
<li><p>30.If George can mow 10 lawns or cultivate 5 gardens a day while Jack can mow 6 lawns or cultivate 4 gardens a day, then:</p>

<ul>
<li><strong>Jack has a comparative advantage in lawn mowing.</strong></li>
<li>相对优势和绝对优势</li>
<li>绝对优势：对一个人的两个活动进行效率比较，所以两个人的绝对优势可能是一样的</li>
<li>相对优势：对两个人的同一个活动进行效率比较，所以两个人的相对优势是不会一样的。

<ul>
<li>一方在这个方面有比较优势，另一方必然是再另外一个方面有比较优势</li>
</ul>
</li>
</ul>
</li>
<li><p>31.If last year the Ajax firm sold 250 sofas at $1,000 each and this year Ajax sold 500 sofas at $1,500 each, then</p>

<ul>
<li><strong>the demand for sofas increased.</strong></li>
<li>价格从4变成了3</li>
<li>一般来说，产量的增加会导致价格的下降，而题目中产量的增加，价格也增加，说明市场上需求也增加了。</li>
</ul>
</li>
<li><p>32.The demand for big screen TVs would fall, if big screen TVs are normal goods and:</p>

<ul>
<li><strong>buyerʹs of big screen TVs incomes fall because of a recession萧条.</strong></li>
<li>对正常商品，影响其需求量的因素有：1.市场消费者数量， 2.消费者偏好， 3.消费者收入， 4.该商品自身的价格， 5.其他商品的价格</li>
<li>其中，1，2，3，5. 能够让整个需求曲线左右移动，而4 是是需求量是沿着需求曲线改变。因为该商品自身价格是需求曲线的变量。</li>
</ul>
</li>
<li><p>33.A change in demand represents a <strong><strong><strong><strong> while a change in quantity demanded is a </strong></strong></strong></strong>.</p>

<ul>
<li><strong>shift to a new demand curve</strong>; <strong>movement along one demand curve</strong></li>
<li>（？）</li>
<li>需求变动和需求量变动</li>
<li>需求变动是指需求曲线移动</li>
<li>需求量变动是指沿着需求曲线变动，需求曲线不变</li>
</ul>
</li>
<li><p>34.If the demand for a good increases when there is high unemployment, we can conclude that the commodity is:</p>

<ul>
<li><strong>an inferior下级 good</strong></li>
<li>高失业率意味着低收入。对正常商品而言，人们收入减少，对其需求也将减少，如：一般的衣服；而对低档的商品，人们收入减少，对其需求则会增加，如：咸菜</li>
</ul>
</li>
<li><p>35.An advance in technology increases supply:</p>

<ul>
<li><strong>because laborʹs or capitalʹs productivity increases and costs of production fall.</strong></li>
<li>技术的提高会增大产量，原因：效率提高了，相应的平均成本降低了。

<ul>
<li>因为产量增大，而固定成本不变，平摊到每个产品的吃那个本就下降了。</li>
</ul>
</li>
</ul>
</li>
<li><p>36.When a strike at a major local employer occurs, the demand for television sets in that local market will:</p>

<ul>
<li><strong>decreases because buyers incomes have decreased.</strong></li>
<li>罢工会引起工人收入降低，电视机是一种正常的商品。人们收入降低，对其需求减少。</li>
</ul>
</li>
<li><p>37.If the current market price for a particular book is $30 a unit and a price ceiling is imposed at $20 per book, then:</p>

<ul>
<li><strong>there will an increase in the quantity demanded of the book.</strong></li>
<li><strong>a shortage of the book will develop at the ceiling price.</strong></li>
<li><strong>a price of $20 per book is the legally allowed maximum price of the book.</strong></li>
<li>价格上限（限定最高价格）对市场价格的影响</li>
<li>当价格上限高于市场稳定价格（当供给和需求相等时的价格），价格上限对市场价格无影响，最终市场价格趋于稳定价格（当供给和需求相等时的价格）</li>
<li>当价格上限低于市场价格，此时，价格较低，对消费者有利，消费者对其需求较大，不利于生产者，生产者对其的供给量将减少。这样一来，市场需求大于供给，形成商品短缺。如果没有价格上限，市场价格将会上升。现在有了价格上限，市场价格只能趋于价格上限。</li>
</ul>
</li>
<li><p>38.Among the impacts of the minimum wage工资 is that:</p>

<ul>
<li><strong>higher costs are imposed on employers.</strong></li>
<li><strong>employers substitute other lower cost inputs in place of higher priced labor.</strong></li>
<li><strong>higher product prices result because production costs are increased.</strong></li>
<li>最低工资的影响：1.企业需要支付的工资增加了，无形中增加了产品的成本（可变成本） 2.产品成本增加，导致其价格上升 3.企业会寻求更低的价格的投入， 比如：买机器，减少工人数量</li>
</ul>
</li>
<li><p>39.After a city imposes a rent control law:</p>

<ul>
<li><strong>landlords reduce the quantity of apartments offered for rent.</strong></li>
<li>租金控制，由于租金太高所以需要控制，设定价格上限。</li>
</ul>
</li>
<li><p>40.Consumers pay 100% of a new sales tax on a good:</p>

<ul>
<li><strong>when the demand is perfectly inelastic.</strong></li>
<li>税收其实都是买房和买房共同承担的，所谓的向谁手只是决定了有谁交给政府而已。</li>
<li>对于需求价格弹性大，收税商品价格高，消费者这就会减少对其的购买，而卖家没办法，都已经进了货，只能由其交大部分的税，所以对于需求价格弹性大的商品来说，卖家交的税更多。</li>
<li>对于需求弹性小，收税价格高，买家一定要买，而买家可以不用进那么多货，所以只能由买家交大部分税。对于需求价格弹性小的商品来说，买家交的税更多。</li>
</ul>
</li>
<li><p>41.Which of the following statements about elasticity of demand需求弹性 is correct?</p>

<ul>
<li><strong>Demand is more elastic in a long time period than it is in a short time period.</strong></li>
<li>（？）需求价格弹性（是指绝对值）有以下两个特点：

<ul>
<li>1.小范围的弹性要大于大范围的弹性，因为小范围的有比较多的替代品，而大范围的比较少得替代品。比如米饭和食物，米饭弹性大，因为消费者可以不买米饭而由米粉，零食代替，当米饭价格高了，可以减少对米饭的购买；而食物，很难找到其替代品，其价格高，也必须买。</li>
<li>2.长期的弹性要大于短期的弹性，因为长期的比较灵活。比如：汽油。当汽油的价格上升的时候，对于现有车的人来说，即使现在的价格高了也必须买汽油，汽油在短期来看，其需求量变动不大；而对于现在想买车的人来说，其会考虑买比较不耗费汽油的车或者买用电的车，这样一来，汽油长期的需求量将会变动非常大。</li>
</ul>
</li>
</ul>
</li>
<li><p>42.Which of the following goods would most likely have the most inelastic demand?</p>

<ul>
<li><strong>Bread</strong></li>
<li>日常生活用品价格弹性小</li>
</ul>
</li>
<li><p>43.If at a price of $100, 10 units were sold while at a price of $125, eight units were sold, the price elasticity of demand value using the midpoint formula is:</p>

<ul>
<li><strong>one</strong></li>
<li>（？）需求价格弹性公式=需求量变动的百分比/价格变动的百分比</li>
<li>所谓的中点法是指在求百分比的时候用中点

<ul>
<li>[(8-10)/((8-10)/2)]/[(125-100)/((125+100)/2)]=-1</li>
<li>需求价格弹性是指绝对值</li>
</ul>
</li>
</ul>
</li>
<li><p>44.If at a price of $50, 20 units are sold and at a price of $60, 0 units are sold, the price elasticity of demand of the good is:</p>

<ul>
<li><strong>perfectly elastic.</strong></li>
<li>用中点法求得其需求价格弹性（指绝对值）等于11.0000011， 一般的，需求价格弹性>1，就算富有弹性。</li>
</ul>
</li>
<li><p>45.When demand is price elastic, a fall in price causes total revenue to rise because:</p>

<ul>
<li><strong>the increase in quantity sold is large enough to offset the lower price.</strong></li>
<li>富有弹性，也就是需求价格弹性（绝对值）大，价格变动一点，其需求量变动很大。</li>
<li>价格降低，消费者对其需求增大，富有弹性，说明其需求量增加的很大。当其需求量增大到收益能够大于因为价格下降而带来的损失时，卖家总收益就会增加。</li>
</ul>
</li>
<li><p>46.If the cross-price elasticity of demand for goods A and B is a positive value, this means the two goods are:</p>

<ul>
<li><strong>substitutes</strong></li>
<li>交叉需求价格弹性=一个商品需求量变动百分比/另外一种商品变动百分比</li>
<li>反映的是两种商品这种关系，如果其中一个是正数，说明一种商品价格升高，另一种商品的需求量增大，这是替代品的特征</li>
</ul>
</li>
<li><p>47.If you expect the economy is going to boom and average income in the economy will rise in the foreseeable future, the type of firm that would be able to increase its sales if your expectations are
met is:</p>

<ul>
<li><strong>one that sells a luxury good.</strong></li>
<li>奢侈品在人们收入增加，其对奢侈品的需求就会增加</li>
</ul>
</li>
<li><p>48.An external cost is created when you:</p>

<ul>
<li><strong>litter on the side of the road.</strong></li>
<li>我们研究的市场只是涉及到买方和卖方的。如果考虑旁观者的利益，则是考虑外部性。比如：企业用煤炭，对整个社会会造成污染，如果考虑这个层面，则这个企业会带来负的外部性。会造成额外的成本。</li>
</ul>
</li>
<li><p>49.Because producers do not bear the external cost of pollution:</p>

<ul>
<li><strong>production is beyond the economically efficient level.</strong></li>
<li>由于企业一般不考虑外部性，只考虑自己的利益，而对于整个社会来说，还要考虑到外部性，所以企业的产量都是超过了社会的最佳产量，对社会带来超过社会可忍受成都的负外部性。</li>
</ul>
</li>
<li><p><img src="http://pbking1.github.com/images/econ/4.png" alt="Image of Yaktocat" /></p></li>
<li><img src="http://pbking1.github.com/images/econ/"></li>
<li>50.An efficient way to get the firm in figure 5.1 to produce what society wants is:

<ul>
<li><strong>a tax to make the firm realize the external costs it imposes on others.</strong></li>
<li>为了让企业考虑外部性，一个有效的方法就是对其征税，强制让其承担外部成本</li>
</ul>
</li>
</ul>


<h3>exam 2</h3>

<ul>
<li><p>1.Ex-President Carter’s recommendation of registering women for the draft raised an uproar around the country. One opponent of this proposal stated: &ldquo;Women are needed at home to rear the children, let the men fight the wars.&rdquo; This opponent implied that:</p>

<ul>
<li><strong>the opportunity cost associated with drafting women is higher than the opportunity cost of drafting men.</strong></li>
<li>男人在家带孩子的没有女人带的好。</li>
<li>所以女人的机会成本比较大。</li>
<li>所以女人在家带孩子比较好</li>
</ul>
</li>
<li><p>2.Which of the following accurately describes the fundamental problem at the core of all economic analysis? The fundamental problem is:</p>

<ul>
<li><strong>understanding how scarce resources are allocated among competing uses to best satisfy society’s unlimited wants.</strong></li>
<li>稀有资源的最佳分配</li>
</ul>
</li>
<li><p>3.If an individual’s demand for frozen dinners increases when the price of steak rises, we would infer that:</p>

<ul>
<li><strong>steak and frozen dinners are substitutes for this person</strong>.</li>
<li>排类价格上涨，所以人们对快餐需求增加</li>
<li>所以快餐为排雷的替代品</li>
</ul>
</li>
<li><p>4.On the New York Stock Exchange, the current price per share for stock of the Boston Celtics, a NBA basketball team, is $8.25. At that price the total quantity of shares demanded is 2,500, while the total quantity supplied for trade is 2,000. It follows that</p>

<ul>
<li><strong>there is a shortage of shares of the Boston Celtics on the stock exchange.</strong></li>
<li></li>
</ul>
</li>
<li><p>6.Suppose a political candidate in the upcoming November elections promises voters more funding for AIDS research and child care, and assures them they will not have to sacrifice any other goods or services to obtain the additional programs.</p>

<ul>
<li><strong>This may be possible if the economy has unemployed resources.</strong></li>
</ul>
</li>
<li><p>7.This year the demand for new homes increases while at the same time the supply also increases. As a result of these changes in the market for new homes you can conclude that:</p>

<ul>
<li><strong>the equilibrium number of new homes will increase.</strong></li>
</ul>
</li>
<li><p>8.Some time ago the government of China required many highly skilled technicians and scientists to engage in unskilled agricultural labor in order to develop &ldquo;proper social attitudes.&rdquo; This policy caused China to produce</p>

<ul>
<li><strong>inside its PPF.</strong></li>
</ul>
</li>
<li><p>9.Recent health studies claim that consuming a glass of wine with afternoon or evening meals significantly reduces the risk of heart disease. If people believe this new information, what is likely to occur to the short-run equilibrium in the wine market?</p>

<ul>
<li><strong>Equilibrium price and quantity will both rise due to an increase in the demand for wine.</strong></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[computer architecture 1]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/13/computer-architecture-1/"/>
    <updated>2015-02-13T14:28:43-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/13/computer-architecture-1</id>
    <content type="html"><![CDATA[<h3>charpter1</h3>

<ul>
<li><p>What is computer architecture</p>

<ul>
<li>4 classes of computers

<ul>
<li>personal computer</li>
<li>server computer</li>
<li>embedded computer</li>
<li>supercomputer
<!--more--></li>
</ul>
</li>
<li><p>What does “PostPC era” mean</p>

<ul>
<li>personal mobile device(PMD)</li>
<li>cloud computing

<ul>
<li>server are replace by cloud computing</li>
<li>Software as a Service(Saas)</li>
</ul>
</li>
<li>Portion of software run on a PMD, and a portion(part of) run in the cloud</li>
</ul>
</li>
<li><p>What factors could affect performance</p>

<ul>
<li>algorithm</li>
<li>programming language, compiler, architecture</li>
<li>processor and memory system</li>
<li>I/O system(including OS and hardware)</li>
</ul>
</li>
<li><p>Eight great ideas – Know what they mean</p>

<ul>
<li>1.design for moore&rsquo;s law</li>
<li>2.use abstraction to simplify design</li>
<li>3.make the common case fast</li>
<li>4.performance via parallelism</li>
<li>5.performance via pipelining</li>
<li>6.performance via prediction</li>
<li>7.hierarchy of memory</li>
<li>8.dependability via redundancy</li>
</ul>
</li>
</ul>
</li>
<li><p>Different levels of program code</p>

<ul>
<li>HLL &ndash;> Assembly language &ndash;> ML</li>
<li>5 components of a computer

<ul>
<li>input</li>
<li>output</li>
<li>control

<ul>
<li>tells datapath, memory, I/O what to do according to the instructions.</li>
</ul>
</li>
<li>datapath

<ul>
<li>performs the arithmetic operations</li>
</ul>
</li>
<li>memory</li>
</ul>
</li>
<li><p>input &ndash;>(control, datapath)&ndash;>output</p></li>
<li><p>What is ISA?</p>

<ul>
<li>instruction set architecture

<ul>
<li>the hardware/software interface</li>
</ul>
</li>
</ul>
</li>
<li><p>Understand “Yield” in terms of chip manufacturing?</p>

<ul>
<li>Proportion of working dies per wafer晶圆(硅半导体集成电路制作所用的硅晶片)</li>
</ul>
</li>
<li><p>Response time vs Throughput</p>

<ul>
<li>Response time

<ul>
<li>How long it takes to do one task</li>
</ul>
</li>
<li>Throughput

<ul>
<li>Total work done per unit time</li>
</ul>
</li>
</ul>
</li>
<li><p>Elapsed time vs CPU time</p>

<ul>
<li>elapsed time

<ul>
<li>wall clock time

<ul>
<li>total response time, inkling everything</li>
<li>can be used to determine the system performance</li>
</ul>
</li>
</ul>
</li>
<li>cpu time

<ul>
<li>the time that cpu spent for <strong>a given process</strong></li>
<li>can be divide into user CPU time and system CPU time</li>
</ul>
</li>
</ul>
</li>
<li><p>Know how to calculate CPU time, CPI_avg, IPC, Clock rate, Clock Cycle Time, and Performance</p>

<ul>
<li>1 cycle per second &ndash;> 1 Hz

<ul>
<li>1 GHz = 10<sup>9</sup> hz</li>
</ul>
</li>
<li>clock rate(frequency)

<ul>
<li>cycle per second</li>
</ul>
</li>
<li>clock cycle time(period)

<ul>
<li>duration of a clock cycle</li>
</ul>
</li>
<li>CPU time

<ul>
<li>CPU time = CPU clock cycle * clock cycle time = CPU Clock cycle / Clock Rate</li>
</ul>
</li>
<li>Instruction count

<ul>
<li>determine by program, ISA, compiler</li>
</ul>
</li>
<li>Average cycle per instruction(CPI)

<ul>
<li>IPC = 1/CPI</li>
</ul>
</li>
<li>Clock Cycle = Instruction * Average Cycle per instruction</li>
<li>CPU time = Instruction * CPI * Clock Cycle Time

<ul>
<li>= Instruction Count * CPI / Clock Rate</li>
<li>= Instruction Count / (Clock Rate * IPC)</li>
<li>= (Instruction/program) * (Cycles/Instruction) * (Seconds/Cycle)</li>
<li>= IC * PCI * CC</li>
</ul>
</li>
<li>Clock Cycles = sum(CPI * Instruction Count)</li>
<li>how to measure performance

<ul>
<li>use instruction/second

<ul>
<li>so we can use the format clock rate/CPI</li>
</ul>
</li>
</ul>
</li>
<li>Performance depends on

<ul>
<li>Algorithm:affects IC, CPI</li>
<li>programming language: affects IC, CPI</li>
<li>Compiler:affects IC, CPI</li>
<li>ISA:affects IC, CPI, CC</li>
</ul>
</li>
<li>if you want an improvement in the execution time

<ul>
<li>you need to deduce the percentage of old time

<ul>
<li>for example

<ul>
<li>if you want to improve 50%, then you should use (100%-50%)=50% rather than (100% + 50%) = 150%</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>speed up

<ul>
<li>use the (old execute time) / (new execute time)

<ul>
<li>old time = old instruction count * old average cycle per instruction / clock rate</li>
<li>new time = new instruction count * new average cycle per instruction / clock rate

<ul>
<li>old time / new time = old instruction count * old average cycle per instruction / (new instruction count * new average cycle per instruction)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Could explain why “Power Wall” is a problem?</p>

<ul>
<li><p>situation</p>

<ul>
<li>can not reduce voltage further, and will make transistor more leaky</li>
</ul>
</li>
<li><p>Power = Capacitive Load * Voltage * Frequency</p></li>
<li><p>Understand what are the challenges on multicore processors</p>

<ul>
<li>Multicore processors: more than one core per chip</li>
<li>Hard to do

<ul>
<li>Programming for performance (not only for correctness)</li>
<li>Load balancing</li>
<li>Optimizing communication and synchronization</li>
</ul>
</li>
</ul>
</li>
<li><p>Fallacies and Pitfalls</p>

<ul>
<li>Fallacy: Some commonly held misconceptions that you might encounter

<ul>
<li>Computers at low utilization use little bit power</li>
<li>Designing for performance and designing for energy efficiency are unrelated</li>
</ul>
</li>
<li>PiGall: easily made mistakes

<ul>
<li> They are only true in a limited context</li>
<li>Can help you avoid making the same mistakes

<ul>
<li>example:

<ul>
<li>If you improve one aspect of a computer, then you would expect a proportional improvement in the overall performance</li>
<li>Using a subset of the performance equal on as a performance metric.</li>
<li>MIPS as a Performance Metric</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>e.g. MIPS, Amdahl’s Law, etc.</p></li>
</ul>
</li>
</ul>


<h3>chapter 2</h3>

<ul>
<li>Understand what is instruction and instruction set?

<ul>
<li>instruction set: the vocabulary of all commands understood

<ul>
<li>different computer have different instruction set</li>
</ul>
</li>
<li>instruction: words of computer&rsquo;s language</li>
<li>instruction set architecture(ISA): ISA serves as the interface between software and hardware

<ul>
<li>provide the mechanism by which software tells hardware what should be done</li>
</ul>
</li>
</ul>
</li>
<li>Differences between RISC and CISC

<ul>
<li>RISC

<ul>
<li>reduced instruction set computer</li>
<li>difference

<ul>
<li>fixed instruction lengths 32 bits</li>
<li>load store instruction sets</li>
<li>limited addressing modes</li>
<li>limited operations</li>
<li>simpler, cheaper</li>
<li>MIPS: typical of RISC ISAs</li>
</ul>
</li>
</ul>
</li>
<li>CISC

<ul>
<li>x86</li>
</ul>
</li>
</ul>
</li>
<li><p>MIPS ISA</p>

<ul>
<li><p>MIPS has a number 32 32-bit registers</p>

<ul>
<li>32 bit data called a word</li>
<li>memory is byte addressed

<ul>
<li>each address identifies a byte</li>
</ul>
</li>
<li>MIPS is big endian</li>
</ul>
</li>
<li><p>R and I types of instruction format</p>

<ul>
<li>R-format

<ul>
<li><code>op(6 bits)-rs(5 bits)-rt(5 bits)-rd(5 bits)-shamt(5 bits)-funct(6 bits)</code></li>
<li>add, sub</li>
</ul>
</li>
<li>I-format

<ul>
<li><code>op(6 bits)-rs(5 bits)-rt(5 bits)-constant or offset address(16 bits)</code></li>
<li>addi, lw, sw, beq, bne</li>
</ul>
</li>
</ul>
</li>
<li><p>Big endian, little endian</p>

<ul>
<li>little endian: <strong>least</strong> significant byte store at least-address of memory</li>
<li>big endian: <strong>Most</strong> significant byte store at least-address of memory</li>
</ul>
</li>
<li> Memory alignment

<ul>
<li>although computer are byte-addressable</li>
<li>memory typically organised in n-byte lines</li>
<li><strong>only the char[N] are the same in both big endian and little endian</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>How to represent unsigned and signed integers</p>

<ul>
<li>What is 2s-complement, how, why

<ul>
<li>Most-negative: 1000 0000 &hellip; 0000</li>
<li>Most-positive: 0111 1111 &hellip; 1111</li>
<li>Bit 31 is called “sign bit”</li>
<li>求负：取反加一</li>
</ul>
</li>
</ul>
</li>
<li><p>Sign extension</p>

<ul>
<li>leading bit = 1 &ndash;> negative</li>
<li>range

<ul>
<li>–2,147,483,648t o +2,147,483,647</li>
</ul>
</li>
<li>Sign extension: replicate the sign bit to the left</li>
<li>2<sup>31</sup> &ndash; 1 = 0x7FFFFFFF</li>
<li>-2<sup>31</sup> = 0x80000000</li>
<li>overflow problem

<ul>
<li>for add instruciton

<ul>
<li>128 + x > 2<sup>31</sup> &ndash; 1 the upper bound</li>
<li>128 + x &lt; -2<sup>31</sup> the lower bound</li>
</ul>
</li>
<li>so if you want to overflow, you need to bigger than 2<sup>31</sup> &ndash; 1 and smaller than -2<sup>31</sup></li>
</ul>
</li>
</ul>
</li>
<li><p>Logical operations: sll, srl, and, or, nor</p></li>
<li><p>Conditional operations: beq, bne</p>

<ul>
<li>beq: branch equal</li>
<li>bne: branch not equal</li>
</ul>
</li>
<li><p>Concept of “basic block”</p>

<ul>
<li>a basic block is a sequence of instructions with no embedded branch, no branch target</li>
</ul>
</li>
<li><p>How “Procedure calling” is supported</p>

<ul>
<li>procedure is used to structure program</li>
<li>each procedure performs a specific task</li>
<li>working like a black box</li>
</ul>
</li>
<li><p>Know jal (for calling), and jr (for return)</p>

<ul>
<li>jal procedureName

<ul>
<li>puts address of following instruction in $ra</li>
<li>jump to target address</li>
<li>procedure call</li>
</ul>
</li>
<li>jr $ra

<ul>
<li>jump-register</li>
<li>copy $ra to PC</li>
<li>procedure return</li>
</ul>
</li>
</ul>
</li>
<li><p>Understand the fact(n) assembly example</p></li>
<li><p>The memory layout of a program</p></li>
<li><p>J-type instruction format, e.g., j and jal</p>

<ul>
<li><code>op(6 bits)-instruction address(26 bits)</code></li>
</ul>
</li>
<li><p>Know how to calculate the target of PC-relative addressing, and target of (pseudo) direct jump addressing</p>

<ul>
<li>target address = PC + offset * 4</li>
<li>pseudo instructions: not real instruction

<ul>
<li>move $t0, $t1 &ndash;> add $t0, $zero, $t1</li>
<li>blt $t0, $t1, L &ndash;> slt $at, $t0, $t1

<ul>
<li> bne $at, $zero, L</li>
</ul>
</li>
<li>$at : assembler temporary</li>
</ul>
</li>
</ul>
</li>
<li><p>Hardware synchronisation instructions</p>

<ul>
<li><p>ll rt, offset(rs)</p>

<ul>
<li>load linked</li>
</ul>
</li>
<li><p>sc rt, offset(rs)</p>

<ul>
<li>store conditional</li>
</ul>
</li>
<li>rt is both input and output</li>
</ul>
</li>
<li><p>Know what information is stored in object modules</p>

<ul>
<li>the assembler translate program into <strong>machine instructions</strong> which are stored in object modules</li>
</ul>
</li>
<li><p>Know what are Compiler, Assembler, Linker, Loader used for?</p>

<ul>
<li>C program compile through compiler</li>
<li>the compiler come up with assembly language program</li>
<li>then assembler generate object(Machine language module)</li>
<li>object(machine language module and library routine) go to linker</li>
<li>the linker static link and generate executable machine language program</li>
<li>then go to loader and load into memory</li>
</ul>
</li>
<li><p>A few fallacies and pithalls</p>

<ul>
<li>instruction count and CPI are not good performance indicators in isolation</li>
<li>compiler optimisation are sensitive to algorithm</li>
<li>java compiled code s significantly faster than JVM interpreted</li>
<li>nothing can fix a dumb algorithm</li>
<li>use assembly code for high performance</li>
<li>powerful instruction &ndash;> high performance</li>
<li>importance of binary compatibility => instruction set does not change</li>
<li>sequential words are at sequential byte addresses

<ul>
<li>increment by 4</li>
</ul>
</li>
<li>using a pointer to an automatic variable outside its defining procedure

<ul>
<li>e.g passing pointer back via returning result

<ul>
<li>because pointer becomes invalid when stack popped</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MIPS instruction</p></li>
<li><table>
<thead>
<tr>
<th>MIPS instructions </th>
<th> Name </th>
<th> format</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>add</td>
<td>R</td>
</tr>
<tr>
<td>subtract</td>
<td>sub</td>
<td>R</td>
</tr>
<tr>
<td>add immediate</td>
<td>addi</td>
<td>I</td>
</tr>
<tr>
<td>load word</td>
<td>lw</td>
<td>I</td>
</tr>
<tr>
<td>store word </td>
<td> sw </td>
<td> I</td>
</tr>
<tr>
<td>load half </td>
<td> lh </td>
<td> I</td>
</tr>
<tr>
<td>load half unsigned </td>
<td> lhu </td>
<td> I</td>
</tr>
<tr>
<td>store half </td>
<td> sh </td>
<td> I</td>
</tr>
<tr>
<td>load byte </td>
<td> lb </td>
<td>  I </td>
</tr>
<tr>
<td>load byte unsigned</td>
<td> lbu </td>
<td> I</td>
</tr>
<tr>
<td>store byte </td>
<td> sb </td>
<td> I</td>
</tr>
<tr>
<td>load linked </td>
<td> ll </td>
<td> I</td>
</tr>
<tr>
<td>store conditional </td>
<td> sc </td>
<td> I</td>
</tr>
<tr>
<td>load upper immediate </td>
<td> lui </td>
<td> I</td>
</tr>
<tr>
<td>and </td>
<td> and </td>
<td> R</td>
</tr>
<tr>
<td>or </td>
<td> or </td>
<td> R</td>
</tr>
<tr>
<td>nor </td>
<td> nor </td>
<td> R</td>
</tr>
<tr>
<td>and immediate </td>
<td> andi </td>
<td> I</td>
</tr>
<tr>
<td>or immediate </td>
<td> ori </td>
<td> I</td>
</tr>
<tr>
<td>shift left logical </td>
<td> all </td>
<td> R</td>
</tr>
<tr>
<td>shift right logical </td>
<td> srl </td>
<td> R</td>
</tr>
<tr>
<td>branch on equal </td>
<td> beq </td>
<td> I</td>
</tr>
<tr>
<td>branch on not equal </td>
<td> bne </td>
<td> I</td>
</tr>
<tr>
<td>set less than </td>
<td> slt </td>
<td> R</td>
</tr>
<tr>
<td>set less than immediate  </td>
<td> slti </td>
<td> I</td>
</tr>
<tr>
<td>set less than immediate unsigned</td>
<td> sltiu </td>
<td> I</td>
</tr>
<tr>
<td>jump </td>
<td> j </td>
<td> J</td>
</tr>
<tr>
<td>jump register </td>
<td> jr </td>
<td> R</td>
</tr>
<tr>
<td>jump and link </td>
<td> jal </td>
<td> J</td>
</tr>
</tbody>
</table>
</li>
<li><p>thus we can see that R instruction contain the kind</p>

<ul>
<li>add, sub, and, or , nor, slt, shift, jump register, move, multi</li>
</ul>
</li>
<li>the I instruction contain

<ul>
<li>contain the load, store, immediate command, branch</li>
</ul>
</li>
<li><p>J instruction only have j and jal</p></li>
<li><p>汇编代码示例</p>

<ul>
<li>1.<code>if (i == j) f = g + h; else f = g - h</code>

<ul>
<li>beq $s3, $s4, Then</li>
<li>sub $s0, $s1, $s2</li>
<li>J Exit</li>
<li>Then: add $s0, $s1, $s2</li>
<li>Exit: &hellip;</li>
</ul>
</li>
<li>2.<code>while(array[i] == k) i+=1</code>

<ul>
<li>Loop:sll $t1, $s3, 2 //t1 = i * 4</li>
<li>add $t1, $t1, $s6</li>
<li>lw $t0, $t1</li>
<li>beq $s5, $t0, EXIT</li>
<li>addi $s3, $s3, 1</li>
<li>j Loop</li>
<li>EXIT:&hellip;</li>
</ul>
</li>
<li><p>3.leaf procedure example</p>

<ul>
<li><p><code>
int leaf_example(int, g, h, i, j){
  int f;
  f = (g + h) - (i - j);
  return f;
}
</code></p></li>
<li><p>MIPS code:</p>

<ul>
<li>addi $sp, $sp, -4  //save s0 on stack</li>
<li>sw $s0, 0($sp)</li>
<li>add $t0, $a0, $a1</li>
<li>add $t1, $a2, $a3</li>
<li>sub $s0, $t0, $t1</li>
<li>add $v0, $s0, $zero   //store result</li>
<li>lw $s0, 0($sp)   //store s0</li>
<li>addi $sp, $sp, 4</li>
<li>jr $ra  //return</li>
</ul>
</li>
</ul>
</li>
<li><p> 4.no leaf procedure example</p>

<ul>
<li><p> <code>
int fact(int n){
   if(n &lt; 1){
       return 1;
   }else{
       return n * fact(n - 1);
   }
}
int main(){
   int n = 10;
   fact(n);
   printf(n);
}
</code></p></li>
<li><p> MIPS code:</p>

<ul>
<li> fact:

<ul>
<li>addi $sp, $sp, -8</li>
<li>lw $ra, 4($sp)</li>
<li>lw $a0, 0($sp)</li>
<li>slti $t0, $a0, 1  //n &lt; 1, t0 = 1</li>
<li>beq $t0, $zero, L1 //if t0 == 0(means n >= 1) go to L1</li>
<li>addi $v0, $zer0, 1</li>
<li>addi $sp, $sp, 8</li>
<li>jr $ra //return address</li>
</ul>
</li>
<li> L1:

<ul>
<li>addi $a0, $a0, -1 //n = n &ndash; 1</li>
<li>jal fact //递归</li>
<li>sw $a0, 0($sp)</li>
<li>sw $ra, 4($sp)</li>
<li>addi $sp, $sp, 8</li>
<li>multi $v0, $a0, $v0 //n*fact(n-1)</li>
<li>jr $ra  //return address</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>segment place</p>

<ul>
<li>code segment &ndash;> data segment &ndash;> heap segment &ndash;> stack segment

<h3>chapter 3</h3></li>
</ul>
</li>
<li><p>Given a logic function, know how to draw its logic gate diagram</p></li>
<li><p>Given a logic gate diagram, know how to write down its logic function</p></li>
<li>Know how a full adder is implemented</li>
<li>Know what are decoder and multiplexer and how they work</li>
<li>Understand clock, register, SRAM, DRAM

<ul>
<li>SRAM:static Random Access Memory</li>
<li>DRAM:dynamic Random Access Memory</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linkedin_api_example]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/12/linkedin-api-example/"/>
    <updated>2015-02-12T14:51:14-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/12/linkedin-api-example</id>
    <content type="html"><![CDATA[<ul>
<li>we can use the RESTFUL api to get some information in linkedin

<ul>
<li><a href="https://apigee.com/console/linkedin">https://apigee.com/console/linkedin</a>

<ul>
<li>this is a online simluator to perform RESTFUL api of linkedin</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>and the sample code below is using the linkedin package from thrid party

<ul>
<li>you can download the package using the following link

<ul>
<li><a href="https://pypi.python.org/pypi/python-linkedin/4.0">https://pypi.python.org/pypi/python-linkedin/4.0</a></li>
<li><a href="https://github.com/ozgur/python-linkedin">https://github.com/ozgur/python-linkedin</a></li>
</ul>
</li>
</ul>
</li>
<li>code

<ul>
<li>the following code can produce some result

<ul>
<li>but I have some problem in using the search api

<ul>
<li>application.search_profile(selectors=[{&lsquo;people&rsquo;: [&lsquo;first-name&rsquo;, &lsquo;last-name&rsquo;]}], params={&lsquo;keywords&rsquo;: &lsquo;apple microsoft&rsquo;})</li>
</ul>
</li>
<li>Search URL is &lsquo;<a href="https://api.linkedin.com/v1/people-search:">https://api.linkedin.com/v1/people-search:</a>(people:(first-name,last-name))?keywords=apple%20microsoft&rsquo;</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /usr/bin/env python
</span><span class='line'># -*- coding: utf-8 -*-
</span><span class='line'>
</span><span class='line'>CONSUMER_KEY = 'xxxxxxx'     # This is api_key
</span><span class='line'>CONSUMER_SECRET = 'xxxxxxx'   # This is secret_key
</span><span class='line'>
</span><span class='line'>USER_TOKEN = 'xxxxxxx'   # This is oauth_token
</span><span class='line'>USER_SECRET = 'xxxxxxx'   # This is oauth_secret
</span><span class='line'>RETURN_URL = 'http://localhost:8000'
</span><span class='line'>
</span><span class='line'>from linkedin import linkedin
</span><span class='line'>from oauthlib import *
</span><span class='line'>from urllib2 import *
</span><span class='line'>import urllib2
</span><span class='line'>from json import dumps, loads
</span><span class='line'># Define CONSUMER_KEY, CONSUMER_SECRET,  
</span><span class='line'># USER_TOKEN, and USER_SECRET from the credentials 
</span><span class='line'># provided in your LinkedIn application
</span><span class='line'>
</span><span class='line'># Instantiate the developer authentication class
</span><span class='line'>authentication = linkedin.LinkedInDeveloperAuthentication(CONSUMER_KEY, CONSUMER_SECRET, 
</span><span class='line'>                                                      USER_TOKEN, USER_SECRET, 
</span><span class='line'>                                                      RETURN_URL, linkedin.PERMISSIONS.enums.values())
</span><span class='line'>
</span><span class='line'># Pass it in to the app...
</span><span class='line'>application = linkedin.LinkedInApplication(authentication)
</span><span class='line'>
</span><span class='line'>print application.get_profile()
</span><span class='line'>
</span><span class='line'>print application.get_profile(selectors=['id', 'first-name', 'last-name', 'location', 'distance', 'num-connections', 'skills', 'educations'])
</span><span class='line'>
</span><span class='line'>print application.search_company(selectors=[{'companies': ['name', 'universal-name', 'website-url']}], params={'keywords': 'apple microsoft'})
</span><span class='line'># Search URL is https://api.linkedin.com/v1/company-search:(companies:(name,universal-name,webs
</span><span class='line'>
</span><span class='line'>print application.get_memberships(params={'count': 20})
</span><span class='line'>
</span><span class='line'>print application.get_companies(company_ids=[1035], universal_names=['apple'], selectors=['name'], params={'is-company-admin': 'true'})
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro_to_microeconomic_8]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-8/"/>
    <updated>2015-02-08T22:02:14-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-8</id>
    <content type="html"><![CDATA[<h3>goal part8</h3>

<ul>
<li>C.Public policy to promote competition

<ul>
<li>1.Antitrust policy</li>
<li>2.Regulation</li>
</ul>
</li>
<li>D.Income distribution

<ul>
<li>1.Equity</li>
<li>2.Sources of income ineqiality</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>C.Public policy to promote competition 促进市场竞争的政策

<ul>
<li>1.Antitrust policy

<ul>
<li>反托拉斯法能促进竞争，了解就行</li>
</ul>
</li>
<li>2.Regulation 政府对垄断的管制

<ul>
<li>如果政府给垄断、垄断竞争、完全竞争企业一次性补贴或一次性征税（lump sum subsidy or tax），不会对企业的MC产生影响，因此不会影响利润最大化产量和价格。</li>
<li>但由于影响了ATC，导致利润或loss有变化。如果征税或补贴是按单位per unit，则会影响MC，继而影响利润最大化产量和价格。</li>
</ul>
</li>
</ul>
</li>
<li>D.Income distribution 收入分配

<ul>
<li>1.Equity

<ul>
<li>收入不平等的来源：歧视，教育程度不同，能力不同，动机不同。</li>
</ul>
</li>
<li>2.Sources of income ineqiality

<ul>
<li>收入不平等的来源</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro_to_microeconomic_7]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-7/"/>
    <updated>2015-02-08T22:02:10-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-7</id>
    <content type="html"><![CDATA[<h3>goal part7</h3>

<ul>
<li>Market Failure and the Role of Government (12%–18%)

<ul>
<li>A.Externalities

<ul>
<li>1.Marginal social benefit and marginal social cost</li>
<li>2.Positive Externalities</li>
<li>3.Negative externalities</li>
<li>4.Remedies</li>
</ul>
</li>
<li>B.Publicgoods

<ul>
<li>1.Public versus private goods</li>
<li>2.Provision of public goods</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>Market Failure and the Role of Government 市场失灵和政府管制

<ul>
<li>A.Externalities外部性

<ul>
<li>1.Marginal social benefit and marginal social cost

<ul>
<li>有外部性的经济活动会产生边际社会收益和边际社会成本</li>
</ul>
</li>
<li>2.Positive Externalities

<ul>
<li>正外部性：市场生产的数量&lt;社会最优的数量，MSB>MSC</li>
</ul>
</li>
<li>3.Negative externalities

<ul>
<li>负外部性：市场生产的数量>社会最优的数量，MSB&lt;MSC</li>
</ul>
</li>
<li>4.Remedies

<ul>
<li>对外部性的补救办法：对有负外部性的物品征税，对有正外部性的物品补贴</li>
</ul>
</li>
</ul>
</li>
<li>B.Publicgoods

<ul>
<li>1.Public versus private goods

<ul>
<li>私人物品有排他性和竞争性</li>
<li>公共物品没有排他性没有竞争性s</li>
</ul>
</li>
<li>2.Provision of public goods

<ul>
<li>公共物品的供给：政府收税，统一提供，如国防。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro_to_microeconomic_6]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-6/"/>
    <updated>2015-02-08T22:02:06-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-6</id>
    <content type="html"><![CDATA[<h3>goal part6</h3>

<ul>
<li>Factor Markets (10%–18%)

<ul>
<li>A.Derived factor demand</li>
<li>B.Marginal revenue product</li>
<li>C.Labor market and firms’ hiring of labor</li>
<li>D.Market distribution of income</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>Factor Markets  要素市场

<ul>
<li>学习时可以类比产品市场的供求均衡</li>
<li>A.Derived factor demand

<ul>
<li>派生需求，概念而已</li>
</ul>
</li>
<li>B.Marginal revenue product

<ul>
<li>边际产量值：增加一单位劳力所引起的产值的变化 MRP=P*MP</li>
</ul>
</li>
<li>C.Labor market and firms’ hiring of labor

<ul>
<li>劳动需求曲线=MRP曲线，MRP=P<em>MPL，利润最大化雇用人数：w=MRP=P</em>MP</li>
<li>A)影响需求

<ul>
<li>Price的变动，影响MRP，即需求曲线移动</li>
<li>Technological Change技术变革：技术进步—>MP增加——>MRP增加——>需求增加</li>
<li>Supply of Other factors如果企业有更多的设备（资本），劳力的MP会提高</li>
</ul>
</li>
<li>B)影响供给

<ul>
<li>Changes in Tastes 女性从家庭中走出；啃老族增加</li>
<li>Changes in other opportunities类似产品市场供给的“substitution”，金融行业吸引人，没人做工程师了……</li>
<li>Immigration 类似产品市场供给的“number of sellers”</li>
</ul>
</li>
</ul>
</li>
<li>D.Market distribution of income</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro_to_microeconomic_5]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-5/"/>
    <updated>2015-02-08T22:02:03-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-5</id>
    <content type="html"><![CDATA[<h3>goal part5</h3>

<ul>
<li>Firm behavior and market structure (25%–35%)

<ul>
<li>1.Profit:

<ul>
<li>a.Accounting versus economic profits</li>
<li>b.Normal profit</li>
<li>c.Profit maximization: MR=MC rule</li>
</ul>
</li>
<li>2.Perfect competition

<ul>
<li>a.Profit maximization</li>
<li>b.Short-run supply and shut-down decision</li>
<li>c.Firm and market behaviors in short-run and long-run equilibria</li>
<li>d.Efficiency and perfect competition</li>
</ul>
</li>
<li>3.Monopoly

<ul>
<li>a.Sources of market power</li>
<li>b.Profit maximization</li>
<li>c.Inefficiency of monopoly</li>
<li>d.Price discrimination</li>
</ul>
</li>
<li>4.Oligopoly

<ul>
<li>a.Interdependence, collusion and cartels</li>
<li>b.Game theory and strategic behavior</li>
</ul>
</li>
<li>5.Monopolistic competition

<ul>
<li>a.Product differentiation and role of advertising</li>
<li>b.Profit maximization</li>
<li>c.Short-run and long-run equilibrium</li>
<li>d.Excess capacity and inefficiency</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>1.Profit:</p>

<ul>
<li><p> a.Accounting versus economic profits</p>

<ul>
<li> 企业都是最求利益最大化的</li>
<li> 会计利润 = 总收益 &ndash; 显性成本</li>
<li> 经济利润 = 显性成本 &ndash; 隐性成本</li>
</ul>
</li>
<li><p> b.Normal profit</p>

<ul>
<li> 经济利润为0</li>
<li> 但是会计利润不为0</li>
</ul>
</li>
<li>c.Profit maximization: MR=MC rule

<ul>
<li>当MR = MC时，利润最大化</li>
</ul>
</li>
</ul>
</li>
<li><p>2.Perfect competition完全竞争</p>

<ul>
<li>特点：有许多买者与卖者，每个企业都无法影响市场价格，是price-taker，因此企业需求曲线是水平的完全弹性的，市场需求曲线向右下方倾斜；进入退出无壁垒，企业在长期无经济利润，因为有利润或损失的话就会有进入或退出直到把利润清零。</li>
<li>a.Profit maximization

<ul>
<li>P=AR是恒等式，因为P=TR/Q,AR=TR/Q。完全竞争市场很特别，企业获得利润最大化的产量是在P=MC=MR=AR时。</li>
</ul>
</li>
<li>b.Short-run supply and shut-down decision

<ul>
<li>短期的企业供给曲线是MC曲线在AVC上方的那段；在短期，如果P&lt;AVC，企业选择停业；市场长期供给曲线是水平的。</li>
</ul>
</li>
<li>c.Firm and market behaviors in short-run and long-run equilibria

<ul>
<li>窍门：单个企业和整个市场的供求成本图相互对应。因为企业是价格接受者，所以企业的价格线应与市场的一致。当市场需求有变化从而影响市场均衡价格，再反映到企业的价格变化，企业就有了短期利润或损失，吸引新企业进入市场或导致旧企业退出，从而反映到市场供给曲线往右或往左移动，进而形成新的市场均衡价格，反复调整后，长期均衡价格会等于minATC，而此时刚好也等于MC。        &ndash; 计算短期profit或loss时，应找准P和ATC，Profit=TR-TC=(P-ATC)*Q</li>
</ul>
</li>
<li>d.Efficiency and perfect competition

<ul>
<li>因为P=MC，所以完全竞争市场有效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>3.Monopoly垄断</p>

<ul>
<li>特点：只有一家企业，因此需求曲线向右下方倾斜；自己定价，是price maker；有壁垒，因此有长期经济利润</li>
<li>a.Sources of market power

<ul>
<li>垄断的三种来源：天然拥有某种资源，如南非钻石；政府给予的特权，如专利保护；自然垄断，由规模经济引起的，如供电。</li>
</ul>
</li>
<li>b.Profit maximization利益最大化

<ul>
<li>先通过MR=MC的条件确定产量Q，再通过需求曲线找到对应的P，这是垄断企业利润最大化的条件。</li>
</ul>
</li>
<li>c.Inefficiency of monopoly 垄断无效率

<ul>
<li>因为产量少于需求并且收取高于期望的价格，所以垄断是效率低的。too little of the production and charges too high a price</li>
<li>P=AR>MR</li>
<li>会画图。知道Revenue maximizing（MR=0的产量），profit maximizing（MR=MC）, efficient maximizing（P=MC）与fair return企业经济利润为0（ATC和D相交）这四种情况下的产量和价格。</li>
</ul>
</li>
<li>d.Price discrimination价格歧视

<ul>
<li>对每个消费者收取不同的价格，MR曲线与D重合，把所有消费者剩余都剥夺过来变成企业自己的利润。</li>
</ul>
</li>
</ul>
</li>
<li><p>4.Oligopoly 寡头</p>

<ul>
<li>a.Interdependence, collusion and cartels卡特尔、联盟、互赖

<ul>
<li> 受反托拉斯法的约束，有market power，企业数量很少；合作的话，如同垄断一般获利最大，如果不合作，则利润不高。</li>
</ul>
</li>
<li>b.Game theory and strategic behavior博弈论和占优策略

<ul>
<li> 会利用支付矩阵分析占优策略。题目中可能一方有占优策略另一方无占优策略，那么没有的那方要先揣测出有占优的那方的意图。</li>
</ul>
</li>
</ul>
</li>
<li><p>5.Monopolistic competition垄断竞争</p>

<ul>
<li>a.Product differentiation and role of advertising

<ul>
<li> 有许多卖者，每个卖者提供略有差别的产品，无壁垒，有决定价格的能力，做广告的必要性</li>
</ul>
</li>
<li>b.Profit maximisation

<ul>
<li>P=AR>MR</li>
</ul>
</li>
<li>c.Short-run and long-run equilibrium

<ul>
<li>短期有profit或loss，吸引新企业进入或旧企业退出市场。</li>
<li>进而达到长期均衡，D与ATC曲线相切，切点刚好是MC=MR投影到D的点，长期利润为0。因为在ATC的下降部分相切，所以有规模经济。</li>
</ul>
</li>
<li>d.Excess capacity and inefficiency

<ul>
<li>垄断竞争无效率体现在：产能过剩 Excess capacity，价格过高 P>MC</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>exercise</h4>

<ul>
<li>1.What is the connection between elasticity and total revenue?

<ul>
<li><strong>elasticity弹性 and total revenue总收益 are related</strong>

<ul>
<li><strong>if a good is elastic in demand, total revenue will increase(decrease) with a price decrease(increase).</strong></li>
<li>2.Explain why the short-run demand curve is usually less elastic than the long-run demand curve?</li>
</ul>
</li>
<li><strong>题意为：为什么短期需求曲线比长期需求曲线更加没弹性。</strong></li>
<li><p><strong>因为你在长期需求是有更多时间来决策，因此会增加你的选择可能性。并且增加需求弹性</strong></p></li>
<li><p>3.Which item in each pair has the larger elasticity of demand? Why?    &ndash; a. <strong>Sports Illustrated</strong> or a magazine    &ndash; b.Vacations or <strong>vacations in Cancun</strong>    &ndash; c.<strong>Broccoli</strong> or vegetables    &ndash; d.<strong>An IUPUI education</strong> or a college education</p></li>
<li>4.Define income elasticity of demand and cross-elasticity of demand.</li>
<li><strong>Income elasticity of demand:</strong>

<ul>
<li><strong>the percentage change in quantity demanded for a given percentage change in income.</strong></li>
</ul>
</li>
<li><strong>cross-elasticity of demand:</strong>

<ul>
<li><strong>the percentage change in the demand for good x when there is a given %change in the price of good y</strong>&ndash; 5.What are the differences between momentary, short-run, and long-run supply? Which is the most elastic? The least elastic?     &ndash; <strong>long run supply is the most elastic in demand, monetary货币 is the least elastic in demand</strong></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro_to_microeconomic_4]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-4/"/>
    <updated>2015-02-08T21:56:16-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/08/intro-to-microeconomic-4</id>
    <content type="html"><![CDATA[<h3>goal detail</h3>

<ul>
<li>Production and costs(10%–15%)

<ul>
<li>1.Production functions: short and long run短期和长期的生产函数</li>
<li>2.Marginal product and diminishing returns边际产量和边际产量递减规律</li>
<li>3.Short-run costs短期成本曲线</li>
<li>4.Long-run costs and economies of scale长期成本曲线和规模经济</li>
<li>5.cost minimising input combination</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>1.Production functions: short and long run短期和长期的生产函数</p>

<ul>
<li>生产函数反映投入个数和产量之间的关系。可以用曲线表示，横坐标为投入如劳动力数量，纵坐标为产量。可以用表格表示，一般如下：

<ul>
<li>难点：经济学上short-term和long-term的分界在于是否有一些投入是固定的，

<ul>
<li>在短期，认为没有时间改变如土地和大型设备等投入，如上表，劳力从0个增加到3个，是在设备和土地都不变的条件下；</li>
<li>在长期，认为有足够的时间调整一切投入，劳力、资本和土地都是变量，因此长期生产函数要复杂很多，可用F=f（a,b,c,……n）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.Marginal product and diminishing returns边际产量和边际产量递减规律</p>

<ul>
<li>MP of A = additional output/ additional input of A</li>
<li>Diminishing returns 和 diminishing marginal product都是边际产量递减的意思。在短期，其他投入保持不变，一种投入不断增加，它的边际产量会逐渐减少，这是拥挤造成的生产率下降。</li>
</ul>
</li>
<li><p>3.Short-run costs短期成本曲线</p>

<ul>
<li>成本曲线反映产量与成本之间的关系。横坐标是产量，纵坐标是各种成本，单位是元。</li>
<li>Q为需求数量</li>
<li><table>
<thead>
<tr>
<th>成本名字</th>
<th>定义</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>explicit costs显性成本 </td>
<td> 需要企业支付货币的投入成本 </td>
<td> no</td>
</tr>
<tr>
<td>Implicit costs隐性成本 </td>
<td> 不需要企业支付货币的投入成本 </td>
<td> no</td>
</tr>
<tr>
<td>Fixed costs固定成本 </td>
<td> 不随产量变动而变动的成本 </td>
<td> no</td>
</tr>
<tr>
<td>Variable costs可变成本 </td>
<td> 随着变量变动而变动的成本 </td>
<td> no</td>
</tr>
<tr>
<td>Total costs总成本 </td>
<td> no </td>
<td> 总成本 = 固定成本 + 可变成本</td>
</tr>
<tr>
<td>average fixed costs平均固定成本 </td>
<td> no </td>
<td> 平均固定成本 = 固定成本 / Q</td>
</tr>
<tr>
<td>average variable costs平均可变成本 </td>
<td> no </td>
<td> 平均可变成本 = 可变成本 / Q</td>
</tr>
<tr>
<td>average total costs平均总成本 </td>
<td> no </td>
<td> 平均总成本 = 总成本 / Q and 平均总成本 = 平均可变成本 + 平均固定成本</td>
</tr>
<tr>
<td>marginal costs边际成本 </td>
<td> 格外以单位产量所引起的成本的增加 </td>
<td> 边际成本 = 总成本的变化量 / Q的变化量</td>
</tr>
</tbody>
</table>
</li>
<li><p>如果产量为0， 则固定成本 = 总成本</p></li>
<li>平均固定成本随着产量的增加而递减，平均可变成本到最后肯定是递增的</li>
<li>因此平均总成本曲线是U型的</li>
<li><strong>边际成本和平均总成本只有在最低点相交一次</strong></li>
<li>边际成本曲线最后是上扬的

<ul>
<li>因为边际产量递减规律

<ul>
<li>企业一开始的时候生产能力有剩余， 增加单一单位的投入量，边际产量就会高于前一单位的投入这样可能出现一段边际成本下降</li>
<li>生产能力全部被利用之后，再增加边际投入，就会出现边际产量递减，边际成本递增</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.Long-run costs and economies of scale长期成本曲线和规模经济</p>

<ul>
<li>长期成本曲线比短期成本平坦，因为长期很多投入都是可变的，企业可以选择不同的生产规模</li>
<li>长期有economic of scale 规模经济：指随着产量增加平均总成本不断下降

<ul>
<li>反之是economic of scale规模不经济</li>
</ul>
</li>
<li>constant return to scale规模收益不变：指产量变动而平均总产量不变，或者投入增加的倍数和产出增加的倍数相同</li>
<li>总的来说，可以从两方面描述，要么随着产量的增加平均总产量如何变化，要么是投入增加和产出增加的比例是否相同</li>
<li>规模经济的产生是因为较高的产量水平允许工人实现专业化

<ul>
<li>专业化可以是工人更加精通某一项工作</li>
</ul>
</li>
</ul>
</li>
<li><p>5.cost minimising input combination</p>

<ul>
<li>成本最小化的要素组合：MP(L)/P(L)=MP(K)/P(K)</li>
</ul>
</li>
</ul>


<h3>exercise</h3>

<ul>
<li><p>1.Define marginal cost. Why does marginal cost eventually increase as total product increases?</p>

<ul>
<li><strong>marginal cost is defined as the change in total cost as one more unit of output is produced.</strong></li>
<li><strong>it eventually declines(衰减) in the short run as a result of decreasing marginal product of labor</strong></li>
</ul>
</li>
<li><p>2.What is the relationship between the long-run average cost curve and the short-run average cost curves? What do economies of scale and diseconomies of scale have on the shape of the long-run average cost curve?</p>

<ul>
<li><strong>long run average cost is the &ldquo;bottom envelop&rdquo; of the short run average cost curves</strong></li>
<li><strong>economic of scale is the decreasing sloped part of the curve, constant return to scale is the horizontal portion of the curve, and decreasing return to scale is the upward sloping part of the curve</strong></li>
</ul>
</li>
<li><p>3.What are the two main differences between the short-run and long-run? Why does diminishing marginal product exist in the short-run, but not the long run?</p>

<ul>
<li><strong>a short run will have at least one inputs is fixed in quantity</strong></li>
<li><strong>a long run will have all input varied in number</strong></li>
</ul>
</li>
<li><p>4.Why is marginal revenue equal to both average revenue and price in a perfectly competitive setting?</p>

<ul>
<li><strong>if the price is constant(say $5), then the next unit you sell will be $5(MR = $5)</strong></li>
<li><strong>if all units are sold at $5, then the average is $5(average revenue = $5)</strong></li>
</ul>
</li>
<li><p>5.Why can&rsquo;t a perfectly competitive firm influence industry price?</p>

<ul>
<li><strong>too many small firm with little market share selling homogeneous goods</strong></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
