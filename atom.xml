<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[KING]]></title>
  <link href="http://pbking1.github.com/atom.xml" rel="self"/>
  <link href="http://pbking1.github.com/"/>
  <updated>2015-05-06T15:17:25-04:00</updated>
  <id>http://pbking1.github.com/</id>
  <author>
    <name><![CDATA[pb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[computer architecture final exam review]]></title>
    <link href="http://pbking1.github.com/blog/2015/05/04/computer-architecture-final-exam-review/"/>
    <updated>2015-05-04T23:07:15-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/05/04/computer-architecture-final-exam-review</id>
    <content type="html"><![CDATA[<!--more-->


<h3>memory</h3>

<ul>
<li><p>Memory Hierarchy</p>

<ul>
<li>Understand what is memory wall? Why it is a bottleneck?瓶颈

<ul>
<li>内存壁垒：处理器和内存的悬殊持续增长</li>
<li>瓶颈：好的内存架构设计对系统的性能有越来越高的重要性</li>
</ul>
</li>
<li>Illusion provided from a memory hierarchy

<ul>
<li>传统的内存层级

<ul>
<li>通过使用局部性的优势

<ul>
<li>能够尽可能的利用磁盘上能够使用的内存</li>
<li>速度也会很快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Principle of locality (two types of locality)

<ul>
<li>定义:程序每次会使用一小部分的地址空间

<ul>
<li>temporal locality

<ul>
<li>曾经使用过的程序，再次被使用的可能会很大</li>
<li>比如循环中的指令和数据</li>
</ul>
</li>
<li>spatial locality

<ul>
<li>在执行过的程序附近的程序被使用的可能性很大</li>
<li>例如顺序执行中的数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DDR RAM? Relationship between memory clock rate and memory bandwidth

<ul>
<li>mobile system require 2X bandwidth every 2 years</li>
</ul>
</li>
<li><p>DDR DRAM 叫double data rate DRAM</p>

<ul>
<li>transfer data on rising and falling clock edges</li>
<li>E.g., 800MHz DDR &ndash;> BW?</li>
</ul>
</li>
<li><p>Know how to calculate Average Disk Read Time</p>

<ul>
<li>average disk read time = seek time + rotation latency + transfer time + controller delay</li>
<li>rpm = revolution per minutes</li>
<li>e.g

<ul>
<li>512B sector, 15000rpm, 4ms average seek time, 100MB/s transfer rate, 0.2ms controller overhead, idle disk</li>
<li> time = 4ms seek time +

<ul>
<li>(&frac12;)/(15000/60) = 2ms rotationl latency</li>
<li>512/100MB/s = 5.12 s = 0.00512ms transfer time</li>
<li>0.2ms controller delay</li>
<li>= 6.2 ms</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Difference between three types of caches:</p>

<ul>
<li><p><strong>Direct-mapped cache</strong></p>

<ul>
<li>根据索引表映射哪个cache块用来存数据</li>
<li>一个block只能有一个选择存哪里</li>
<li>内存块的那一个位置分配给cache的某个位置，由后三位决定（假设有8个块（2<sup>3</sup>=8））

<ul>
<li>001：00001，01001，10001，11001</li>
</ul>
</li>
<li>用valid bit来判断cache的数据<strong>是否存在</strong>内存那个位置</li>
<li>tag用来判断cache的数据在内存哪个位置</li>
<li><strong>重点</strong>

<ul>
<li>index不存在cache里面，就像数组不会存索引</li>
<li>假设有一个word：22

<ul>
<li>首先转成二进制10110</li>
<li>然后后三位位index</li>
<li>前两位为tag</li>
<li>然后把数据存入对应位置</li>
<li>因为没存进来的时候，对应位置没有数据，所以为miss（第一次访问那个内存地址），存入之后，才会变成hit</li>
<li>然后数据valid bit变成Y</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>n-way Set-associative cache</p>

<ul>
<li>每个set都有n个成员</li>
<li>用块的号数来决定哪个set</li>
<li>在给定的set中搜索全部成员（因为set里面的成员少，所以搜索起来快）

<ul>
<li>那么就只要比较n次，更加省时间</li>
</ul>
</li>
</ul>
</li>
<li>Fully associative cache

<ul>
<li>cache可以映射到内存中任何一个位置</li>
<li>所有成员都要搜索一次</li>
<li>耗费时间长，每个成员都要对比, 每个block的tag都要对比</li>
</ul>
</li>
</ul>
</li>
<li>For each of the above cache type

<ul>
<li><p>How to calculate a block(or set) index give an address?</p>

<ul>
<li>miss: load 的数据不再memory里面

<ul>
<li>every miss always load the 64 byte</li>
</ul>
</li>
<li>如何选block size

<ul>
<li>用两种方式

<ul>
<li>early restart

<ul>
<li>CPU在等第一个byte，但是64byte还没load进去</li>
<li>或者可以先读第一个byte， 不用等他读完</li>
</ul>
</li>
<li>critical word first</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>How to subdivide an address given a cache design, or vice versa?</p></li>
</ul>
</li>
<li>Write back vs write through（write hit）

<ul>
<li>write through

<ul>
<li>如果write hit， 则更新缓存里面的block和memory里面的block</li>
<li>这样缓存和内存里面的数据就同步了</li>
<li>但是会使得数据的写更长时间

<ul>
<li>解决方案：使用write buffer

<ul>
<li>把要写入内存的数据hold waiting</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>write back</p>

<ul>
<li>当你更新数据的时候，只改cache里面的数据</li>
<li>速度快</li>
</ul>
</li>
<li><p>两者使用的差别</p>

<ul>
<li>如果写的频率高的时候，write back快</li>
</ul>
</li>
</ul>
</li>
<li>Write allocate vs no write allocate (on write miss)

<ul>
<li>allocate

<ul>
<li>fetch the block</li>
</ul>
</li>
<li>no allocate

<ul>
<li>do not fetch the block</li>
</ul>
</li>
</ul>
</li>
<li><p>condition</p>

<ul>
<li>if read hit: cpu continue</li>
<li>if write hit: write through or write back</li>
<li>if read miss: store pipeline, read data to pipeline and continue</li>
<li>if write miss: write through (allocate or no allocate)</li>
</ul>
</li>
<li><p>Know how to calculate AMAT, actual CPI</p>

<ul>
<li>AMAT: average memory access time

<ul>
<li>hit time + miss rate * miss penalty</li>
</ul>
</li>
<li>actual CPI : cpu time divide into 2 parts

<ul>
<li>cpu execution clock cycles</li>
<li>memory stall clock cycles

<ul>
<li>(instruction / program)* <strong>(misses/introduction)</strong> * miss penalty</li>
</ul>
</li>
</ul>
</li>
<li>E.g. on a machine with one or two level caches</li>
<li>3 formulas (two from lectures, one from the HW 6 solution)</li>
</ul>
</li>
<li><p>Know what is LRU(least recent use) replacement policy</p></li>
<li>Virtual memory

<ul>
<li>What is page table</li>
<li>Address subdivision</li>
<li><p>How to translate a virtual address to a physical address</p></li>
<li><p>Purpose of MMU</p></li>
<li>What is page fault</li>
<li>How a page fault handler works?</li>
</ul>
</li>
<li>Know what is TLB

<ul>
<li>Understand the interaction between TLB and caches</li>
</ul>
</li>
<li>Know the sources of cache misses (3 Cs model) <strong>必考</strong>

<ul>
<li>三种类型的miss

<ul>
<li>compulsory miss

<ul>
<li>第一次访问会导致这种miss</li>
<li>因为第一次访问的时候数据不会在内存里面</li>
<li>解决方案

<ul>
<li>假设一个block只能存一个byte，然后我们要load 128 byte的数据

<ul>
<li>那么我们就要load 128次</li>
<li>但是如果把block增大成128 byte，那么我们只要存一次</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>capacity miss

<ul>
<li>理论上存在，实际的机器是不存在的</li>
<li>只有full associate cache</li>
<li>空间不足</li>
<li>解决方案

<ul>
<li>增大cache size</li>
</ul>
</li>
</ul>
</li>
<li>conflict miss

<ul>
<li>假设有两个entry，但是有100个要进去

<ul>
<li>这个时候就会发生这种miss</li>
</ul>
</li>
<li>也就是资源竞争</li>
<li>解决方案

<ul>
<li>增加关联性</li>
</ul>
</li>
<li>不存在与full associate cache</li>
</ul>
</li>
</ul>
</li>
<li>What about the fourth C?</li>
<li>Why each type of miss occurs?</li>
</ul>
</li>
<li>Software optimisation techniques: AVX, Loop Unrolling, Blocking?</li>
<li>A few fallacies and pitfalls</li>
</ul>


<h3>parallel processor</h3>

<ul>
<li>Amdahl&rsquo;s law

<ul>
<li>知道公式以及知道如何计算</li>
<li>公式

<ul>
<li>speedup = 1/[(1-F)+F/P]</li>
<li>F为并行化的百分比</li>
<li>P为处理器数量</li>
<li>e.g

<ul>
<li>我们有100个处理器，想要90倍的speedup</li>
<li>1/[(1-F) + F/100] = 90

<ul>
<li>F = 89*100/(99*90) = 99.9%</li>
<li>所以非并行的部分必须要&lt;=0.1%</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>strong scaling(缩放) and weak scaling

<ul>
<li>scaling

<ul>
<li>e.g1 10*10 matrix

<ul>
<li>从10个处理器加速到100个处理器，speedup是多少

<ul>
<li>首先在单个处理器：time=(10+100)*Tadd=110*Tadd</li>
<li>10个处理器

<ul>
<li>time=10*Tadd + (10*10)/10*Tadd = 20*Tadd</li>
<li>speedup = 110/20=5.5</li>
</ul>
</li>
<li>100个处理器

<ul>
<li>time=10*Tadd + (10*10)/100*Tadd = 11*Tadd</li>
<li>speedup = 110/11 = 10</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>e.g2

<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>strong scaling

<ul>
<li>数据规模确定</li>
</ul>
</li>
<li>weak scaling

<ul>
<li>数据规模和处理器的数量有关</li>
<li>例如

<ul>
<li>我们有10个处理器，那么数组的规模就是10*10</li>
<li>如果有100个处理器，那么数组的规模就是100*100</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>good understanding of hardware threading

<ul>
<li>增加单个核的资源利用率</li>
<li>在thread里面，dependency handled by scheduling and register renaming</li>
<li>不同的thread里面的指令在函数单元available 的时候执行</li>
<li>每个cycle都没有thread switching</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[operating system final exam review]]></title>
    <link href="http://pbking1.github.com/blog/2015/05/04/operating-system-final-exam-review/"/>
    <updated>2015-05-04T01:16:19-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/05/04/operating-system-final-exam-review</id>
    <content type="html"><![CDATA[<!--more-->


<h3>charpter 8 Main Memory</h3>

<ul>
<li>background

<ul>
<li><p>address binding内存绑定</p>

<ul>
<li>在三个时间发生

<ul>
<li>编译时间

<ul>
<li>如果内存地址确定，那么就生成<strong>absolute</strong>的代码：如果内存的起始地址改变了，代码就要重新编译</li>
</ul>
</li>
<li>载入时间

<ul>
<li>如果内存地址再编译时间不是确定的，就要生成<strong>relocatable</strong>(可重定位)的代码</li>
</ul>
</li>
<li>执行时间

<ul>
<li>如果进程能够重一个内存段移动到另外一个内存段，那么就把绑定地址延迟到run time。需要硬件支持</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>logical and physical address space逻辑地址和物理地址</p>

<ul>
<li>logical address

<ul>
<li>CPU生成的地址，也就是虚拟地址</li>
</ul>
</li>
<li>physical address

<ul>
<li>内存单元看见的地址</li>
<li>加载到寄存器中的地址</li>
</ul>
</li>
<li>不同

<ul>
<li>在编译时间和载入时间logical地址和physical地址一样</li>
<li>在执行时间的时候不一样</li>
</ul>
</li>
</ul>
</li>
<li>Memory management Unit(MMU)

<ul>
<li>用于映射虚拟地址到物理地址</li>
<li>因为真实的程序用的都是逻辑地址</li>
</ul>
</li>
<li>dynamic linking动态链接

<ul>
<li>和动态加载的不同在于

<ul>
<li>不是把加载延迟到运行时，而是将连接延迟到运行时</li>
</ul>
</li>
<li>常用于系统库</li>
</ul>
</li>
<li>dynamic loading动态加载

<ul>
<li>一个子程序只有在调用时才被加载，所有子程序都以可重定位的形式保存在磁盘上。</li>
<li>优点：

<ul>
<li>不用的子程序不会被装入内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>swapping交换空间

<ul>
<li>内存需要在内存中来执行</li>
<li>但是进程可以暂时从内存中交换出来到备份储存上，在执行的时候再调回内存</li>
<li>交换时间的主要消耗是在传输时间</li>
</ul>
</li>
<li>contiguous memory allocation连续内存分配<em>必考</em>

<ul>
<li>动态内存分配

<ul>
<li>首次适应</li>
<li>最佳适应</li>
<li>最差适应</li>
</ul>
</li>
</ul>
</li>
<li>segmentation分段

<ul>
<li>a segment is a logical unit

<ul>
<li>比如

<ul>
<li>main program</li>
<li>procedure</li>
<li>function</li>
<li>method</li>
<li>object</li>
<li>common lock</li>
<li>stack</li>
<li>array</li>
</ul>
</li>
</ul>
</li>
<li>外部碎片

<ul>
<li>放不进内存的块</li>
<li>因为内存被用完了，剩下的空间大小不足

<ul>
<li>因此本来要放进去的块，放不进去了</li>
</ul>
</li>
</ul>
</li>
<li>内部碎片

<ul>
<li>内存空间剩下的那些一点点的空间，放不下其他的块</li>
<li>这些小小的空间就是内部碎片</li>
</ul>
</li>
</ul>
</li>
<li>paging分页

<ul>
<li>进程的块也叫页</li>
<li><p>把页平均分成一定数量的页</p>

<ul>
<li>这样分配空间的时候可以更充分地利用空间</li>
<li>并且不会有外部碎片，只会有内部碎片</li>
</ul>
</li>
<li><p>page table</p>

<ul>
<li>use to translate logical to physical address</li>
<li>address is devided into

<ul>
<li>page number

<ul>
<li></li>
</ul>
</li>
<li>page offset</li>
</ul>
</li>
<li>implementaion

<ul>
<li>PTBR 页表基寄存器

<ul>
<li>point to page to table</li>
</ul>
</li>
<li>PRLR 页长寄存器

<ul>
<li>indicate size of the page table</li>
</ul>
</li>
<li>TLB 翻译后备缓冲器

<ul>
<li>又叫关联内存</li>
<li>special fast-lookup cache</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>effective memory-access time 有效内存访问时间

<ul>
<li>EAT = 内存映射反应时间<em>命中率 + （1-命中率）</em>（内存映射反应时间+额外时间）</li>
</ul>
</li>
<li>valid-invalid bit

<ul>
<li>用于保护</li>
<li>valid的意思是要找的页在进程的逻辑地址空间里面</li>
<li>invalid的意思是是不在</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>charpter 9 virtual memory</h3>

<ul>
<li>background

<ul>
<li>因为程序执行的时候只需要一部分程序在内存里面</li>
<li>把user的逻辑内存从物理内存里面分离出来</li>
<li>进程中所有寄存器访问的地址都是逻辑地址，这些逻辑地址在运行的时候被转换成物理地址</li>
<li>效果

<ul>
<li>主存中保留多个进程</li>
<li>进程可以比主存的全部空间还大</li>
</ul>
</li>
</ul>
</li>
<li><p>demand paging</p>

<ul>
<li>lazy swapper

<ul>
<li>只有在需要的时候才把页调进主存

<ul>
<li>可以造成更少的I/O</li>
<li>更少的内存使用</li>
<li>更快的速度</li>
<li>更多的用户</li>
</ul>
</li>
</ul>
</li>
<li>如果页已经在内存里面了，那么这个页就是valid

<ul>
<li>否则就是invalid(造成page fault，因为是对无效地址的访问)</li>
</ul>
</li>
</ul>
</li>
<li><p>page replacement</p>

<ul>
<li>FIFO

<ul>
<li>每次换第一个</li>
</ul>
</li>
<li>opt

<ul>
<li>淘汰离现在最长时间后再访问的页</li>
</ul>
</li>
<li>LRU

<ul>
<li>把离现在最远没有调用的换掉</li>
</ul>
</li>
</ul>
</li>
<li>allocation of frame

<ul>
<li>equal allocation

<ul>
<li>在n个进程之间分配m个frame

<ul>
<li>那么就是平均每个进程一个平均值m/n</li>
</ul>
</li>
</ul>
</li>
<li>proportional allocation

<ul>
<li>gloabl replacement</li>
<li>local replacement</li>
</ul>
</li>
</ul>
</li>
<li>thrashing

<ul>
<li>频繁的把页调出去又调进来，导致严重的性能问题</li>
<li><p>working-set model</p></li>
<li><p>page fault frequency</p></li>
</ul>
</li>
</ul>


<h3>charpter 10 Mass-storage structure</h3>

<ul>
<li>disk structure

<ul>
<li>logical block

<ul>
<li>disk drive被addressed做一位数组的逻辑块

<ul>
<li>这些块是传输的最小单元</li>
</ul>
</li>
</ul>
</li>
<li>CLV</li>
<li>CAV</li>
</ul>
</li>
<li>disk attachment

<ul>
<li>host attached storage accessed through I/O ports talking to I/O busses</li>
</ul>
</li>
<li>disk scheduling

<ul>
<li>access latency

<ul>
<li>= Average access time = average seek time + average latency</li>
</ul>
</li>
<li>seek time

<ul>
<li>寻道时间</li>
<li>约等于seek distance</li>
</ul>
</li>
<li>rotational latency</li>
<li>bandwidth

<ul>
<li>byte 传输的总数</li>
</ul>
</li>
<li>algorithm

<ul>
<li>比如有queue:98，183，37，122，14，124，65，67
  -start from 53</li>
<li>FCFS

<ul>
<li>从头加到尾</li>
<li>所以执行队列

<ul>
<li>53，98，183，37，122，14，124，65，67</li>
</ul>
</li>
</ul>
</li>
<li>SSTF

<ul>
<li>最常用</li>
<li>把绝对值离起点最近点依次加入</li>
<li>所以执行队列

<ul>
<li>首先排序

<ul>
<li>14，37，65，67，98，122，124，183</li>
</ul>
</li>
<li>然后找离起点绝对值最小的

<ul>
<li>53，65，67，37，14，98，122，124，183</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SCAN

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从右扫到左</li>
<li>所以执行队列

<ul>
<li>首先排序

<ul>
<li>14，37，65，67，98，122，124，183</li>
</ul>
</li>
<li>53，37，14，0，65，67，98，122，124，183，255</li>
</ul>
</li>
</ul>
</li>
<li>C-SCAN

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从头扫到尾</li>
<li>所以执行队列

<ul>
<li>首先排序

<ul>
<li>14，37，65，67，98，122，124，183</li>
</ul>
</li>
<li>53，65，67，98，122，124，183，255，0，14，37</li>
</ul>
</li>
</ul>
</li>
<li>LOOK

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从右扫到左</li>
<li>执行队列不含有0和255

<ul>
<li>53，37，14，65，67，98，122，124，183</li>
</ul>
</li>
</ul>
</li>
<li>C-LOOK

<ul>
<li>先把数组排序</li>
<li>然后从左扫到右，然后再从头扫到尾</li>
<li>53，65，67，98，122，124，183，14，37</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>disk management

<ul>
<li>low level formatting

<ul>
<li>physical formatting</li>
<li>divide a disk into sectors that the disk controller can read and write</li>
<li>把disk分成几个sector</li>
</ul>
</li>
<li>bootstrap被存储在ROM里面</li>
</ul>
</li>
<li><p>swap-space management</p>

<ul>
<li>虚拟内存使用磁盘空间来作为内存的extension</li>
<li>因为虚拟内存的使用是

<ul>
<li>程序只有一部分在内存里面，其他的部分都放在磁盘上</li>
<li>只有在需要使用其他部分的时候才会把哪些部分放进内存</li>
</ul>
</li>
</ul>
</li>
<li><p>RAID structure</p>

<ul>
<li><p>redundant array of inexpensive disks</p></li>
<li><p>reliability</p>

<ul>
<li>通过redundancy是的多个disk drives提供可靠性</li>
</ul>
</li>
<li><p>MTTF</p>

<ul>
<li>mean time to failure</li>
</ul>
</li>
<li><p>MTTR</p>

<ul>
<li>mean time to repair</li>
<li>exposure time when another failure could cause data loss</li>
</ul>
</li>
<li>data striping

<ul>
<li>把一组disk用作一个存储单元</li>
</ul>
</li>
<li>bit-level</li>
<li>block-level</li>
</ul>
</li>
</ul>


<h3>charpter 11 file system interface</h3>

<ul>
<li><p>file concept</p>

<ul>
<li><p>file attribute</p>

<ul>
<li>name</li>
<li>id</li>
<li>type</li>
<li>date</li>
<li>size</li>
<li>protection</li>
</ul>
</li>
<li><p>file operation</p>

<ul>
<li>read</li>
<li>write</li>
<li>execute</li>
<li>delete</li>
<li>create</li>
<li>seek</li>
<li>open</li>
<li>close</li>
</ul>
</li>
<li>file type

<ul>
<li>data

<ul>
<li>numeric</li>
<li>charactor</li>
<li>binary</li>
</ul>
</li>
<li>program</li>
</ul>
</li>
</ul>
</li>
<li><p>access method</p>

<ul>
<li>sequential access顺序访问

<ul>
<li>一个记录接着一个记录的访问</li>
<li>常用于文件读写</li>
</ul>
</li>
<li>direct access直接访问

<ul>
<li>文件由固定长度的逻辑记录组成，允许任何程序按照任意顺序进行快速读和写</li>
<li>基于文件的磁盘模式</li>
<li>常用语数据库</li>
</ul>
</li>
</ul>
</li>
<li>directory and disk structure

<ul>
<li>single level directory

<ul>
<li>相当于单层map

<ul>
<li>&lt;command,file></li>
</ul>
</li>
</ul>
</li>
<li>two level directory

<ul>
<li>每个用户都有自己的文件目录</li>
<li>相当于双层map

<ul>
<li>第一层变成&lt;user,command></li>
<li>第二层变成&lt;command,file></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>tree structure directory

<ul>
<li>general graph directory

<ul>
<li>其实和双层很像，前两层一样

<ul>
<li>第三层开始多了很多别的命令的map</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>file system mounting

<ul>
<li>mount point

<ul>
<li>文件系统使用之前必须要mount</li>
<li>也就是说目录结构要建立在多个分区上就必须安装这些分区来使其可用</li>
<li>mount point 通常是空目录

<ul>
<li>用于安装文件系统</li>
<li>e.g unix常常安装在/home

<ul>
<li>这样访问这个文件系统的目录结构的时候

<ul>
<li>只要加上这个/home前缀就可以了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>charpter 12 file system implementation</h3>

<ul>
<li>file system structure

<ul>
<li>文件结构

<ul>
<li>逻辑存储单元</li>
<li>相关信息的收集</li>
</ul>
</li>
<li>文件系统依赖磁盘</li>
<li>磁盘提供random access和inplace write</li>
<li>file control block

<ul>
<li>记录文件信息</li>
</ul>
</li>
<li>device driver</li>
<li>layer file system

<ul>
<li>应用程序->逻辑文件系统->文件组织模块->基本文件系统->I/O控制->设备</li>
</ul>
</li>
</ul>
</li>
<li>file system implementation

<ul>
<li>使用多个磁盘和内存结构

<ul>
<li>boot control block

<ul>
<li>包括系统冲该分区引导操作系统所需要的信息</li>
</ul>
</li>
<li>partition control block

<ul>
<li>包括分区的详细信息</li>
</ul>
</li>
</ul>
</li>
<li>VFS

<ul>
<li>虚拟文件系统允许使用同样的系统调用API来使用不同类型的文件系统</li>
</ul>
</li>
</ul>
</li>
<li>directory implementation
  -使用线性表和hash表来指向数据块</li>
<li><p>allocation method</p>

<ul>
<li>disk block给文件的分配方法</li>
<li>连续分配

<ul>
<li>continguous allocation</li>
<li>每个文件使用一个集合的连续块</li>
</ul>
</li>
<li>链式分配

<ul>
<li>每个文件都有一个链表的block</li>
</ul>
</li>
<li>index分配

<ul>
<li>每个文件都有他自己的index block</li>
</ul>
</li>
</ul>
</li>
<li><p>free space management</p>

<ul>
<li>文件系统使用free space list 来跟踪可以使用的block</li>
<li>bit vector</li>
<li>bit map</li>
<li>Grouping</li>
<li>counting</li>
</ul>
</li>
<li><p>efficiency and performance</p>

<ul>
<li>效率

<ul>
<li>取决于所使用的磁盘分配和目录管理算法</li>
<li>首先是只要是磁盘就会有一定的空间用来存索引节点

<ul>
<li>因为索引会加快查询</li>
</ul>
</li>
</ul>
</li>
<li>性能

<ul>
<li>增加复杂的index</li>
</ul>
</li>
</ul>
</li>
<li><p>recovery</p>

<ul>
<li>consistency checking

<ul>
<li>compare data in directory structure with data block on disk and try to fix inconsistencies</li>
<li>慢而且容易失败</li>
</ul>
</li>
<li>用系统程序备份数据</li>
<li>用备份恢复系统程序</li>
</ul>
</li>
<li><p>log structured file system</p>

<ul>
<li>用来记录每个metadata的更新</li>
</ul>
</li>
<li><p>NFS</p>

<ul>
<li>一个用来通过网络远程access file的软件系统</li>
</ul>
</li>
</ul>


<h3>charpter 13 I/O system</h3>

<ul>
<li>I/O hardware

<ul>
<li><p>basic</p>

<ul>
<li>port端口

<ul>
<li>设备的连接点</li>
</ul>
</li>
<li>bus总线

<ul>
<li>直接共享连接</li>
</ul>
</li>
<li>controller控制器

<ul>
<li>操作port，bus，device的电子元件</li>
</ul>
</li>
<li>I/O指令控制设备</li>
</ul>
</li>
<li><p>SCSI</p>

<ul>
<li>SCSI总线控制器常常是纤维和计算机相连接的独立线路板或者主机适配器</li>
</ul>
</li>
<li><p>memory mapped I/O</p>

<ul>
<li>内存映射I/O

<ul>
<li>设备数据和指令寄存器映射到处理器的地址空间</li>
<li>例如，PC可以用I/O指令来控制一些设备，并且使用内存映射I/O来控制其他设备</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O port register</p></li>
<li>polling轮询

<ul>
<li>主机和控制器之间的交互完成协议需要握手</li>
<li>过程

<ul>
<li>首先<strong>忙等待</strong>读取忙bit</li>
<li>然后如果接到下一个命令，就清除忙bit</li>
<li>然后通过命令寄存器里面的命令就绪bit来表示其意愿</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>interrupt

<ul>
<li>设备控制器通过catch中断并且dispatch到中断处理程序</li>
<li>中断处理程序通过处理设备来清除中断</li>
<li>终端也可以用与异常处理</li>
</ul>
</li>
<li>DMA

<ul>
<li>直接内存访问</li>
<li>direct memory access</li>
<li>用于避免对大规模数据移动使用I/O</li>
<li>这样无需cpu的帮助也可以把地址放到总线然后开始传输</li>
</ul>
</li>
<li>Kernal I/O subsystem

<ul>
<li>I/O scheduing

<ul>
<li>有一些I/O请求通过设备队列来排序</li>
<li>有一些操作系统使用公平式的</li>
<li>有一席实现服务质量</li>
</ul>
</li>
<li>buffering

<ul>
<li>在设备之间传输数据的时候把数据存在内存里面</li>
<li>为了解决以下两种情况

<ul>
<li>设备速度不一样</li>
<li>设备传输大小不一样</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>安全</h3>

<ul>
<li><p>goal of protection</p>

<ul>
<li>确保每个对象的访问都是正确的，没有越权访问</li>
</ul>
</li>
<li><p>principal of protection</p>

<ul>
<li>最低优先级准则

<ul>
<li>给程序分配他所需要的最低优先级</li>
</ul>
</li>
</ul>
</li>
<li><p>domain of protection</p>

<ul>
<li><p>domain:set of access right</p>

<ul>
<li>等于user id</li>
<li>在文件系统之间交换</li>
</ul>
</li>
<li><p>domain：可以含有user, process, procedure</p></li>
<li>access-right: &lt;object-name, right-set></li>
</ul>
</li>
<li><p>accesss matrix</p>

<ul>
<li>行：domain</li>
<li>列：object</li>
<li>Access(i,j)：在domain(i)中的process能够对object(j)使用的operation set</li>
</ul>
</li>
<li>implementation of the access matrix

<ul>
<li>用(sparse)稀疏矩阵实现</li>
<li>option1

<ul>
<li>global table

<ul>
<li>三元式&lt;domain, object, right-set></li>
</ul>
</li>
</ul>
</li>
<li>option2

<ul>
<li>access list

<ul>
<li>每一列是一个object</li>
<li>然后每个object含有一个list&lt;domain, right-set></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>access control

<ul>
<li>使用access matrix 来控制用户的访问权限</li>
<li>要对process设置privilage</li>
<li>capacity list</li>
<li>access list</li>
</ul>
</li>
<li>security problem

<ul>
<li>资源和访问是否在所有情况下使用正确</li>
<li>man in the middle attack

<ul>
<li>接入sender和receiver的信息传输

<ul>
<li>更改传输的信息</li>
</ul>
</li>
</ul>
</li>
<li>four level of security problem

<ul>
<li>physical</li>
<li>operating system</li>
<li>human</li>
<li>network</li>
</ul>
</li>
</ul>
</li>
<li>program threat

<ul>
<li><p>trojan horse</p>

<ul>
<li>木马</li>
<li>一个误用自身环境的代码段</li>
</ul>
</li>
<li><p>trap door</p>

<ul>
<li>后门</li>
<li>在程序中留一个只有他自己可以使用的漏洞</li>
</ul>
</li>
<li>logic bomb

<ul>
<li>在某种特殊情况下才会激发的安全隐患</li>
</ul>
</li>
<li>virus

<ul>
<li>在正常软件中嵌入的代码段</li>
<li>用来感染别的电脑</li>
</ul>
</li>
</ul>
</li>
<li>system an network threat

<ul>
<li>worm

<ul>
<li>通过繁殖机制破坏系统性能的进程

<ul>
<li>大量繁殖导致操作系统耗尽资源</li>
<li>然后瘫痪系统</li>
</ul>
</li>
</ul>
</li>
<li>morris internet worm

<ul>
<li>一个字符串查询finger，超出分配给输入的缓冲，并且覆写栈</li>
</ul>
</li>
</ul>
</li>
<li>crytography as a security tool

<ul>
<li>RSA工作方式

<ul>
<li>加密用公钥</li>
<li>解密用私钥</li>
</ul>
</li>
<li>同步加密</li>
<li>异步加密</li>
</ul>
</li>
<li>user authentication

<ul>
<li>密码</li>
<li>biometric</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[computation theory final exam review]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/30/computation-theory-final-exam-review/"/>
    <updated>2015-04-30T23:45:08-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/30/computation-theory-final-exam-review</id>
    <content type="html"><![CDATA[<h3>Chapter 12:</h3>

<ul>
<li>undecidable decision problem不可解问题

<ul>
<li>不是所有问题都能找到多项式级的算法</li>
<li>有些问题甚至没有正确的算法</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>Understand what it means for a problem to be decidable (or not)

<ul>
<li>A decision problem is any arbitrary yes-or-no question on an infinite set of input.</li>
<li>也就是任意的输入都能产生一个yes或者no的结果</li>
</ul>
</li>
<li>Be able to state the Halting Problem and discuss its implications含义.

<ul>
<li>halting problem 停机问题

<ul>
<li>因为不存在一个算法，是的我们无法写出一个程序来判断一个随机程序P能够对所有的输入停机</li>
<li>判断任意一个程序是否会在有限的时间之内结束执行的问题。该问题等价于

<ul>
<li>给定一个程序P和输入w，程序P再输入w下能够最终停止</li>
</ul>
</li>
<li>停机问题是无解的</li>
</ul>
</li>
</ul>
</li>
<li>Be able to outline概述 a proof of the Halting Problem.

<ul>
<li>证明

<ul>
<li>用反证

<ul>
<li>假设停机问题有解

<ul>
<li>那么就存在过程H(P,I)可以判断程序P再输入I的情况下是否可停机的问题

<ul>
<li>如果P在输入的时候可以停机，那么H输出停机</li>
<li>如果不能停机，就输出无限循环（无限循环那么其实也是停机），所以矛盾</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to carry out a reducibility（归约） argument辩论.

<ul>
<li>一个问题A能够归约化为问题B的含义是，可以用问题B的解法解决A</li>
<li>e.g

<ul>
<li>我们要求解一个一元一次方程和一个一元二次方程，那么我们可以说前者可以约化成后者</li>
<li>也可以说求解一元二次方程的时间复杂度要高于求解一元一次方程

<ul>
<li>因为如果求解一元二次方程的时间复杂度比求解一元一次方程的时间复杂度还低，那么就可以把算法优化</li>
</ul>
</li>
</ul>
</li>
<li>约化的过程只有在用多项式的时间完成才有意义</li>
</ul>
</li>
</ul>


<h3>Chapter 14:</h3>

<ul>
<li>Be able to give an informal definition for the sets P, NP, and NP-complete.

<ul>
<li>set P

<ul>
<li>问题能够再多项式（polynomial）时间内<strong>解决</strong></li>
<li>也就是可以一步步很有效率的解决的问题</li>
<li>或者说，可以用deterministic sequential machine在多项式时间内解决的decision problem</li>
</ul>
</li>
<li>set NP

<ul>
<li>在多项式时间内验证一个解的问题，也就是在多项式时间内猜出一个解的问题</li>
<li>也就是你求出了一个问题的解，我要<strong>验证</strong>你的解是否正确，我用了多项式时间，至于你求解这个问题是否用多项式时间不关我事，可能这个问题有多项式的算法，可能没有。</li>
<li>或者说，可以用non deterministic sequential machine在多项式时间内解决的decision problem。

<ul>
<li>这类问题只要给个解答，可以很快验证这个解答是否正确</li>
</ul>
</li>
</ul>
</li>
<li>set NP-complete

<ul>
<li>最麻烦的NP问题，基本不可能有P的解法

<ul>
<li>例子：

<ul>
<li>我们要在一堆整数内找出和为零的那些组合

<ul>
<li>我们可以很容易验证一个组合的和是否为零，因此是NP问题</li>
<li>但是要我们去找，是没有P的解法的</li>
<li>所以这个是一个NP-complete问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>通俗的讲就是一个时间复杂度最高，并且能够“通吃“所有NP问题的NP问题

<ul>
<li>也就是解决了这个问题，所有的NP问题就解决了</li>
</ul>
</li>
<li>有以下两个条件

<ul>
<li>1.是一个NP问题</li>
<li>2.所有NP问题都能约化成它</li>
</ul>
</li>
<li>证明NP-complete问题

<ul>
<li>首先证明他是一个NP问题</li>
<li>然后证明其中一个NP-complete问题能够约化成它。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关系</strong>

<ul>
<li><strong>NP和NP-hard的交集是NP-complete</strong></li>
<li><strong>P在NP内</strong></li>
<li>所有NP问题都可以设计出一个多项式的算法，转换成另外一个NP问题

<ul>
<li>也就是所有的NP问题都可以用多项式时间的算法来彼此转换</li>
</ul>
</li>
</ul>
</li>
<li>NP=P？

<ul>
<li>也就是NP是否能够用P的时间解决？

<ul>
<li>如果可一个话，NP问题就会都变成P问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to give an informal definition for the set NP hard and its relationship to the classes P,    NP, and NP-complete.

<ul>
<li>NP-hard问题

<ul>
<li>满足NP-complete问题的第二个条件，但是不满足第一个条件</li>
<li>也就是所有NP问题都能约化成它，但是它不是一个NP问题</li>
<li>定义：一个问题被称为P-hard问题，当且仅当一个NP-complete问题可以在多项式时间内归约到这个问题</li>
<li>也就是NP-hard问题比NP-complete问题还难</li>
</ul>
</li>
</ul>
</li>
<li>Be able to name some NP-complete problems.

<ul>
<li>traveling salesman problem旅行者问题

<ul>
<li>这个问题是NP-complete问题，并且这个也是NP-hard问题</li>
<li>是一个多局部最优的最优化问题</li>
<li>问题描述：

<ul>
<li>有n个城市，一个推销员要从其中一个城市出发，走遍所有城市（每个城市只能走一遍），再回到原点，求<strong>是否存在</strong>最短路</li>
<li>如果暴力枚举，只能O(n!)</li>
<li>动态规划可以加快到O((n<sup>2</sup>) * (2<sup>n</sup>))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Compiler theory:</h3>

<ul>
<li>There will be a question or two based on the compiler theory session (slides are online).

<ul>
<li>编译过程：

<ul>
<li>首先是lexical analyzer词法分析</li>
<li>其次是syntax analyzer语法分析器

<ul>
<li>至上而下分析</li>
<li>至下而上分析</li>
<li>用于解析字串，并且看看是否满足语法

<ul>
<li>语法：

<ul>
<li>上下文无关文法

<ul>
<li>pda能够识别任何上下文无关文法生成的语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其次是semantic analyzer语义分析</li>
<li>其次是intermediate code generator中间代码生成</li>
<li>其次是code optimizer代码优化</li>
<li>最后是code generator代码生成</li>
</ul>
</li>
<li>lexical analyzer</li>
<li>FSA:finite state machine</li>
<li>LL 的意思是scan left to right, substitute leftmost</li>
<li>LR 的意思是scan left to right, substitute rightmost</li>
<li>LL(k) 向前看前k个symbol，看是否能够决定每一句语法</li>
<li>二义性：能够构造两颗语法树</li>
</ul>
</li>
</ul>


<h3>Divide and Conquer:</h3>

<ul>
<li>Be able to describe the divide-and-conquer design technique and give at least one example of an algorithm that uses this technique.

<ul>
<li>分而治之思想

<ul>
<li>把一个大问题分成几个小问题</li>
<li>分别解决这些小问题</li>
<li>把小问题的解答组合起来，得到原来问题的答案</li>
</ul>
</li>
<li>例子；

<ul>
<li>归并排序

<ul>
<li>sort数组

<ul>
<li>如果子集为1，那么算法终止</li>
<li>否则，把集合分割成两个子集，对每个子集排序

<ul>
<li>然后把排序好的子集归并为一个集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>并行算法</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Dynamic Programming:</h3>

<ul>
<li>Be able to describe the characteristics of problems suitable for this design approach and give at least one example of an algorithm that uses this technique.

<ul>
<li>动态规划是子问题最优化问题</li>
<li>例子有最长公共子串，最长公共子序列，背包，TSP

<ul>
<li>最长公共子串

<ul>
<li>假设两个字符串s和t，s[i]和t[j]表示第i个和第j个字符</li>
<li>L[i][j]表示以s[i]和t[j]结尾的相同子串的最长长度

<ul>
<li>那么L[i][j]和L[i+1][j+1]的关系是

<ul>
<li>L[i+1][j+1] = s[i]==t[j]?L[i][j]+1:0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to solve a problem using dynamic programming given some hints.</li>
</ul>


<h3>Greedy Algorithms:</h3>

<ul>
<li>Be able to describe the greedy algorithm design technique and give at least one example of an algorithm that uses this technique.

<ul>
<li>最优子结构问题</li>
<li>每次都找最优解</li>
</ul>
</li>
<li>Be able to trace Dijkstra&rsquo;s shortest path problem on a given graph.

<ul>
<li> 首先从空的集合开始，选择离集合最近的点，把那个点加入集合</li>
<li> 然后再更新列表中离这个集合相邻的点的距离

<ul>
<li>然后以这个新的点开始，找他的邻居

<ul>
<li>然后对比到这个邻居的最短的路

<ul>
<li>在原有的最短路上加上这个新的点的距离

<ul>
<li>如果比前一步加上另外一条路径的距离还长，就更新最短路

<ul>
<li>否则就把当前的这个值更新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>循环直到到达终点</li>
</ul>
</li>
</ul>
</li>
<li>Be able to generate Huffman codes for a given frequency analysis

<ul>
<li><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
<li>解法是首先排序

<ul>
<li><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>C</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>然后递归的对数组中<strong>最小的两个元素</strong>进行合并</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>         （22）
</span><span class='line'>         /    \
</span><span class='line'>      （9）     (13)
</span><span class='line'>      /  \      /   \
</span><span class='line'>    G(4) (5)   (7)   (6)
</span><span class='line'>         / \    | \     |\
</span><span class='line'>       A(2)B(3) E(3)C(4)F(3)D(3) </span></code></pre></td></tr></table></div></figure>


<h3>Amortized Analysis:</h3>

<ul>
<li>Be able to describe the goal of an amortized analysis for a given algorithm.

<ul>
<li>平摊分析

<ul>
<li>执行一系列数据结构所需要的时间是通过执行的所有操作求平均得到的。</li>
<li>平摊分析可以用来证明在一系列操作中，通过对所有操作求平均之后，即使对其中单一的操作具有较大的代价，平均代价还是很小的</li>
</ul>
</li>
<li>aggregate method

<ul>
<li>证明对所有的n，由n各操作所构成的序列的总时间再最坏情况下T(n)</li>
<li>所有操作都是同样的cost</li>
</ul>
</li>
<li>accounting method

<ul>
<li>对不同的操作赋予不同的cost，某些操作的费用比他们的实际代价或多或少</li>
<li>平摊代价：一个操作的收费数量

<ul>
<li>如果一个操作的平摊代价超过他的实际代价的时候，差值就是credit

<ul>
<li>这个credit用来补偿那些平摊代价地域实际代价的操作</li>
</ul>
</li>
</ul>
</li>
<li>总的平摊代价是总的实际代价的上界</li>
</ul>
</li>
<li>potential method

<ul>
<li>平摊代价=实际代价+势能</li>
<li>平摊代价依赖于势函数，不同的势函数会产生不同的平摊代价，但是都是实际代价的上限</li>
<li>e.g

<ul>
<li>动态表

<ul>
<li>当向满的表插入一个元素，把表扩大一倍</li>
<li>当删除意向引起表不足1/4满时，把表缩小为原来的一半</li>
</ul>
</li>
<li>由平摊分析可知两项操作的平摊代价都是O(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Be able to carry out an amortized analysis (using the aggregate method, the accounting method, or the potential method, as specified) for a given algorithm given some hints.</li>
</ul>


<h3>Approximation Algorithms:</h3>

<ul>
<li>近似算法的结果不一定是最优的（不是说结果不准确）</li>
<li>对于一些已经被证明是NP-complete问题的优化问题，无法在多项式时间内得到最优解</li>
<li>Be able to give the characteristics of a good approximation algorithm

<ul>
<li>假设最优值为K，求解一个问题的近似算法求得的近似最优解相应的目标函数值为C

<ul>
<li>所以近似性能比x={K/C,C/K}</li>
<li>假设通常情况下，性能比x是问题输入规模n的一个函数P(n)，也就是x&lt;=P(n)</li>
<li>相对误差定义为s=abs((K-C) / K)

<ul>
<li>如果对问题有输入规模n，有一函数V(n)>=s,那么V(n)为该近似算法的相对误差界。</li>
</ul>
</li>
<li>那么有P(n)-1>=V(n)</li>
</ul>
</li>
</ul>
</li>
<li>Be able to define what it means for an approximation algorithm to give an answer &ldquo;close&rdquo; to the optimum result.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015_citadel_onsite_interview]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/29/2015-citadel-onsite-interview/"/>
    <updated>2015-04-29T23:55:50-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/29/2015-citadel-onsite-interview</id>
    <content type="html"><![CDATA[<h3>citadel onsite面试</h3>

<ul>
<li>结果是rejected

<h4>面试流程</h4></li>
<li>第一轮 hr发邮件通知说有一个技术面

<ul>
<li>然后就会有一个技术人员打电话给你，然后面试一些技术方面的内容</li>
<li>例如：

<ul>
<li>如何找出两个只有一个field的数据库表的区别</li>
<li>问了快排和归并的区别</li>
<li>还有问mutex在什么时候用</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>第二轮

<ul>
<li>hr会跟你说邀请你去芝加哥总部面试</li>
<li>路费报销，免费一晚上宾馆</li>
<li>的士费也是</li>
<li>一共六轮面试

<ul>
<li>全部都是技术面试</li>
<li>第一轮：linux admin

<ul>
<li>sed

<ul>
<li>sum the 1th column and 3 column of a file</li>
</ul>
</li>
<li>python</li>
<li>acm

<ul>
<li>how many time will the two clock pointer overlap

<ul>
<li>from 12, each hour the overlap will move on 1/5 part of one hour</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二轮：

<ul>
<li>write some python program to deal with string</li>
</ul>
</li>
<li>第三轮:

<ul>
<li>program manger

<ul>
<li>ask about the future of you</li>
<li>what is the favorite project</li>
<li>whether you will use our company as a jump stone and create your own company</li>
</ul>
</li>
</ul>
</li>
<li>第四轮 network (difficult)

<ul>
<li>ask something about the latency of the network</li>
<li>and ask about the thread</li>
<li>ask about the mutex and how to lock</li>
</ul>
</li>
<li>第五轮第六轮</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[resize disk in OSX10.10]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/29/resize-disk-in-osx10-dot-10/"/>
    <updated>2015-04-29T12:31:35-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/29/resize-disk-in-osx10-dot-10</id>
    <content type="html"><![CDATA[<h3>Resize disk in OS X 10.10 Yosemite</h3>

<ul>
<li>due to the update of OSX, we can not resize the disk after we split the disk in the first time.</li>
<li>so we need to use some other command</li>
</ul>


<!--more-->


<h4>diskutil</h4>

<ul>
<li>first we can use <code>diskutil corestorage</code> to see what option we have</li>
<li>then we will choose <code>diskutil corestorage resizeDisk</code> or something else to resize the disk</li>
<li>some option that is not shown in the menu</li>
<li>Physical Volume (Disk) Commands

<ul>
<li>resizeDisk (undocumented) – Resize a physical volume</li>
<li>removeDisk (undocumented) – Remove a physical volume from a logical volume group</li>
<li>addDisk (undocumented) &ndash; Add a new physical volume to a logical volume group</li>
</ul>
</li>
<li><p>Logical Volume Commands</p>

<ul>
<li>deleteVolume (undocumented) – Delete a logical volume and all of its contents</li>
<li>resizeVolume (undocumented) – Grow or shrink a logical volume</li>
<li>resizeStack (undocumented) – Grow or shrink a logical volume as well as the volume group and physical volume.</li>
</ul>
</li>
<li><p>for example</p>

<ul>
<li>Example: diskutil coreStorage resizeVolume 11111111-2222-3333-4444-555555555555 10g</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ reference and pointer]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer/"/>
    <updated>2015-04-22T12:15:07-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-reference-and-pointer</id>
    <content type="html"><![CDATA[<h3>what is pointer</h3>

<ul>
<li>形参

<ul>
<li>formal parameter</li>
<li>定义时函数里面的变量

<ul>
<li>e.g int swao(int a, int b)</li>
<li>a和b就是形参</li>
</ul>
</li>
</ul>
</li>
<li>实参

<ul>
<li>actual parameter</li>
<li>在主函数里面引用的

<ul>
<li>e.g swap(x,y)</li>
<li>x和y就是实参，实际的值</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>指针</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part1(){
</span><span class='line'>  //basic
</span><span class='line'>  //p指向变量，对p的重新复制就会改变p所指向的变量的值。
</span><span class='line'>  //同样对p指向的变量重新复制也会改变*p的值
</span><span class='line'>  int ptmp = 50;
</span><span class='line'>  int *p;
</span><span class='line'>  p = &ptmp;
</span><span class='line'>  cout&lt;&lt;p&lt;&lt;endl;
</span><span class='line'>  //p存放的是ptmp变量所在的地址值 
</span><span class='line'>  cout&lt;&lt;*p&lt;&lt;endl;
</span><span class='line'>  //50，是指储存在指针的内存地址中的值，也就是ptmp的值
</span><span class='line'>  cout&lt;&lt;&p&lt;&lt;endl; 
</span><span class='line'>  //p指针本身的地址值
</span><span class='line'>  cout&lt;&lt;&ptmp; 
</span><span class='line'>  //ptmp变量所在的地址值
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>指针控制循环</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part2(){
</span><span class='line'>  //用指针来控制循环条件
</span><span class='line'>  //针对数组
</span><span class='line'>  int array[20];
</span><span class='line'>  int *p = array;
</span><span class='line'>  int i;
</span><span class='line'>  for(int j = 0; j &lt; 20; j++)
</span><span class='line'>      array[j] = j;
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  for(i = 0; i &lt; 20; i++){
</span><span class='line'>      cout&lt;&lt;p&lt;&lt;" "&lt;&lt;(*p)&lt;&lt;" ";
</span><span class='line'>      p++; //指针加一
</span><span class='line'>      (*p)++; //指针指向内容加一
</span><span class='line'>      //如果要用指针遍历数组
</span><span class='line'>      //用*(p+i)
</span><span class='line'>      //应为int 的p++ = p + 2
</span><span class='line'>      //int 占2byte
</span><span class='line'>  }
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  //针对字符串
</span><span class='line'>  char *str = "abc";
</span><span class='line'>  while(*p){
</span><span class='line'>      cout&lt;&lt;*p&lt;&lt;" ";
</span><span class='line'>      p++;
</span><span class='line'>      //可以这么做的原因是char占 1 byte
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>引用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void part3(){
</span><span class='line'>  //引用
</span><span class='line'>  int a = 20;
</span><span class='line'>  int b = 10;
</span><span class='line'>  int &p = a;
</span><span class='line'>  //p引用a,所以p是a的另外一个名字
</span><span class='line'>  cout&lt;&lt;p&lt;&lt;endl;
</span><span class='line'>  //p的值改变了
</span><span class='line'>  p = b;
</span><span class='line'>  //a的值也会改变
</span><span class='line'>  cout&lt;&lt;a&lt;&lt;endl;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>传参</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap1(int x, int y){
</span><span class='line'>  cout&lt;&lt;"in function before swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
</span><span class='line'>  int temp = x;
</span><span class='line'>  x = y;
</span><span class='line'>  y = temp;
</span><span class='line'>  cout&lt;&lt;"in fuction after swap"&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;
</span><span class='line'>}
</span><span class='line'>void swap2(int *a, int *b){
</span><span class='line'>  //temp用来存a得值
</span><span class='line'>  //所以其实这里是在交换值
</span><span class='line'>  int temp = *a;
</span><span class='line'>  *a = *b;
</span><span class='line'>  *b = temp;
</span><span class='line'>}
</span><span class='line'>void swap3(int &a, int &b){
</span><span class='line'>  //因为这里是传引用，所以任何的改变都会改变
</span><span class='line'>  int temp = a;
</span><span class='line'>  a = b;
</span><span class='line'>  b = temp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>注意事项</h4>

<ul>
<li>在可以使用引用的情况下，不要用指针</li>
<li>引用不能为空，当对象为NULL时，必须使用指针</li>
<li>引用不允许重新赋值，当使用一个变量指向不同的对象的时候，必须使用指针</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part3]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3/"/>
    <updated>2015-04-22T01:27:20-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part3</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h3>图论</h3>

<h4>图的实现</h4>

<ul>
<li>V为点的个数 E边的个数</li>
<li>邻接矩阵

<ul>
<li>用一个n*n的矩阵

<ul>
<li>第一列第二个为1的意思是

<ul>
<li>第一个点和第二个点相连</li>
<li>1为权值</li>
</ul>
</li>
</ul>
</li>
<li>O(V<sup>2</sup>)</li>
<li>用一个二维数组实现</li>
</ul>
</li>
<li>邻接表

<ul>
<li>用一个n长度的数组

<ul>
<li>然后每一个数组后面接的链表里面存着

<ul>
<li>这个数组index对应的点和哪些点相连

<ul>
<li>这些点存在链表里面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>O(V+E)</li>
<li>stl实现</li>
<li>用vector<Node> list

<ul>
<li>然后Node就是每个点

<ul>
<li>如果有别的点和这个Node相连，就list.push_back(别的点)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>图搜索</h4>

<h5>广度优先搜索</h5>

<ul>
<li>使用的数据结构是queue</li>
<li>相当于先把第一层的所有点入队

<ul>
<li>然后把每个点的相邻的节点入队

<ul>
<li>e.g

<ul>
<li>假设第一层的节点为A, 第二层为B，第三层为C

<ul>
<li>那么队列中的情况就是

<ul>
<li>A,B,C,A1,A2,A3,B1,C2</li>
<li>这样访问下来，就相当于一层一层的遍历了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>伪代码</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function bfs(vertex v){
</span><span class='line'>  create a queue Q
</span><span class='line'>  enqueue v into Q
</span><span class='line'>  mark v as visited
</span><span class='line'>  while Q is not empty{
</span><span class='line'>      use temp to store Q.top
</span><span class='line'>      dequeue the top vertex from Q
</span><span class='line'>      for each adjacent w in temp{
</span><span class='line'>          mark w as visited
</span><span class='line'>          enqueue w into Q
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>深度优先搜索</h5>

<ul>
<li>使用的数据结构是stack</li>
<li>伪代码</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function dfs(vertex v){
</span><span class='line'>  mark v as visited //把点标记为已经访问过了
</span><span class='line'>  for each node adjacent to v //对这个点的所有邻接点进行搜索
</span><span class='line'>      if node is unvisited  //如果从左到右，找到这个点没有被访问过
</span><span class='line'>          dfs(node) //递归调用
</span><span class='line'>      //如果这个点访问过了
</span><span class='line'>          //那么向右移，继续搜索
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>二叉树的BFS和DFS</h5>

<ul>
<li>首先递归建树

<ul>
<li>再用bfs和dfs</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define Element char
</span><span class='line'>typedef struct Node{
</span><span class='line'>  Element data;
</span><span class='line'>  struct Node *left;
</span><span class='line'>  struct Node *right;
</span><span class='line'>}*Tree;
</span><span class='line'>int i = 0;
</span><span class='line'>//按照先序遍历建树
</span><span class='line'>void construct_tree(Tree &root, Element data[]){
</span><span class='line'>  Element e = data[i++];
</span><span class='line'>  if(e == '#')
</span><span class='line'>      root = NULL;
</span><span class='line'>  else{
</span><span class='line'>      root = new Node();
</span><span class='line'>      root -&gt; data = e;
</span><span class='line'>      construct_tree(root -&gt; left, data); //递归建立左子树
</span><span class='line'>      construct_tree(root -&gt; right, data); //递归建立右子树
</span><span class='line'>  }   
</span><span class='line'>}
</span><span class='line'>void bfs(Tree root){  
</span><span class='line'>  queue&lt;Node *&gt; q;
</span><span class='line'>  q.push(root);
</span><span class='line'>  while(!q.empty()){
</span><span class='line'>      Node *temp = q.front();
</span><span class='line'>      q.pop();
</span><span class='line'>      cout&lt;&lt;temp -&gt; data;
</span><span class='line'>      if(temp -&gt; left)
</span><span class='line'>          q.push(temp -&gt; left);
</span><span class='line'>      if(temp -&gt; right)
</span><span class='line'>          q.push(temp -&gt; right);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>void dfs(Tree root){
</span><span class='line'>  stack&lt;Node *&gt; s;
</span><span class='line'>  s.push(root);
</span><span class='line'>  while(!s.empty()){
</span><span class='line'>      Node *temp = s.top();
</span><span class='line'>      s.pop();
</span><span class='line'>      cout&lt;&lt;temp -&gt; data;
</span><span class='line'>      //因为stack是先进后出，所以先把right压进去
</span><span class='line'>      if(temp -&gt; right)
</span><span class='line'>          s.push(temp -&gt; right);
</span><span class='line'>      if(temp -&gt; left)
</span><span class='line'>          s.push(temp -&gt; left);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  //#表示没有左子树或者右子树
</span><span class='line'>  //             A
</span><span class='line'>  //           /   \
</span><span class='line'>  //          B     C
</span><span class='line'>  //        /  \   /  \
</span><span class='line'>  //      D    E   F   G
</span><span class='line'>  Element data[15] = {'A','B','D','#','#','E','#','#','C','F','#','#','G','#','#'};
</span><span class='line'>  Tree tree;
</span><span class='line'>  construct_tree(tree, data);
</span><span class='line'>  //bfs
</span><span class='line'>  cout&lt;&lt;"result of bfs: ";
</span><span class='line'>  bfs(tree);
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  //dfs
</span><span class='line'>  cout&lt;&lt;"result of dfs: ";
</span><span class='line'>  dfs(tree);
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>拓扑排序</h5>

<ul>
<li>方法

<ul>
<li>用在有向图里面</li>
<li>选择一个入度为0的点，输出

<ul>
<li>然后删除这个点和所有和他相连的出去的边</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>最短路径</h4>

<ul>
<li>单源最短路</li>
<li>Dijkstra算法

<ul>
<li>首先把起点加入集合</li>
<li>每次查询的时候

<ul>
<li>把和这个集合最近的那个点加入集合</li>
<li>然后递归</li>
</ul>
</li>
</ul>
</li>
<li>floyd算法

<ul>
<li>原理是动态规划</li>
<li>首先得出图的邻接矩阵

<ul>
<li>然后如果i==j那么为0，因为自己到自己的距离为0</li>
<li>如果两个点不邻接，那么为INF(很大的数字)</li>
</ul>
</li>
<li>其次，如果有N个点，那么就要对矩阵进行n次更新

<ul>
<li>依次把距离当前集合距离最小的点加入集合</li>
<li>并且更新矩阵数据</li>
<li>如果a[i][j] > a[i][k] + a[k][j]

<ul>
<li>则a[i][j] = a[i][k] + a[k][j]</li>
</ul>
</li>
</ul>
</li>
<li>最后得出的矩阵就是包含所有点到所有点的最短距离</li>
</ul>
</li>
</ul>


<h4>最小生成树(todo)</h4>

<ul>
<li>Prim</li>
<li>Kruskal</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure part2]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2/"/>
    <updated>2015-04-22T01:22:30-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/22/c-plus-plus-basic-data-structure-part2</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm part2</h3>

<h4>树</h4>

<ul>
<li>trie树

<ul>
<li>特点

<ul>
<li>根节点没有字符，除此之外，所有节点都只有一个字符</li>
<li>从根节点到任意叶子节点，都是一个独立的单词</li>
<li>每个节点的子节点包含的后续字符串都是不一样的</li>
</ul>
</li>
<li>但是hash表不能一边建立索引一边查数据

<ul>
<li>trie树可以

<ul>
<li>因为只要之前建立过的，再次出现的时候，就不会再增加</li>
</ul>
</li>
<li>而hash表建立的时候，不知道之前这个单词出现过，所以还是要建完表

<ul>
<li>再搜索</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>内排序</h4>

<ul>
<li><p>O(n<sup>2</sup>)</p>

<ul>
<li>主要是交换那个动作耗时</li>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
</ul>
</li>
<li><p>快速排序</p>

<ul>
<li>时间复杂度：nlogn</li>
<li>最坏：n<sup>2</sup>

<ul>
<li>把区域划分成n-1和1</li>
</ul>
</li>
<li>空间复杂度：nlogn</li>
<li>所以其实要解释快排是什么

<ul>
<li>就是选一个中间值

<ul>
<li>把比这个中间值小的放到左边</li>
<li>把比这个中间值大的放到右边</li>
<li>然后分别对这两个子数组递归调用快速排序</li>
<li>最后的出来的就是排序好的</li>
</ul>
</li>
</ul>
</li>
<li>思想：

<ul>
<li>对于A[p&hellip;.r]</li>
<li>基于分而治之</li>
<li>首先

<ul>
<li>A[p&hellip;.r]被分解成两个子数组

<ul>
<li>一个是A[p&hellip;.q-1]，一个是A[q+1&hellip;..r]</li>
<li>然后递归调用对A[p&hellip;q-1]和A[q+1&hellip;..r]排序</li>
</ul>
</li>
<li>最后合并子数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void quicksort(int *a, int low, int upp){
</span><span class='line'>  //low和upp为数组的上界和下界
</span><span class='line'>  int i = low;
</span><span class='line'>  int j = upp;
</span><span class='line'>  int mid = (low + upp)/2;
</span><span class='line'>  //设置pivot用作对比
</span><span class='line'>  int pivot = a[mid];
</span><span class='line'>  int temp;
</span><span class='line'>  //partition
</span><span class='line'>  do{
</span><span class='line'>      while(a[i] &lt; pivot)
</span><span class='line'>          i++;
</span><span class='line'>      while(a[j] &gt; pivot)
</span><span class='line'>          j--;
</span><span class='line'>      if(i &lt;= j){
</span><span class='line'>          swap(a[i], a[j]);
</span><span class='line'>          i++;
</span><span class='line'>          j--;
</span><span class='line'>      }
</span><span class='line'>  }while(i &lt; j);
</span><span class='line'>  //递归调用解决子问题
</span><span class='line'>  if(low &lt; j)
</span><span class='line'>      quicksort(a, low, j);
</span><span class='line'>  if(i &lt; upp)
</span><span class='line'>      quicksort(a, i, upp);
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  int a[10] = {1,5,4,3,6,5,3,4,5,3};
</span><span class='line'>  for(int i = 0; i &lt; 10; i++){
</span><span class='line'>      cout&lt;&lt;a[i]&lt;&lt;" ";
</span><span class='line'>  }
</span><span class='line'>  cout&lt;&lt;endl;
</span><span class='line'>  quicksort(a, 0, 9);
</span><span class='line'>  for(int i = 0; i &lt; 10; i++){
</span><span class='line'>      cout&lt;&lt;a[i]&lt;&lt;" ";
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>归并排序</li>
<li>基本思想：

<ul>
<li>分而治之</li>
<li>先通过递归分解数组，然后再合并数组完成归并排序</li>
</ul>
</li>
<li>如何合并两个有序数组

<ul>
<li>比较两个数列的第一个数，把小的那个加入到结果数组中，然后从原来的数组删掉</li>
<li>然后一直循环比较到全部数据都取出来为止
&#8220;`</li>
</ul>
</li>
</ul>


<p>&#8220;`</p>

<h4>归并和快排的区别</h4>

<ul>
<li>快排分解之后不需要合并就能得到最终答案</li>
<li>归并分解之后还要对比两个子数组然后合并的到答案</li>
</ul>


<h3>外排序</h3>

<h4>哈希表</h4>

<ul>
<li>建立hash表

<ul>
<li>用hash函数把key转换成一个整型数字，这个整型数字对数组长度求模之后就是数组的下标

<ul>
<li>那么value就存在这个下表的数组空间里面</li>
</ul>
</li>
</ul>
</li>
<li><p>查询hash表</p>

<ul>
<li>把要查询的key用hash函数转换成数组下标，再去数组里面提取</li>
<li>O(N)非常快</li>
</ul>
</li>
<li><p>假设有1000万个记录，有重复，去除重复之后大约300万</p>

<ul>
<li>求top 10出现率的记录</li>
<li>解答：

<ul>
<li>用hash表

<ul>
<li>维护一个&lt;记录，出现次数>的hash表

<ul>
<li>这样就有一个300万条左右记录的hash表</li>
<li>再找前十就行了</li>
</ul>
</li>
</ul>
</li>
<li>找前10可以用部分排序

<ul>
<li>也就是用一个10个大小的数组

<ul>
<li>然后搜hash表，每次都和数组最后的那个比

<ul>
<li>如果比他大，就交换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>把key变成下表的方法</p>

<ul>
<li>1.对key求模

<ul>
<li>index = value % 16</li>
</ul>
</li>
<li>2.平方散列

<ul>
<li>index = (value * value) >> 28

<ul>
<li>右移28bit是指除以2<sup>28</sup></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果两个value在hash表中对应同一个index怎么办？

<ul>
<li>可以用链表解决

<ul>
<li>这样就不会有冲突产生</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>索引</h4>

<ul>
<li><p>线性索引</p>

<ul>
<li>索引文件是一个线性的列表</li>
<li>并且列表中的每个元素都对应者数据库中的一个元素

<ul>
<li>或者数据库的某个位置</li>
</ul>
</li>
<li>但是有时候索引文件太大，装不进内存

<ul>
<li>那么解决方案就是用二级索引

<ul>
<li>这个二级索引是索引文件的索引</li>
</ul>
</li>
</ul>
</li>
<li>但是每个数据库更新的时候

<ul>
<li>所有的索引文件都要更新，但是线性索引的代价很大</li>
</ul>
</li>
</ul>
</li>
<li><p>ISAM</p></li>
<li>树状索引

<ul>
<li>B树

<ul>
<li>balance tree</li>
<li>b树的搜索

<ul>
<li>对根节点进行二分查找</li>
</ul>
</li>
</ul>
</li>
<li>B+树

<ul>
<li>B树的变种</li>
<li>叶子节点存数据</li>
<li>非叶子节点存索引</li>
<li>好处

<ul>
<li>因为B+树内部只是存索引，不像B树是存数据的

<ul>
<li>因此B+树I/O读写次数降低了</li>
</ul>
</li>
<li>查找效率稳定

<ul>
<li>因为所有非叶子节点都是索引</li>
<li>因此数据都在叶子节点上，因此关键字查询的路径相同</li>
<li>因此每一个数据的查找效率相当</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[string processing function implementation]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation/"/>
    <updated>2015-04-21T01:56:01-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/21/string-processing-function-implementation</id>
    <content type="html"><![CDATA[<h3>string function in c</h3>

<h4>strcpy</h4>

<ul>
<li>使用一个临时变量保存串的首地址，然后最后返回这个地址</li>
<li>然后在最后判断是否遇到&#8217;\0&#8217;来结束复制</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char *strcpy1(char *des, const char*src){
</span><span class='line'>  char *address = des;
</span><span class='line'>  while((*des++ = *src++) != '\0');
</span><span class='line'>  return address;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *des;
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  char *result;
</span><span class='line'>  result = strcpy1(des, src);
</span><span class='line'>  cout&lt;&lt;result;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<hr />

<h4>strlen</h4>

<ul>
<li>一直累加直到判断是否遇到&#8217;\0&#8217;来结束计数</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int strlen1(const char*src){
</span><span class='line'>  int count = 0;
</span><span class='line'>  while((*src++) != '\0')
</span><span class='line'>      count++;
</span><span class='line'>  return count;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  int result;
</span><span class='line'>  result = strlen1(src);
</span><span class='line'>  cout&lt;&lt;result;
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>strcat</h4>

<ul>
<li>把指针移到最后，然后把b字符串的内容复制到a字符串最后</li>
<li>但是要注意a字符串要有足够的空间来支持b字符串内容的大小</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char *strcat1(char *des, const char*src){
</span><span class='line'>  char *address = des;
</span><span class='line'>  while(*address)
</span><span class='line'>      address++;
</span><span class='line'>
</span><span class='line'>  while((*address++ = *src++) !='\0');
</span><span class='line'>  return des;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char des[10] = "";
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  char *result;
</span><span class='line'>  result = strcat1(des, src);
</span><span class='line'>  printf("%s", result);
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>strcmp</h4>

<ul>
<li>如果字符串一样，那么返回0</li>
<li>如果a>b那么返回正数，否则返回负数</li>
<li>比较方法是用asc码来比较，然后最后返回相减的结果

<ul>
<li>从左到右比较，知道出现不一样的字符或者出现&#8217;\0&#8217;为止</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int strcmp1(const char *s1, const char*s2){
</span><span class='line'>  while(*s1 == *s2){
</span><span class='line'>      if(*s1 == '\0'){
</span><span class='line'>          return 0;
</span><span class='line'>      }
</span><span class='line'>      ++s1;
</span><span class='line'>      ++s2;
</span><span class='line'>  }
</span><span class='line'>  return *s1 - *s2;
</span><span class='line'>}
</span><span class='line'>int main(){
</span><span class='line'>  char *des = "aaa";
</span><span class='line'>  char *src = "aaa";
</span><span class='line'>  int result;
</span><span class='line'>  result = strcmp1(des, src);
</span><span class='line'>  if(result == 0)
</span><span class='line'>      cout&lt;&lt;"the string are the same";
</span><span class='line'>  else
</span><span class='line'>      cout&lt;&lt;"the string are not the same";
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ basic data structure]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure/"/>
    <updated>2015-04-20T22:04:11-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-basic-data-structure</id>
    <content type="html"><![CDATA[<h3>basic data structure and algorithm</h3>

<h4>little review about c++ object oriented</h4>

<ul>
<li>虚函数

<ul>
<li>核心理念就是基类访问派生类定义的函数</li>
<li>动态联编</li>
<li>一个函数的调用不是在编译的时候确定的，而是在运行的时候确定的，并且因为写代码的时候不能确定被调用的函数是基类的函数还是派生类的函数，所以这个函数又叫做“虚函数“</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A{
</span><span class='line'>    public:
</span><span class='line'>        virtual void test(){
</span><span class='line'>            cout&lt;&lt;"A:test() is called";
</span><span class='line'>        }        
</span><span class='line'>};
</span><span class='line'>class B: public A{
</span><span class='line'>    public:
</span><span class='line'>        virtual void test(){
</span><span class='line'>            cout&lt;&lt;"B:test() is called";
</span><span class='line'>        }
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>    A *a = new B();
</span><span class='line'>    a -&gt; test();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!--more-->


<ul>
<li><p>虚函数表</p>

<ul>
<li>实现多态的主要功能</li>
<li><strong>编译器</strong>会为每一个有虚函数的类的实例创建一个虚函数表</li>
<li>用来存虚函数的table

<ul>
<li>table的每个slot（槽）里面存放虚函数的地址</li>
</ul>
</li>
<li>但是我们可以用函数指针来看虚函数表的地址

<ul>
<li>并且虚函数表在继承中，如果派生类没有重写基类的某个函数，他就会在基类中查那个函数，然后引用的时候就会引用基类的</li>
<li>并且如果子类如果增加了函数，就会在基类的虚函数表中增加</li>
</ul>
</li>
</ul>
</li>
<li><p>纯虚函数</p>

<ul>
<li><code>virtual void test() = 0</code></li>
<li>意思是抽象类，也可以说是接口，用来规范派生类的行为

<ul>
<li>告诉使用者我的派生类都会有这个函数</li>
</ul>
</li>
<li>虚构析函数

<ul>
<li>当一个类要被其他的类当基类使用的时候，必须是纯虚的</li>
<li>如果有两个class A和B

<ul>
<li>B继承A，但是A的构析函数没有设置成虚函数</li>
<li>那么在delete B的实例的时候，只有A的实例被delete， B的不会被delete。。。那这不是坑爹吗。。。。</li>
<li>但是再A的构析函数前面加上virtual，这样就能保证在delete B的实例的时候，两个类的构析函数都会被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>但是构造函数不能使虚函数</p></li>
</ul>


<hr />

<h4>链表</h4>

<ul>
<li>链表ADT</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class List{
</span><span class='line'>  private:
</span><span class='line'>      void operator = (const List &){}
</span><span class='line'>      List(const List&){}
</span><span class='line'>  public:
</span><span class='line'>      List(){}
</span><span class='line'>      virtual ~List(){}
</span><span class='line'>      virtual void clear() = 0;
</span><span class='line'>      virtual void insert(const E& item) = 0;
</span><span class='line'>      virtual void append(const E& item) = 0;
</span><span class='line'>      virtual E remove() = 0;
</span><span class='line'>      //move the pointer to start
</span><span class='line'>      virtual void moveToStart() = 0;
</span><span class='line'>      //move the pointer to end
</span><span class='line'>      virtual void moveToEnd() = 0;
</span><span class='line'>      virtual void prev() = 0;
</span><span class='line'>      virtual void next() = 0;
</span><span class='line'>      virtual int length() const = 0;
</span><span class='line'>      virtual int currPos() const = 0;
</span><span class='line'>      virtual void moveToPos(int pos) = 0;
</span><span class='line'>      virtual const E& getValue() const = 0;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class AList: public List&lt;E&gt;{
</span><span class='line'>private:
</span><span class='line'>  int maxSize;
</span><span class='line'>  int listSize;
</span><span class='line'>  int curr;
</span><span class='line'>  E* listArray;   
</span><span class='line'>public:
</span><span class='line'>    //初始化列表
</span><span class='line'>  AList(int size = 100){
</span><span class='line'>      maxSize = size;
</span><span class='line'>      listSize = 0;
</span><span class='line'>      curr = 0;
</span><span class='line'>      listArray = new E[maxSize];
</span><span class='line'>  }
</span><span class='line'>  //构析函数，删掉数组，释放空间
</span><span class='line'>  ~AList(){
</span><span class='line'>      delete []listArray;
</span><span class='line'>  }
</span><span class='line'>  void clear(){
</span><span class='line'>      delete []listArray;
</span><span class='line'>      listSize = 0;
</span><span class='line'>      curr = 0;
</span><span class='line'>      listArray = new E[maxSize];
</span><span class='line'>  }
</span><span class='line'>  //把当前位置之后的数组向后移动一位，再插入
</span><span class='line'>  void insert(const E& it){
</span><span class='line'>      for(int i = listSize; i &gt; curr; i--)
</span><span class='line'>          listArray[i] = listArray[i-1];
</span><span class='line'>      //move back the array from the current position
</span><span class='line'>      listArray[curr] = it;
</span><span class='line'>      listSize++;
</span><span class='line'>  }
</span><span class='line'>  //直接在最后增加item
</span><span class='line'>  void append(const E& it){
</span><span class='line'>      listArray[listSize++] = it;
</span><span class='line'>  }
</span><span class='line'>  //记录当前的数组索引的指向的数据，把数组向前移动一位
</span><span class='line'>  E remove(){
</span><span class='line'>      E it = listArray[curr];
</span><span class='line'>      for(int i = curr; i &lt; listSize - 1; i++){
</span><span class='line'>          listArray[i] = listArray[i + 1];
</span><span class='line'>      }
</span><span class='line'>      listSize--;
</span><span class='line'>      return it;
</span><span class='line'>  }
</span><span class='line'>  void moveToStart(){
</span><span class='line'>      curr = 0;
</span><span class='line'>  }
</span><span class='line'>  void moveToEnd(){
</span><span class='line'>      curr = listSize;
</span><span class='line'>  }
</span><span class='line'>  void prev(){
</span><span class='line'>      if(curr &gt; 0)
</span><span class='line'>          curr--;
</span><span class='line'>  }
</span><span class='line'>  void next(){
</span><span class='line'>      if(curr &lt; listSize)
</span><span class='line'>          curr++;
</span><span class='line'>  }
</span><span class='line'>  int length(){
</span><span class='line'>      return listSize;
</span><span class='line'>  }
</span><span class='line'>  int currPos() const{
</span><span class='line'>      return curr;
</span><span class='line'>  }
</span><span class='line'>  void moveToPos(int pos){
</span><span class='line'>      pos = curr;
</span><span class='line'>  }
</span><span class='line'>  const E& getValue() const{
</span><span class='line'>      return listArray[curr];
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>链式实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>template &lt;typename E&gt; class Link{
</span><span class='line'>public:
</span><span class='line'>  E element;
</span><span class='line'>  Link *next;
</span><span class='line'>  Link(const E& elemval, Link *nextval = NULL){
</span><span class='line'>      element = elemval;
</span><span class='line'>      next = nextval;
</span><span class='line'>  }
</span><span class='line'>  Link(Link *nextval = NULL){
</span><span class='line'>      next = nextval;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>template &lt;typename E&gt; class LList: public List&lt;E&gt;{
</span><span class='line'>private:
</span><span class='line'>  Link&lt;E&gt; *head;
</span><span class='line'>  Link&lt;E&gt; *tail;
</span><span class='line'>  Link&lt;E&gt; *curr;
</span><span class='line'>  int count;
</span><span class='line'>  void init(){
</span><span class='line'>      curr = tail = head = new Link&lt;E&gt;;
</span><span class='line'>      count = 0;
</span><span class='line'>  }
</span><span class='line'>  void removeall(){
</span><span class='line'>      while(head != NULL){
</span><span class='line'>          curr = head;
</span><span class='line'>          head = head -&gt; next;
</span><span class='line'>          delete curr;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>public:
</span><span class='line'>  LList(int size=100){
</span><span class='line'>      init();
</span><span class='line'>  }
</span><span class='line'>  ~LList(){
</span><span class='line'>      removeall();
</span><span class='line'>  }
</span><span class='line'>  void clear(){
</span><span class='line'>      removeall();
</span><span class='line'>      init();
</span><span class='line'>  }
</span><span class='line'>  void insert(const E& it){
</span><span class='line'>      //给要增加的节点初始化
</span><span class='line'>      curr -&gt; next = new Link&lt;E&gt;(it, curr -&gt; next);
</span><span class='line'>      //如果要curr指针就是再末尾
</span><span class='line'>      //那么把curr的下一个赋给tail
</span><span class='line'>      if(tail == curr)
</span><span class='line'>          tail = curr -&gt; next;
</span><span class='line'>      count++;
</span><span class='line'>  }
</span><span class='line'>  void append(const E& it){
</span><span class='line'>      //直接把末尾指针的next指向新建的link
</span><span class='line'>      tail = tail -&gt; next = new Link&lt;E&gt;(it, NULL);
</span><span class='line'>      count++;
</span><span class='line'>  }
</span><span class='line'>  //注意，这里要删除的节点叫做curr-&gt;next
</span><span class='line'>  E remove(){
</span><span class='line'>      //先把要删除的node的值存起来
</span><span class='line'>      E it = curr -&gt; next -&gt; element;
</span><span class='line'>      //用temp存一下要删除的节点
</span><span class='line'>      Link&lt;E&gt; *temp = curr -&gt; next;
</span><span class='line'>      //如果这个要删除的点是末尾，那么把末尾前一个节点赋给tail
</span><span class='line'>      if(tail == curr -&gt; next)
</span><span class='line'>          tail = curr;
</span><span class='line'>      //否则，把要删除的节点的前一个节点的next指向要删除节点的下一个
</span><span class='line'>      curr -&gt; next = curr -&gt; next -&gt; next;
</span><span class='line'>      delete temp;
</span><span class='line'>      count--;
</span><span class='line'>      return it;
</span><span class='line'>  }
</span><span class='line'>  void moveToStart(){
</span><span class='line'>      curr = head;
</span><span class='line'>  }
</span><span class='line'>  void moveToEnd(){
</span><span class='line'>      curr = tail;
</span><span class='line'>  }
</span><span class='line'>  void prev(){
</span><span class='line'>      if(curr == head)
</span><span class='line'>          return ;
</span><span class='line'>      Link&lt;E&gt; *temp = head;
</span><span class='line'>      //向左移动一个单位
</span><span class='line'>      //做法是先用temp存一个head，然后向右找，直到找到curr的前一个，然后把curr的前一个赋给curr
</span><span class='line'>      while(temp -&gt; next != curr)
</span><span class='line'>          temp = temp -&gt; next;
</span><span class='line'>      curr = temp;
</span><span class='line'>  }
</span><span class='line'>  void next(){
</span><span class='line'>      //只要curr指针不是tail，那么就向后移动
</span><span class='line'>      if(curr != tail)
</span><span class='line'>          curr = curr -&gt; next;
</span><span class='line'>  }
</span><span class='line'>  int length(){
</span><span class='line'>      return count;
</span><span class='line'>  }
</span><span class='line'>  int currPos() const{
</span><span class='line'>      Link&lt;E&gt; *temp = head;
</span><span class='line'>      //用temp指针存head，然后依次向后遍历，并且每次后移count+1
</span><span class='line'>      int i;
</span><span class='line'>      for(i = 0; i &lt; count; i++){
</span><span class='line'>          temp = temp -&gt; next;
</span><span class='line'>      }
</span><span class='line'>      return i;
</span><span class='line'>  }
</span><span class='line'>  void moveToPos(int pos){
</span><span class='line'>      curr = head;
</span><span class='line'>      //先把current的指针指向head
</span><span class='line'>      //然后一直向后移动，直到pos次
</span><span class='line'>      for(int i = 0; i &lt; pos; i++){
</span><span class='line'>          curr = curr -&gt; next;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  const E& getValue() const{
</span><span class='line'>      return curr -&gt; next -&gt; element;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>栈</h4>

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Astack{
</span><span class='line'>  private:
</span><span class='line'>      int maxSize;
</span><span class='line'>      int top;
</span><span class='line'>      int *array;
</span><span class='line'>  public:
</span><span class='line'>      Astack(int size = 100){
</span><span class='line'>          maxSize = size;
</span><span class='line'>          top = 0;
</span><span class='line'>          array = new int[size];
</span><span class='line'>      }
</span><span class='line'>      ~Astack(){
</span><span class='line'>          delete []array;
</span><span class='line'>      }
</span><span class='line'>      void clear(){
</span><span class='line'>          top = 0;
</span><span class='line'>      }
</span><span class='line'>      void push(int item){
</span><span class='line'>          array[top++] = item;
</span><span class='line'>      }
</span><span class='line'>      int pop(){
</span><span class='line'>          int temp = array[top];
</span><span class='line'>          return array[--top];
</span><span class='line'>      }
</span><span class='line'>      int getTop(){
</span><span class='line'>          return array[top - 1];
</span><span class='line'>      }   
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>  Astack a;
</span><span class='line'>  a.push(1);
</span><span class='line'>  cout&lt;&lt;a.getTop();
</span><span class='line'>  a.pop();
</span><span class='line'>  cout&lt;&lt;a.getTop();
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>队列</h4>

<ul>
<li>数组实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Aqueue{
</span><span class='line'>  private:
</span><span class='line'>      int front;
</span><span class='line'>      int rear;
</span><span class='line'>      int maxSize;
</span><span class='line'>      int *array;
</span><span class='line'>  public:
</span><span class='line'>      Aqueue(int size = 100){
</span><span class='line'>          maxSize = size;
</span><span class='line'>          front = rear = 0;
</span><span class='line'>          array = new int[size];
</span><span class='line'>      }
</span><span class='line'>      ~Aqueue(){
</span><span class='line'>          delete [] array;
</span><span class='line'>      }
</span><span class='line'>      void enqueue(int item){
</span><span class='line'>          array[rear] = item;
</span><span class='line'>          rear = (rear + 1)%maxSize;
</span><span class='line'>      }
</span><span class='line'>      int dequeue(){
</span><span class='line'>          int temp = array[front];
</span><span class='line'>          front = (front + 1)%maxSize;
</span><span class='line'>          array[front] = 0;
</span><span class='line'>          return temp;
</span><span class='line'>      }
</span><span class='line'>      const int getFrontValue(){
</span><span class='line'>          return array[front];
</span><span class='line'>      }
</span><span class='line'>};
</span><span class='line'>int main(){
</span><span class='line'>  Aqueue q;
</span><span class='line'>  q.enqueue(1);
</span><span class='line'>  cout&lt;&lt;q.getFrontValue()&lt;&lt;endl;
</span><span class='line'>  q.dequeue();
</span><span class='line'>  cout&lt;&lt;q.getFrontValue();
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>二叉树</h4>

<ul>
<li>遍历</li>
<li>前序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void preorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        cout&lt;&lt;root-&gt;value;
</span><span class='line'>        preorder(root -&gt; left);
</span><span class='line'>        preorder(root -&gt; right);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>中序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void inorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        inorder(root -&gt; left);
</span><span class='line'>        cout&lt;&lt;root -&gt; value;
</span><span class='line'>        inorder(root -&gt; right);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>后序遍历</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    void postorder(Node *root){
</span><span class='line'>        if(root == NULL){
</span><span class='line'>            return ;
</span><span class='line'>        }
</span><span class='line'>        postorder(root -&gt; left);
</span><span class='line'>        postorder)root -&gt; right);
</span><span class='line'>        cout&lt;&lt;root -&gt; value;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ program run time]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time/"/>
    <updated>2015-04-20T20:52:22-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/20/c-plus-plus-program-run-time</id>
    <content type="html"><![CDATA[<h4>时间复杂度</h4>

<ul>
<li>costs for growth rate representative of most computer algorithm

<ul>
<li><table>
<thead>
<tr>
<th>n</th>
<th>loglogn</th>
<th>logn</th>
<th>n</th>
<th>nlogn</th>
<th>n<sup>2</sup></th>
<th>n<sup>3</sup></th>
<th>2<sup>n</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>2</td>
<td>4</td>
<td>2<sup>4</sup></td>
<td>2*2<sup>4</sup>=2<sup>5</sup></td>
<td>2<sup>8</sup></td>
<td>2<sup>12</sup></td>
<td>2<sup>16</sup></td>
</tr>
<tr>
<td>256</td>
<td>3</td>
<td>8</td>
<td>2<sup>8</sup></td>
<td>8*2<sup>8</sup>=2<sup>11</sup></td>
<td>2<sup>16</sup></td>
<td>2<sup>24</sup></td>
<td>2<sup>256</sup></td>
</tr>
<tr>
<td>1024</td>
<td>3.3</td>
<td>10</td>
<td>2<sup>10</sup></td>
<td>10*2<sup>10</sup>=2<sup>13</sup></td>
<td>2<sup>20</sup></td>
<td>2<sup>30</sup></td>
<td>2<sup>1024</sup></td>
</tr>
<tr>
<td>64K</td>
<td>4</td>
<td>16</td>
<td>2<sup>16</sup></td>
<td>16*2<sup>16</sup>=2<sup>20</sup></td>
<td>2<sup>32</sup></td>
<td>2<sup>48</sup></td>
<td>2<sup>64K</sup></td>
</tr>
<tr>
<td>1M</td>
<td>4.3</td>
<td>20</td>
<td>2<sup>20</sup></td>
<td>20*2<sup>20</sup>=2<sup>24</sup></td>
<td>2<sup>40</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>1M</sup></td>
</tr>
<tr>
<td>1G</td>
<td>4.9</td>
<td>30</td>
<td>2<sup>30</sup></td>
<td>30*2<sup>30</sup>=2<sup>35</sup></td>
<td>2<sup>60</sup></td>
<td>2<sup>90</sup></td>
<td>2<sup>1G</sup></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>最差，最好，平均

<ul>
<li>例如顺序搜索

<ul>
<li>如果在第一个就搜到，那么就是最佳的case</li>
<li>如果搜到最后一个才搜到，那就是最差的case</li>
<li>（最佳+最差）/2为平均</li>
</ul>
</li>
<li>一般都是用平均的</li>
</ul>
</li>
<li>上界

<ul>
<li>大O表示

<ul>
<li>对一个非负的函数T(n)，T(n)是O(f(n))的当且仅当存在两个非负的c和k，使得T(n)&lt;=cf(n) 对所有n > k;

<ul>
<li>其中k为n的最小值</li>
</ul>
</li>
</ul>
</li>
<li>大omega

<ul>
<li>对一个非负的函数T(n)，T(n)是omega(g(n))当且存在两个非负的c和k，使得T(n)>=cg(n) 对所有n > k;</li>
</ul>
</li>
<li>大theta

<ul>
<li>当上界和下界被同一个常数影响。</li>
</ul>
</li>
</ul>
</li>
<li>例子</li>
<li><code>
sum1 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=n;j++)
      sum1++;
sum2 = 0;
for(k=1;k&lt;=n;k*=2)
  for(j=1;j&lt;=k;j++)
      sum2++;
</code>

<ul>
<li>第一个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了n次

<ul>
<li>那么复杂度为nlogn</li>
</ul>
</li>
</ul>
</li>
<li>第二个循环

<ul>
<li>第一个for执行了logn + 1次</li>
<li>第二个for执行了执行了k次，k=2<sup>i</sup>

<ul>
<li>那么复杂度为n</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用算法的时间复杂度</li>
<li><p><strong>搜索</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>二分搜索</td>
<td>数组查n个元素</td>
<td>logn|</td>
</tr>
<tr>
<td>顺序查找</td>
<td>数组查n个元素</td>
<td>n|</td>
</tr>
<tr>
<td>最短路（乱序数组）</td>
<td>V个点和E条边</td>
<td>V<sup>2</sup></td>
</tr>
<tr>
<td>最短路（bellman-ford）</td>
<td> V个点和E条边</td>
<td>V*E       </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p><strong>排序</strong></p>

<ul>
<li><table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>平均时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>快速排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>归并排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>堆排序</td>
<td>数组</td>
<td>nlogn</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>插入排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>选择排序</td>
<td>数组</td>
<td>n<sup>2</sup></td>
</tr>
<tr>
<td>桶排序</td>
<td>数组</td>
<td>n+k</td>
</tr>
<tr>
<td>计数排序</td>
<td>数组</td>
<td>n*k </td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>


<h4>算法加速</h4>

<ul>
<li>focus on算法主要消耗时间的部分</li>
<li>先优化算法，再优化代码</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xapian omindex build index and search]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search/"/>
    <updated>2015-04-15T22:28:58-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/15/xapian-omindex-build-index-and-search</id>
    <content type="html"><![CDATA[<h3>omega is a component that can be used with xapian</h3>

<ul>
<li>we can use omega to build index</li>
</ul>


<h4>build index</h4>

<ul>
<li><code>omindex --db index --url / ./index_file/</code>

<ul>
<li>&mdash;db 后面跟的是索引数据库的名字</li>
<li>&mdash;url 后面跟的是 / 然后再加上要建索引的数据的文件夹（含有那些要建索引的文件）</li>
</ul>
</li>
<li>运行之后，就会生成index文件夹，这个文件夹里面就是建好的索引</li>
</ul>


<h4>query</h4>

<ul>
<li>quest &mdash;db=index &ldquo;asd&rdquo;

<ul>
<li>&mdash;db 后面跟的是索引数据库</li>
<li>然后再加上要查询的关键字</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtual machine windows VS2010 UNC path not support]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/14/virtual-machine-windows-vs2010-unc-path-not-support/"/>
    <updated>2015-04-14T21:17:08-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/14/virtual-machine-windows-vs2010-unc-path-not-support</id>
    <content type="html"><![CDATA[<h3>解决UNC路径不受支持</h3>

<pre><code>在虚拟机的VS2010中编译出错
</code></pre>

<ul>
<li>错误提示：用作为当前目录的以上路径启动了 CMD.EXE。 UNC 路径不受支持。默认值设为 Windows 目录。系统找不到指定的文件。执行 c:\windows\system32\cmd.exe 时出错.</li>
<li>解决方法:

<ul>
<li>在注册表中,添加一个值即可.路径如下:

<ul>
<li>HKEY_CURRENT_USER\Software\Microsoft\Command Processor</li>
<li>添加值 DisableUNCCheck，类型为 REG_DWORD 并将该值设置为1 （十六进制）。</li>
</ul>
</li>
<li>或者，打开cmd.exe

<ul>
<li>把下面这行代码复制进去，按回车</li>
<li>reg add  &ldquo;HKEY_CURRENT_USER\Software\Microsoft\Command Processor&rdquo; /v DisableUNCCheck /t REG_DWORD /d 1 /f</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.net in mac MonoDevelop]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/14/asp-dot-net-in-mac-monodevelop/"/>
    <updated>2015-04-14T03:01:35-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/14/asp-dot-net-in-mac-monodevelop</id>
    <content type="html"><![CDATA[<h3>install asp.net environment in mac</h3>

<ul>
<li>we can use MonoDevelop IDE in mac to develop c# or VB program

<ul>
<li>also asp.net too</li>
</ul>
</li>
<li>download url: <a href="http://www.monodevelop.com/download/">http://www.monodevelop.com/download/</a>

<ul>
<li>download the Xamarin studio as development IDE</li>
</ul>
</li>
</ul>


<!--more-->


<h3>after install the environment</h3>

<ul>
<li>start a solution as ASP.NET project in C#</li>
<li>it will generate a project with some default page

<ul>
<li>The Default.aspx can be act as a html page</li>
<li>and Default.aspx.cs can act be a controller in c#</li>
<li>and Default.aspx.designer.cs can act be a model in MVC</li>
</ul>
</li>
</ul>


<h3>connect to mysql</h3>

<ul>
<li>remember to add System.Data in the Reference</li>
<li>add a MyDql.Data in Packages</li>
<li>add a <code>using MySql.Data.MySqlClient;</code> in the cs code</li>
</ul>


<h3>code for mysql connection</h3>

<ul>
<li>front end page</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;%@ Page Language="C#" Inherits="test1.Default" %&gt;
</span><span class='line'>&lt;!DOCTYPE html&gt;
</span><span class='line'>&lt;html&gt;
</span><span class='line'>&lt;head runat="server"&gt;
</span><span class='line'>  &lt;title&gt;Default&lt;/title&gt;
</span><span class='line'>  &lt;style&gt;
</span><span class='line'>  table, th, td {
</span><span class='line'>      border: 1px solid black;
</span><span class='line'>      border-collapse: collapse;
</span><span class='line'>  }
</span><span class='line'>  th, td {
</span><span class='line'>      padding: 15px;
</span><span class='line'>  }
</span><span class='line'>  &lt;/style&gt;
</span><span class='line'>&lt;/head&gt;
</span><span class='line'>&lt;body&gt;
</span><span class='line'>  &lt;form id="form1" runat="server"&gt;
</span><span class='line'>      &lt;asp:button id="clickMeButton" runat="server" text="Click Me" onClick="clickMeButton_Click" /&gt;
</span><span class='line'>      &lt;asp:label id="outputlabel" runat="server" /&gt;
</span><span class='line'>  &lt;/form&gt;
</span><span class='line'>&lt;/body&gt;
</span><span class='line'>&lt;/html&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>backend</li>
<li>cs file 1</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;code&gt;
</span><span class='line'>using System; 
</span><span class='line'>using System.Data; 
</span><span class='line'>using System.Configuration; 
</span><span class='line'>using System.Collections; 
</span><span class='line'>using System.Web; 
</span><span class='line'>using System.Web.Security; 
</span><span class='line'>using System.Web.UI; 
</span><span class='line'>using System.Web.UI.WebControls; 
</span><span class='line'>using System.Web.UI.WebControls.WebParts; 
</span><span class='line'>using System.Web.UI.HtmlControls; 
</span><span class='line'>using MySql.Data.MySqlClient; 
</span><span class='line'>namespace test1
</span><span class='line'>{
</span><span class='line'>  public partial class Default : System.Web.UI.Page
</span><span class='line'>  {
</span><span class='line'>      public void clickMeButton_Click (object sender, EventArgs e)
</span><span class='line'>      {
</span><span class='line'>          object val = ViewState["ButtonClickCount"];
</span><span class='line'>          int i = (val == null)? 1 : (int)val + 1;
</span><span class='line'>          outputlabel.Text = string.Format ("You clicked me {0} {1}", i, i==1?"time":"times");
</span><span class='line'>          ViewState["ButtonClickCount"] = i;
</span><span class='line'>          string query = "select * from reference limit 10"; 
</span><span class='line'>          MySqlConnection myConnection = new MySqlConnection("server=localhost;user id=root;password=root;database=reference_db"); 
</span><span class='line'>          MySqlCommand myCommand=new MySqlCommand(query,myConnection); 
</span><span class='line'>          myConnection.Open(); 
</span><span class='line'>          myCommand.ExecuteNonQuery(); 
</span><span class='line'>          MySqlDataReader myDataReader = myCommand.ExecuteReader(); 
</span><span class='line'>          string bookres=""; 
</span><span class='line'>          bookres += "&lt;table style=\"width:100%\"&gt;";
</span><span class='line'>          while (myDataReader.Read()==true) 
</span><span class='line'>          { 
</span><span class='line'>              bookres += "&lt;tr&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["id"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["ReferenceType"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;td&gt;";
</span><span class='line'>              bookres+=myDataReader["Record_Number"]; 
</span><span class='line'>              bookres += "&lt;/td&gt;&lt;/tr&gt;";
</span><span class='line'>          } 
</span><span class='line'>          bookres += "&lt;/table&gt;";
</span><span class='line'>          myDataReader.Close(); 
</span><span class='line'>          myConnection.Close(); 
</span><span class='line'>          outputlabel.Text = bookres;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>cs file 2</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;code&gt;
</span><span class='line'>using System;
</span><span class='line'>using System.Web;
</span><span class='line'>using System.Web.UI;
</span><span class='line'>namespace test1
</span><span class='line'>{
</span><span class='line'>  public partial class Default
</span><span class='line'>  {
</span><span class='line'>      protected System.Web.UI.WebControls.Button button1;
</span><span class='line'>      protected System.Web.UI.WebControls.Label outputlabel;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java spring tutorial part1]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/11/java-spring-tutorial-part1/"/>
    <updated>2015-04-11T15:41:46-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/11/java-spring-tutorial-part1</id>
    <content type="html"><![CDATA[<h3>maven</h3>

<ul>
<li>make sure &lsquo;mvn -v&rsquo; return the current version in you computer</li>
<li>otherwise, install the maven first</li>
</ul>


<h3>Hello world</h3>

<ul>
<li>project hierarchy

<ul>
<li>helloworld (folder)

<ul>
<li>(root directory)</li>
<li>src

<ul>
<li>main

<ul>
<li>java

<ul>
<li>hello

<ul>
<li>Greeter.java</li>
<li>HelloWorld.java</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>target(auto generate after mvn install)

<ul>
<li>helloworld-0.1.0.jar</li>
</ul>
</li>
<li>pom.xml</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<h4>class</h4>

<ul>
<li><code>mkdir -p src/main/java/hello</code>

<ul>
<li>make a directory to put the java class</li>
</ul>
</li>
<li>create two class <code>HelloWorld.java</code> and <code>Greeter.java</code>

<ul>
<li><p>HelloWorld.java</p>

<ul>
<li><p>&#8220;`
  package hello;</p>

<p>  import org.joda.time.LocalTime;</p>

<p>  public class HelloWorld{
      public static void main(String[] args){
          LocalTime currentTime = new LocalTime();
          System.out.println(&ldquo;The currentTime local time is &rdquo; + currentTime);
          Greeter greeter = new Greeter();
          System.out.println(greeter.sayHello());
      }
  }</p></li>
</ul>


<p>  &#8220;`</p></li>
<li><p>Greeter.java</p>

<ul>
<li><p>&#8220;`
  package hello;</p>

<p>  public class Greeter {
      public String sayHello() {
          return &ldquo;Hello world!&rdquo;;
      }
  }
&#8220;`</p></li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>configuration</h4>

<ul>
<li>pom.xml

<ul>
<li>put the file in the root of the project</li>
<li><p>&#8220;`
  &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <groupId>org.springframework</groupId>
      <artifactId>helloworld</artifactId>
      <packaging>jar</packaging>
      <version>0.1.0</version></p>

<pre><code>  &lt;!--- 插件 --&gt;
  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;joda-time&lt;/groupId&gt;
          &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
          &lt;version&gt;2.2&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
              &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
              &lt;version&gt;2.1&lt;/version&gt;
              &lt;executions&gt;
                  &lt;execution&gt;
                      &lt;phase&gt;package&lt;/phase&gt;
                      &lt;goals&gt;
                          &lt;goal&gt;shade&lt;/goal&gt;
                      &lt;/goals&gt;
                      &lt;configuration&gt;
                          &lt;transformers&gt;
                              &lt;transformer
                                  implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;
                                  &lt;mainClass&gt;hello.HelloWorld&lt;/mainClass&gt;
                              &lt;/transformer&gt;
                          &lt;/transformers&gt;
                      &lt;/configuration&gt;
                  &lt;/execution&gt;
              &lt;/executions&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>

<p>  </project>
&#8220;`</p></li>
</ul>
</li>
</ul>


<h4>run the maven project</h4>

<ul>
<li>compile

<ul>
<li>mvn compile</li>
</ul>
</li>
<li>install

<ul>
<li>mvn install</li>
</ul>
</li>
<li>two ways to run

<ul>
<li>java -jar helloworld-0.1.0.jar</li>
<li>mvn exec:java -Dexec.mainClass=&ldquo;hello.HelloWorld&rdquo;</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[install tomcat in mac]]></title>
    <link href="http://pbking1.github.com/blog/2015/04/03/install-tomcat-in-mac/"/>
    <updated>2015-04-03T03:28:36-04:00</updated>
    <id>http://pbking1.github.com/blog/2015/04/03/install-tomcat-in-mac</id>
    <content type="html"><![CDATA[<h3>install tomcat in mac</h3>

<ul>
<li>1.go to <a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and download the zip file of tomcat</li>
<li>2.then unzip the zip file into /Library and rename into &ldquo;Tomcat&rdquo;</li>
<li>3.then <code>sudo chmod 755 /Library/Tomcat/bin/*.sh</code></li>
<li>4.if you want to start tomcat

<ul>
<li><code>sudo sh startup.sh</code></li>
<li>if want to stop

<ul>
<li><code>sudo sh /Library/Tomcat/bin/shutdown.sh</code></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compile qtox on OSX]]></title>
    <link href="http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx/"/>
    <updated>2015-03-03T23:49:35-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/03/03/compile-qtox-on-osx</id>
    <content type="html"><![CDATA[<h3>Problems when compile qtox on mac</h3>

<ul>
<li>first is the modification of the qtox.pro file</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CONFIG += c++11
</span><span class='line'>CONFIG += x86_64
</span><span class='line'>CONFIG -= x86
</span><span class='line'>contains(JENKINS,YES) {
</span><span class='line'>  INCLUDEPATH += ./libs/include/
</span><span class='line'>} else {
</span><span class='line'>  INCLUDEPATH += libs/include
</span><span class='line'>    # add head path
</span><span class='line'>    INCLUDEPATH += /usr/include
</span><span class='line'>    INCLUDEPATH += /usr/local/include
</span><span class='line'>    INCLUDEPATH += /opt/local/include
</span><span class='line'>}
</span><span class='line'>macx {
</span><span class='line'>    BUNDLEID = im.tox.qtox
</span><span class='line'>    ICON = img/icons/qtox.icns
</span><span class='line'>    QMAKE_INFO_PLIST = osx/info.plist
</span><span class='line'>    QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9
</span><span class='line'>    # add libtoxav
</span><span class='line'>    LIBS += -L/usr/local/opt/libtoxcore/lib -ltoxav -ltoxcore
</span><span class='line'>    LIBS += -L/usr/local/opt/libsodium/lib -lsodium
</span><span class='line'>    LIBS += -L/usr/local/opt/libvpx/lib -lvpx
</span><span class='line'>    LIBS += -L/usr/local/lib -lopus
</span><span class='line'>    LIBS += -L/usr/local/lib -lopencv_core -lopencv_highgui
</span><span class='line'>    #LIBS += -L/opt/local/lib -lopencv_core -lopencv_highgui
</span><span class='line'>    LIBS += -L$$PWD/libs/lib/ -framework OpenAL -mmacosx-version-min=10.9
</span><span class='line'>    #LIBS += -L$$PWD/libs/lib/ -ltoxcore -ltoxav -ltoxencryptsave -ltoxdns -lsodium -lvpx -lopus -framework OpenAL -lopencv_core -lopencv_highgui -mmacosx-version-min=10.7
</span><span class='line'>    contains(DEFINES, QTOX_PLATFORM_EXT) { LIBS += -framework IOKit -framework CoreFoundation }
</span><span class='line'>    contains(DEFINES, QTOX_FILTER_AUDIO) { LIBS += -lfilteraudio }</span></code></pre></td></tr></table></div></figure>




<!--more-->


<ul>
<li><p>1.-ltoxcore can not found</p>

<ul>
<li>install the toxcore library

<ul>
<li>and remember to add the library path</li>
</ul>
</li>
</ul>
</li>
<li><p>2.can not find -lopus</p>

<ul>
<li>install the libogg first and then install the opus library</li>
</ul>
</li>
<li><ol>
<li>“Project ERROR: Could not resolve SDK path for ‘macosx10.8′”.</li>
<li><code>cd /Users/Mark/Qt/5.3/clang_64/mkspecs/</code>

<ul>
<li>modify <code>!host_build:QMAKE_MAC_SDK = macosx10.9</code></li>
</ul>
</li>
</ol>
</li>
<li><p>4.&ldquo;Undefined symbols for architecture x86_64&rdquo;</p>

<ul>
<li><strong>not solved</strong>

<ul>
<li>one way on the Internet(did not solve)

<ul>
<li>change <code>../Qt5.4.0/5.4.0-rc1/clang_64/mkspecs/macx-clang/qmake.conf</code>

<ul>
<li>from <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.6</code></li>
<li>into <code>QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9</code>

<ul>
<li>and remember to clean the project before rebuild</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.&lsquo;#include &lt;>&rsquo; and &lsquo;#include &ldquo;&rdquo;&rsquo;</p>

<ul>
<li>&lsquo;#include &lt;>&rsquo;

<ul>
<li>find the header in particular path

<ul>
<li>/usr/include</li>
<li>for exmaple: /usr/include/stdio.h</li>
</ul>
</li>
</ul>
</li>
<li>&lsquo;#include &ldquo;&rdquo;&rsquo;

<ul>
<li>find the header in absolute path</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CLEP microeconomic practise exam]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/28/clep-microeconomic-practise-exam/"/>
    <updated>2015-02-28T15:03:29-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/28/clep-microeconomic-practise-exam</id>
    <content type="html"><![CDATA[<h3>exam 1</h3>

<ul>
<li>1.If a producing firm does not have enough time to expand its plant capacity生产规模, it is:

<ul>
<li><strong>operating in the short run</strong></li>
<li>因为没时间，所以要赶紧做事，以免被别人打败

<ul>
<li>所以只能进行短期运营</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>2.Economic costs of production differ from accounting costs of production in that:

<ul>
<li><strong>economic costs add the opportunity cost of a firm using its own resources.</strong></li>
<li>经济利润和会计利润

<ul>
<li>会计利润：总收入减总成本</li>
<li>经济利润：总收入减总成本减机会成本</li>
</ul>
</li>
</ul>
</li>
<li><p>3.An example of a long run adjustment is:</p>

<ul>
<li><strong>Walmart builds another Supercenter.</strong></li>
<li>长期运营的话就要扩大规模</li>
</ul>
</li>
<li><p>4.The reason the marginal product of labor in the short run increases at first and then falls is because:</p>

<ul>
<li><strong>there are fewer opportunities for division of labor and specialization.</strong></li>
<li>边际产量：增加一个劳动力增加的产量</li>
<li>边际产量递减规律

<ul>
<li>边际产量递减，所以边际成本递增</li>
</ul>
</li>
<li>一开始效果明显，到后来基数大了所以就不明显了

<ul>
<li>工人少，人数增加效率增加</li>
<li>工人越多，就会存在协调问题，所以效率就会下降</li>
</ul>
</li>
</ul>
</li>
<li><p>5.If 11 workers can produce a total of 54 units of a product and another worker has a marginal product of six, then the average product of 12 workers is:</p>

<ul>
<li><strong>(54 + 6)/12 = 5</strong></li>
</ul>
</li>
<li><p>6.Economies of scale exist because as a firm increases its size in the long run长期:</p>

<ul>
<li><strong>labor and management can specialize their activities more.</strong></li>
<li><strong>as a larger input buyer the firm can purchase inputs at a lower per unit cost.</strong></li>
<li><strong>the firm can afford more sophisticated technology in production.</strong></li>
<li>规模经济：

<ul>
<li>短期无法改变固定成本，只有长期才能改变固定成本。

<ul>
<li>长期的曲线是由很多短期的曲线</li>
<li>随着产量增加，平均总成本下降(这一段就叫规模经济)</li>
<li>平均总成本上升的(这一段叫规模不经济)</li>
</ul>
</li>
<li>固定成本：器材(本来就有的)

<ul>
<li>固有资产</li>
</ul>
</li>
<li>可变成本：劳动力（可以增加可以减少）

<ul>
<li>会随着产量变动而变动的成本</li>
</ul>
</li>
<li>平均固定成本：固有资产平均分到课本成本上

<ul>
<li>随着产量的增加，递减的</li>
</ul>
</li>
<li>平均可变成本：例如原材料

<ul>
<li>随着产量的增加，递增的</li>
</ul>
</li>
<li>平均总成本：平均可变成本 + 平均固定成本

<ul>
<li>一开始是平均固定成本起主导作用，所以下降</li>
<li>然后是平均可变成本起主导作用，所以增加</li>
<li>斜率就为边际成本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>7.In natural monopolies自然垄断 such as the generation of electricity, long-run average costs continue to decrease as the plant size gets larger, because:</p>

<ul>
<li><strong>diseconomies of scale are very minor but economies of scale continue.规模经济持续</strong></li>
<li>由于规模经济造成的垄断，叫自然垄断

<ul>
<li>因为企业应为规模经济成本比较低。 所以比其他新来的企业更有竞争力</li>
</ul>
</li>
</ul>
</li>
<li><p>8.In figure 10.2, the difference between average total costs and average variable costs is:</p></li>
<li><img src="http://pbking1.github.com/images/econ/1.png" alt="Image" /></li>
<li><img src="http://pbking1.github.com/images/econ/">

<ul>
<li><strong>average fixed costs.</strong></li>
<li>平均总成本 = 平均可变成本 + 平均固定成本</li>
</ul>
</li>
<li>9.In figure 10.2, average variable costs approach average total costs as output rises because:

<ul>
<li><strong>average fixed costs are falling.</strong></li>
</ul>
</li>
<li>10.In figure 10.2, when marginal costs are rising:

<ul>
<li><strong>marginal product of labor（劳动边际产量） is declining.</strong></li>
<li>边际产量递减</li>
</ul>
</li>
<li><p>11.Both individual buyers and sellers in perfect competition:</p>

<ul>
<li><strong>have to take the market price as a given.</strong></li>
<li>都是价格接受者</li>
<li>完全竞争市场：卖家很多，买家很多，而且市场物品一样。企业能够只有进出。

<ul>
<li>当价格高于成本时，就会有新的企业进入

<ul>
<li>这时候供给多了，价格下降</li>
<li>然后变回原来的价格。然后企业就退出</li>
<li>然后价格有上升</li>
<li>所有都是价格接受者（价格就是边际成本）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>12.If a perfectly competitive seller is producing at an output where price is $11 and the marginal cost is $14.54, then to maximise profits the firm should:</p>

<ul>
<li><strong>produce a smaller level of output.</strong></li>
<li>边际成本比市场价格高

<ul>
<li>无利可图， 所以压缩产量</li>
</ul>
</li>
</ul>
</li>
<li><p>13.A very large number of small sellers who sell identical products implies:</p>

<ul>
<li><strong>the inability of one seller to influence price.</strong></li>
<li>很多卖家卖相同产品，所以都是价格接受者</li>
<li>所以不能调价，不然买家就会跑到别的市场买</li>
<li>完全竞争</li>
</ul>
</li>
<li><p><img src="http://pbking1.github.com/images/econ/2.png" alt="Image" /></p></li>
<li><img src="http://pbking1.github.com/images/econ/"></li>
<li><p>14.At price P1, the firm in figure 11.1 would produce:</p>

<ul>
<li><strong>zero</strong></li>
<li>这种图都是短期的，长期的只有一个u型曲线</li>
<li>因为固定成本是已经付出的成本</li>
<li>市场价格P1低于平均可变成本，说明成本比较高了，所以无利可图，所以不生产</li>
</ul>
</li>
<li><p>15.At price P2, the firm in figure 11.1 would produce:</p>

<ul>
<li><strong>Q5</strong></li>
<li>在Q5这个交点，如果产量低于这个交点，所以成本低于市场价格，所以有利可图</li>
<li>如果高，则成本高于市场价格，所以无利可图，不生产</li>
</ul>
</li>
<li><p>16.At price P1, the firm in figure 11.1 would:</p>

<ul>
<li><strong>lose fixed costs.</strong></li>
<li>因为不生产，所以损失掉了固定成本</li>
</ul>
</li>
<li><p>17.At price P3, the firm in figure 11.1 would:</p>

<ul>
<li><strong>break even损益均衡的</strong></li>
<li>因为MC和ATC在P3相交，所以收益和成本一样，所以没赚没亏</li>
</ul>
</li>
<li><p>18.At price P4 in the long run, the industry including the firm in figure 11.1 would:</p>

<ul>
<li><strong>have entry of new firms.</strong></li>
<li>边际收益大于平均总成本，所以会有新的企业进入赚钱</li>
</ul>
</li>
<li><p>19.At price P2 in the long run, the industry including the firm in figure 11.1 would:</p>

<ul>
<li><strong>have exit（退出） of some existing firms.</strong></li>
<li>因为长期的话,要算上平均固定成本。</li>
<li>因此所以要看平均总成本曲线，在P2，平均总成本曲线高于MC曲线，所以要退出市场。</li>
</ul>
</li>
<li><p>20.When a competitive firm finds that the market price is below its minimum average variable cost level, it will sell:</p>

<ul>
<li><strong>nothing at all, the firm shuts down.</strong></li>
<li>因为再完全竞争市场下，短期只考虑平均可变成本，当市场价格低于平均可变成本的时候，无利可图，企业关门</li>
</ul>
</li>
<li><p>21.If, as the industry expands, a competitive industry can supply larger quantities at the same long-run market price, it is:</p>

<ul>
<li><strong>a constant-cost industry.</strong></li>
<li>在一个完全市场竞争中，由于允许企业自由进出，市场价格不受买者和卖者的影响，他们都是价格接受者，所以企业成本是不会变的</li>
<li>也就是说企业的供给曲线是一条横线，企业无论供给多少，市场价格都不会变</li>
</ul>
</li>
<li><p>22.A local electricity-generating company has a monopoly that is protected by a barrier to entry that takes the form of:</p>

<ul>
<li><strong>economies of scale.</strong></li>
<li>自然垄断是因为规模经济而形成的垄断</li>
<li>规模经济是指企业产量增大而成本不断降低的阶段，其他企业想要进入，成本比该企业高，竞争力低，最终只有一家企业在做：例如自来水，电力的企业</li>
</ul>
</li>
<li><p><img src="http://pbking1.github.com/images/econ/3.png" alt="Image" /></p></li>
<li><img src="http://pbking1.github.com/images/econ/"></li>
<li><strong>这个图是垄断的成本曲线，因为边际收益MR在需求曲线下面（？）</strong></li>
<li><p>23.To profit maximize the firm in figure 14.1 will produce:</p>

<ul>
<li><strong>Q2</strong>.</li>
<li>垄断企业是价格影响者，在一定产量的前提下，增加一单位产品，想要卖出，就要降低价格，增加一个单位产品的销售，增加的利润是低于当时市场价格的，所以边际收益曲线在需求曲线之下。</li>
<li>垄断要达到最大的利润，必须边际收益等于边际成本，也就是MR=MC（Q2,P1），这个时候增加以单位产品，所得到的利益和成本相同，相互抵消不赚不亏。利用MR=MC，可以确定产量，但相应的价格，应该要在该产量下，投影到需求曲线上，这个需求曲线上的价格才是对应的价格。</li>
</ul>
</li>
<li><p>24.The profit maximize price for the firm in figure 14.1 is:</p>

<ul>
<li><strong>P3</strong></li>
<li>(?)对垄断行业（MR再需求曲线下），确定利润最大化对应的产量和价格的步骤

<ul>
<li>MR=MC(边际收益等于边际成本) &ndash;> 确定产量 &ndash;> 产量投影到需求曲线 &ndash;> 确定价格</li>
</ul>
</li>
</ul>
</li>
<li><p>25.If average total costs are ATC1, the firm in figure 14.1 will:</p>

<ul>
<li><strong>make a profit</strong></li>
<li>总成本=平均总成本*产量</li>
<li>总收益=单价*产量</li>
<li>把公式在图上表示为矩形面积，比较两个矩形，总收益大于总成本，有利润</li>
</ul>
</li>
<li><p>26.In figure 14.1, the difference between the monopoly output and the competitive output is:</p>

<ul>
<li><strong>Q3-Q2</strong></li>
<li>完全竞争市场和垄断市场，最大区别在于一个是价格接受者，一个是价格影响者</li>
<li>完全竞争市场：价格接受者，其边际收益曲线和市场需求曲线完全重合，利润最大的条件

<ul>
<li>利润最大化的条件：边际收益=边际成本（MR=MC）也就是市场需求曲线（也就是边际收益曲线）和边际成本曲线相交的点</li>
</ul>
</li>
<li>垄断市场：价格影响者，其边际收益曲线和市场需求曲线不同，比市场需求曲线低。

<ul>
<li>利润最大化的条件：边际收益=边际成本（MR=MC）也就是边际收益曲线和边际成本曲线的交点。</li>
</ul>
</li>
</ul>
</li>
<li><p>27.A profit maximizing monopolistʹs price is:</p>

<ul>
<li><strong>greater than what the price would be if the mononoplistʹs industry were competitive.</strong></li>
<li>(?)垄断市场和完全竞争市场相比，产量少，价格高</li>
</ul>
</li>
<li><p>28.The important economic concept illustrated by increasing opportunity costs is:</p>

<ul>
<li><strong>the more resources devoted to any activity, the smaller the payoff of devoting more resources to that activity.</strong></li>
<li>机会成本的根本原因是资源有限</li>
<li>所以你把资源投入到一个活动中，其他方面的活动能用的资源就变少了，这种损失的所有可能收益称为机会成本</li>
</ul>
</li>
<li><p>29.A production possibilities frontier model shows that:</p>

<ul>
<li><strong>if all resources are fully and efficiently utilized, more output of good X can only be achieved by producing less of another good.</strong></li>
<li>生产可能性边界模型，在线上的每一点都表示在充分利用资源的前提下所能生产的两种产品的产量分产品的产量组合。</li>
<li>可以想象，要增加一种产品的产量，必然要减少另外一种产品的产量，所以其曲线是斜向下的直线或者是斜向下的曲线</li>
</ul>
</li>
<li><p>30.If George can mow 10 lawns or cultivate 5 gardens a day while Jack can mow 6 lawns or cultivate 4 gardens a day, then:</p>

<ul>
<li><strong>Jack has a comparative advantage in lawn mowing.</strong></li>
<li>相对优势和绝对优势</li>
<li>绝对优势：对一个人的两个活动进行效率比较，所以两个人的绝对优势可能是一样的</li>
<li>相对优势：对两个人的同一个活动进行效率比较，所以两个人的相对优势是不会一样的。

<ul>
<li>一方在这个方面有比较优势，另一方必然是再另外一个方面有比较优势</li>
</ul>
</li>
</ul>
</li>
<li><p>31.If last year the Ajax firm sold 250 sofas at $1,000 each and this year Ajax sold 500 sofas at $1,500 each, then</p>

<ul>
<li><strong>the demand for sofas increased.</strong></li>
<li>价格从4变成了3</li>
<li>一般来说，产量的增加会导致价格的下降，而题目中产量的增加，价格也增加，说明市场上需求也增加了。</li>
</ul>
</li>
<li><p>32.The demand for big screen TVs would fall, if big screen TVs are normal goods and:</p>

<ul>
<li><strong>buyerʹs of big screen TVs incomes fall because of a recession萧条.</strong></li>
<li>对正常商品，影响其需求量的因素有：1.市场消费者数量， 2.消费者偏好， 3.消费者收入， 4.该商品自身的价格， 5.其他商品的价格</li>
<li>其中，1，2，3，5. 能够让整个需求曲线左右移动，而4 是是需求量是沿着需求曲线改变。因为该商品自身价格是需求曲线的变量。</li>
</ul>
</li>
<li><p>33.A change in demand represents a <strong><strong><strong><strong> while a change in quantity demanded is a </strong></strong></strong></strong>.</p>

<ul>
<li><strong>shift to a new demand curve</strong>; <strong>movement along one demand curve</strong></li>
<li>（？）</li>
<li>需求变动和需求量变动</li>
<li>需求变动是指需求曲线移动</li>
<li>需求量变动是指沿着需求曲线变动，需求曲线不变</li>
</ul>
</li>
<li><p>34.If the demand for a good increases when there is high unemployment, we can conclude that the commodity is:</p>

<ul>
<li><strong>an inferior下级 good</strong></li>
<li>高失业率意味着低收入。对正常商品而言，人们收入减少，对其需求也将减少，如：一般的衣服；而对低档的商品，人们收入减少，对其需求则会增加，如：咸菜</li>
</ul>
</li>
<li><p>35.An advance in technology increases supply:</p>

<ul>
<li><strong>because laborʹs or capitalʹs productivity increases and costs of production fall.</strong></li>
<li>技术的提高会增大产量，原因：效率提高了，相应的平均成本降低了。

<ul>
<li>因为产量增大，而固定成本不变，平摊到每个产品的吃那个本就下降了。</li>
</ul>
</li>
</ul>
</li>
<li><p>36.When a strike at a major local employer occurs, the demand for television sets in that local market will:</p>

<ul>
<li><strong>decreases because buyers incomes have decreased.</strong></li>
<li>罢工会引起工人收入降低，电视机是一种正常的商品。人们收入降低，对其需求减少。</li>
</ul>
</li>
<li><p>37.If the current market price for a particular book is $30 a unit and a price ceiling is imposed at $20 per book, then:</p>

<ul>
<li><strong>there will an increase in the quantity demanded of the book.</strong></li>
<li><strong>a shortage of the book will develop at the ceiling price.</strong></li>
<li><strong>a price of $20 per book is the legally allowed maximum price of the book.</strong></li>
<li>价格上限（限定最高价格）对市场价格的影响</li>
<li>当价格上限高于市场稳定价格（当供给和需求相等时的价格），价格上限对市场价格无影响，最终市场价格趋于稳定价格（当供给和需求相等时的价格）</li>
<li>当价格上限低于市场价格，此时，价格较低，对消费者有利，消费者对其需求较大，不利于生产者，生产者对其的供给量将减少。这样一来，市场需求大于供给，形成商品短缺。如果没有价格上限，市场价格将会上升。现在有了价格上限，市场价格只能趋于价格上限。</li>
</ul>
</li>
<li><p>38.Among the impacts of the minimum wage工资 is that:</p>

<ul>
<li><strong>higher costs are imposed on employers.</strong></li>
<li><strong>employers substitute other lower cost inputs in place of higher priced labor.</strong></li>
<li><strong>higher product prices result because production costs are increased.</strong></li>
<li>最低工资的影响：1.企业需要支付的工资增加了，无形中增加了产品的成本（可变成本） 2.产品成本增加，导致其价格上升 3.企业会寻求更低的价格的投入， 比如：买机器，减少工人数量</li>
</ul>
</li>
<li><p>39.After a city imposes a rent control law:</p>

<ul>
<li><strong>landlords reduce the quantity of apartments offered for rent.</strong></li>
<li>租金控制，由于租金太高所以需要控制，设定价格上限。</li>
</ul>
</li>
<li><p>40.Consumers pay 100% of a new sales tax on a good:</p>

<ul>
<li><strong>when the demand is perfectly inelastic.</strong></li>
<li>税收其实都是买房和买房共同承担的，所谓的向谁手只是决定了有谁交给政府而已。</li>
<li>对于需求价格弹性大，收税商品价格高，消费者这就会减少对其的购买，而卖家没办法，都已经进了货，只能由其交大部分的税，所以对于需求价格弹性大的商品来说，卖家交的税更多。</li>
<li>对于需求弹性小，收税价格高，买家一定要买，而买家可以不用进那么多货，所以只能由买家交大部分税。对于需求价格弹性小的商品来说，买家交的税更多。</li>
</ul>
</li>
<li><p>41.Which of the following statements about elasticity of demand需求弹性 is correct?</p>

<ul>
<li><strong>Demand is more elastic in a long time period than it is in a short time period.</strong></li>
<li>（？）需求价格弹性（是指绝对值）有以下两个特点：

<ul>
<li>1.小范围的弹性要大于大范围的弹性，因为小范围的有比较多的替代品，而大范围的比较少得替代品。比如米饭和食物，米饭弹性大，因为消费者可以不买米饭而由米粉，零食代替，当米饭价格高了，可以减少对米饭的购买；而食物，很难找到其替代品，其价格高，也必须买。</li>
<li>2.长期的弹性要大于短期的弹性，因为长期的比较灵活。比如：汽油。当汽油的价格上升的时候，对于现有车的人来说，即使现在的价格高了也必须买汽油，汽油在短期来看，其需求量变动不大；而对于现在想买车的人来说，其会考虑买比较不耗费汽油的车或者买用电的车，这样一来，汽油长期的需求量将会变动非常大。</li>
</ul>
</li>
</ul>
</li>
<li><p>42.Which of the following goods would most likely have the most inelastic demand?</p>

<ul>
<li><strong>Bread</strong></li>
<li>日常生活用品价格弹性小</li>
</ul>
</li>
<li><p>43.If at a price of $100, 10 units were sold while at a price of $125, eight units were sold, the price elasticity of demand value using the midpoint formula is:</p>

<ul>
<li><strong>one</strong></li>
<li>（？）需求价格弹性公式=需求量变动的百分比/价格变动的百分比</li>
<li>所谓的中点法是指在求百分比的时候用中点

<ul>
<li>[(8-10)/((8-10)/2)]/[(125-100)/((125+100)/2)]=-1</li>
<li>需求价格弹性是指绝对值</li>
</ul>
</li>
</ul>
</li>
<li><p>44.If at a price of $50, 20 units are sold and at a price of $60, 0 units are sold, the price elasticity of demand of the good is:</p>

<ul>
<li><strong>perfectly elastic.</strong></li>
<li>用中点法求得其需求价格弹性（指绝对值）等于11.0000011， 一般的，需求价格弹性>1，就算富有弹性。</li>
</ul>
</li>
<li><p>45.When demand is price elastic, a fall in price causes total revenue to rise because:</p>

<ul>
<li><strong>the increase in quantity sold is large enough to offset the lower price.</strong></li>
<li>富有弹性，也就是需求价格弹性（绝对值）大，价格变动一点，其需求量变动很大。</li>
<li>价格降低，消费者对其需求增大，富有弹性，说明其需求量增加的很大。当其需求量增大到收益能够大于因为价格下降而带来的损失时，卖家总收益就会增加。</li>
</ul>
</li>
<li><p>46.If the cross-price elasticity of demand for goods A and B is a positive value, this means the two goods are:</p>

<ul>
<li><strong>substitutes</strong></li>
<li>交叉需求价格弹性=一个商品需求量变动百分比/另外一种商品变动百分比</li>
<li>反映的是两种商品这种关系，如果其中一个是正数，说明一种商品价格升高，另一种商品的需求量增大，这是替代品的特征</li>
</ul>
</li>
<li><p>47.If you expect the economy is going to boom and average income in the economy will rise in the foreseeable future, the type of firm that would be able to increase its sales if your expectations are
met is:</p>

<ul>
<li><strong>one that sells a luxury good.</strong></li>
<li>奢侈品在人们收入增加，其对奢侈品的需求就会增加</li>
</ul>
</li>
<li><p>48.An external cost is created when you:</p>

<ul>
<li><strong>litter on the side of the road.</strong></li>
<li>我们研究的市场只是涉及到买方和卖方的。如果考虑旁观者的利益，则是考虑外部性。比如：企业用煤炭，对整个社会会造成污染，如果考虑这个层面，则这个企业会带来负的外部性。会造成额外的成本。</li>
</ul>
</li>
<li><p>49.Because producers do not bear the external cost of pollution:</p>

<ul>
<li><strong>production is beyond the economically efficient level.</strong></li>
<li>由于企业一般不考虑外部性，只考虑自己的利益，而对于整个社会来说，还要考虑到外部性，所以企业的产量都是超过了社会的最佳产量，对社会带来超过社会可忍受成都的负外部性。</li>
</ul>
</li>
<li><p><img src="http://pbking1.github.com/images/econ/4.png" alt="Image of Yaktocat" /></p></li>
<li><img src="http://pbking1.github.com/images/econ/"></li>
<li>50.An efficient way to get the firm in figure 5.1 to produce what society wants is:

<ul>
<li><strong>a tax to make the firm realize the external costs it imposes on others.</strong></li>
<li>为了让企业考虑外部性，一个有效的方法就是对其征税，强制让其承担外部成本</li>
</ul>
</li>
</ul>


<h3>exam 2</h3>

<ul>
<li><p>1.Ex-President Carter’s recommendation of registering women for the draft raised an uproar around the country. One opponent of this proposal stated: &ldquo;Women are needed at home to rear the children, let the men fight the wars.&rdquo; This opponent implied that:</p>

<ul>
<li><strong>the opportunity cost associated with drafting women is higher than the opportunity cost of drafting men.</strong></li>
<li>男人在家带孩子的没有女人带的好。</li>
<li>所以女人的机会成本比较大。</li>
<li>所以女人在家带孩子比较好</li>
</ul>
</li>
<li><p>2.Which of the following accurately describes the fundamental problem at the core of all economic analysis? The fundamental problem is:</p>

<ul>
<li><strong>understanding how scarce resources are allocated among competing uses to best satisfy society’s unlimited wants.</strong></li>
<li>稀有资源的最佳分配</li>
</ul>
</li>
<li><p>3.If an individual’s demand for frozen dinners increases when the price of steak rises, we would infer that:</p>

<ul>
<li><strong>steak and frozen dinners are substitutes for this person</strong>.</li>
<li>排类价格上涨，所以人们对快餐需求增加</li>
<li>所以快餐为排雷的替代品</li>
</ul>
</li>
<li><p>4.On the New York Stock Exchange, the current price per share for stock of the Boston Celtics, a NBA basketball team, is $8.25. At that price the total quantity of shares demanded is 2,500, while the total quantity supplied for trade is 2,000. It follows that</p>

<ul>
<li><strong>there is a shortage of shares of the Boston Celtics on the stock exchange.</strong></li>
<li></li>
</ul>
</li>
<li><p>6.Suppose a political candidate in the upcoming November elections promises voters more funding for AIDS research and child care, and assures them they will not have to sacrifice any other goods or services to obtain the additional programs.</p>

<ul>
<li><strong>This may be possible if the economy has unemployed resources.</strong></li>
</ul>
</li>
<li><p>7.This year the demand for new homes increases while at the same time the supply also increases. As a result of these changes in the market for new homes you can conclude that:</p>

<ul>
<li><strong>the equilibrium number of new homes will increase.</strong></li>
</ul>
</li>
<li><p>8.Some time ago the government of China required many highly skilled technicians and scientists to engage in unskilled agricultural labor in order to develop &ldquo;proper social attitudes.&rdquo; This policy caused China to produce</p>

<ul>
<li><strong>inside its PPF.</strong></li>
</ul>
</li>
<li><p>9.Recent health studies claim that consuming a glass of wine with afternoon or evening meals significantly reduces the risk of heart disease. If people believe this new information, what is likely to occur to the short-run equilibrium in the wine market?</p>

<ul>
<li><strong>Equilibrium price and quantity will both rise due to an increase in the demand for wine.</strong></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[computer architecture 1]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/13/computer-architecture-1/"/>
    <updated>2015-02-13T14:28:43-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/13/computer-architecture-1</id>
    <content type="html"><![CDATA[<h3>charpter1</h3>

<ul>
<li><p>What is computer architecture</p>

<ul>
<li>4 classes of computers

<ul>
<li>personal computer</li>
<li>server computer</li>
<li>embedded computer</li>
<li>supercomputer
<!--more--></li>
</ul>
</li>
<li><p>What does “PostPC era” mean</p>

<ul>
<li>personal mobile device(PMD)</li>
<li>cloud computing

<ul>
<li>server are replace by cloud computing</li>
<li>Software as a Service(Saas)</li>
</ul>
</li>
<li>Portion of software run on a PMD, and a portion(part of) run in the cloud</li>
</ul>
</li>
<li><p>What factors could affect performance</p>

<ul>
<li>algorithm</li>
<li>programming language, compiler, architecture</li>
<li>processor and memory system</li>
<li>I/O system(including OS and hardware)</li>
</ul>
</li>
<li><p>Eight great ideas – Know what they mean</p>

<ul>
<li>1.design for moore&rsquo;s law</li>
<li>2.use abstraction to simplify design</li>
<li>3.make the common case fast</li>
<li>4.performance via parallelism</li>
<li>5.performance via pipelining</li>
<li>6.performance via prediction</li>
<li>7.hierarchy of memory</li>
<li>8.dependability via redundancy</li>
</ul>
</li>
</ul>
</li>
<li><p>Different levels of program code</p>

<ul>
<li>HLL &ndash;> Assembly language &ndash;> ML</li>
<li>5 components of a computer

<ul>
<li>input</li>
<li>output</li>
<li>control

<ul>
<li>tells datapath, memory, I/O what to do according to the instructions.</li>
</ul>
</li>
<li>datapath

<ul>
<li>performs the arithmetic operations</li>
</ul>
</li>
<li>memory</li>
</ul>
</li>
<li><p>input &ndash;>(control, datapath)&ndash;>output</p></li>
<li><p>What is ISA?</p>

<ul>
<li>instruction set architecture

<ul>
<li>the hardware/software interface</li>
</ul>
</li>
</ul>
</li>
<li><p>Understand “Yield” in terms of chip manufacturing?</p>

<ul>
<li>Proportion of working dies per wafer晶圆(硅半导体集成电路制作所用的硅晶片)</li>
</ul>
</li>
<li><p>Response time vs Throughput</p>

<ul>
<li>Response time

<ul>
<li>How long it takes to do one task</li>
</ul>
</li>
<li>Throughput

<ul>
<li>Total work done per unit time</li>
</ul>
</li>
</ul>
</li>
<li><p>Elapsed time vs CPU time</p>

<ul>
<li>elapsed time

<ul>
<li>wall clock time

<ul>
<li>total response time, inkling everything</li>
<li>can be used to determine the system performance</li>
</ul>
</li>
</ul>
</li>
<li>cpu time

<ul>
<li>the time that cpu spent for <strong>a given process</strong></li>
<li>can be divide into user CPU time and system CPU time</li>
</ul>
</li>
</ul>
</li>
<li><p>Know how to calculate CPU time, CPI_avg, IPC, Clock rate, Clock Cycle Time, and Performance</p>

<ul>
<li>1 cycle per second &ndash;> 1 Hz

<ul>
<li>1 GHz = 10<sup>9</sup> hz</li>
</ul>
</li>
<li>clock rate(frequency)

<ul>
<li>cycle per second</li>
</ul>
</li>
<li>clock cycle time(period)

<ul>
<li>duration of a clock cycle</li>
</ul>
</li>
<li>CPU time

<ul>
<li>CPU time = CPU clock cycle * clock cycle time = CPU Clock cycle / Clock Rate</li>
</ul>
</li>
<li>Instruction count

<ul>
<li>determine by program, ISA, compiler</li>
</ul>
</li>
<li>Average cycle per instruction(CPI)

<ul>
<li>IPC = 1/CPI</li>
</ul>
</li>
<li>Clock Cycle = Instruction * Average Cycle per instruction</li>
<li>CPU time = Instruction * CPI * Clock Cycle Time

<ul>
<li>= Instruction Count * CPI / Clock Rate</li>
<li>= Instruction Count / (Clock Rate * IPC)</li>
<li>= (Instruction/program) * (Cycles/Instruction) * (Seconds/Cycle)</li>
<li>= IC * PCI * CC</li>
</ul>
</li>
<li>Clock Cycles = sum(CPI * Instruction Count)</li>
<li>how to measure performance

<ul>
<li>use instruction/second

<ul>
<li>so we can use the format clock rate/CPI</li>
</ul>
</li>
</ul>
</li>
<li>Performance depends on

<ul>
<li>Algorithm:affects IC, CPI</li>
<li>programming language: affects IC, CPI</li>
<li>Compiler:affects IC, CPI</li>
<li>ISA:affects IC, CPI, CC</li>
</ul>
</li>
<li>if you want an improvement in the execution time

<ul>
<li>you need to deduce the percentage of old time

<ul>
<li>for example

<ul>
<li>if you want to improve 50%, then you should use (100%-50%)=50% rather than (100% + 50%) = 150%</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>speed up

<ul>
<li>use the (old execute time) / (new execute time)

<ul>
<li>old time = old instruction count * old average cycle per instruction / clock rate</li>
<li>new time = new instruction count * new average cycle per instruction / clock rate

<ul>
<li>old time / new time = old instruction count * old average cycle per instruction / (new instruction count * new average cycle per instruction)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Could explain why “Power Wall” is a problem?</p>

<ul>
<li><p>situation</p>

<ul>
<li>can not reduce voltage further, and will make transistor more leaky</li>
</ul>
</li>
<li><p>Power = Capacitive Load * Voltage * Frequency</p></li>
<li><p>Understand what are the challenges on multicore processors</p>

<ul>
<li>Multicore processors: more than one core per chip</li>
<li>Hard to do

<ul>
<li>Programming for performance (not only for correctness)</li>
<li>Load balancing</li>
<li>Optimizing communication and synchronization</li>
</ul>
</li>
</ul>
</li>
<li><p>Fallacies and Pitfalls</p>

<ul>
<li>Fallacy: Some commonly held misconceptions that you might encounter

<ul>
<li>Computers at low utilization use little bit power</li>
<li>Designing for performance and designing for energy efficiency are unrelated</li>
</ul>
</li>
<li>PiGall: easily made mistakes

<ul>
<li> They are only true in a limited context</li>
<li>Can help you avoid making the same mistakes

<ul>
<li>example:

<ul>
<li>If you improve one aspect of a computer, then you would expect a proportional improvement in the overall performance</li>
<li>Using a subset of the performance equal on as a performance metric.</li>
<li>MIPS as a Performance Metric</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>e.g. MIPS, Amdahl’s Law, etc.</p></li>
</ul>
</li>
</ul>


<h3>chapter 2</h3>

<ul>
<li>Understand what is instruction and instruction set?

<ul>
<li>instruction set: the vocabulary of all commands understood

<ul>
<li>different computer have different instruction set</li>
</ul>
</li>
<li>instruction: words of computer&rsquo;s language</li>
<li>instruction set architecture(ISA): ISA serves as the interface between software and hardware

<ul>
<li>provide the mechanism by which software tells hardware what should be done</li>
</ul>
</li>
</ul>
</li>
<li>Differences between RISC and CISC

<ul>
<li>RISC

<ul>
<li>reduced instruction set computer</li>
<li>difference

<ul>
<li>fixed instruction lengths 32 bits</li>
<li>load store instruction sets</li>
<li>limited addressing modes</li>
<li>limited operations</li>
<li>simpler, cheaper</li>
<li>MIPS: typical of RISC ISAs</li>
</ul>
</li>
</ul>
</li>
<li>CISC

<ul>
<li>x86</li>
</ul>
</li>
</ul>
</li>
<li><p>MIPS ISA</p>

<ul>
<li><p>MIPS has a number 32 32-bit registers</p>

<ul>
<li>32 bit data called a word</li>
<li>memory is byte addressed

<ul>
<li>each address identifies a byte</li>
</ul>
</li>
<li>MIPS is big endian</li>
</ul>
</li>
<li><p>R and I types of instruction format</p>

<ul>
<li>R-format

<ul>
<li><code>op(6 bits)-rs(5 bits)-rt(5 bits)-rd(5 bits)-shamt(5 bits)-funct(6 bits)</code></li>
<li>add, sub</li>
</ul>
</li>
<li>I-format

<ul>
<li><code>op(6 bits)-rs(5 bits)-rt(5 bits)-constant or offset address(16 bits)</code></li>
<li>addi, lw, sw, beq, bne</li>
</ul>
</li>
</ul>
</li>
<li><p>Big endian, little endian</p>

<ul>
<li>little endian: <strong>least</strong> significant byte store at least-address of memory</li>
<li>big endian: <strong>Most</strong> significant byte store at least-address of memory</li>
</ul>
</li>
<li> Memory alignment

<ul>
<li>although computer are byte-addressable</li>
<li>memory typically organised in n-byte lines</li>
<li><strong>only the char[N] are the same in both big endian and little endian</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>How to represent unsigned and signed integers</p>

<ul>
<li>What is 2s-complement, how, why

<ul>
<li>Most-negative: 1000 0000 &hellip; 0000</li>
<li>Most-positive: 0111 1111 &hellip; 1111</li>
<li>Bit 31 is called “sign bit”</li>
<li>求负：取反加一</li>
</ul>
</li>
</ul>
</li>
<li><p>Sign extension</p>

<ul>
<li>leading bit = 1 &ndash;> negative</li>
<li>range

<ul>
<li>–2,147,483,648t o +2,147,483,647</li>
</ul>
</li>
<li>Sign extension: replicate the sign bit to the left</li>
<li>2<sup>31</sup> &ndash; 1 = 0x7FFFFFFF</li>
<li>-2<sup>31</sup> = 0x80000000</li>
<li>overflow problem

<ul>
<li>for add instruciton

<ul>
<li>128 + x > 2<sup>31</sup> &ndash; 1 the upper bound</li>
<li>128 + x &lt; -2<sup>31</sup> the lower bound</li>
</ul>
</li>
<li>so if you want to overflow, you need to bigger than 2<sup>31</sup> &ndash; 1 and smaller than -2<sup>31</sup></li>
</ul>
</li>
</ul>
</li>
<li><p>Logical operations: sll, srl, and, or, nor</p></li>
<li><p>Conditional operations: beq, bne</p>

<ul>
<li>beq: branch equal</li>
<li>bne: branch not equal</li>
</ul>
</li>
<li><p>Concept of “basic block”</p>

<ul>
<li>a basic block is a sequence of instructions with no embedded branch, no branch target</li>
</ul>
</li>
<li><p>How “Procedure calling” is supported</p>

<ul>
<li>procedure is used to structure program</li>
<li>each procedure performs a specific task</li>
<li>working like a black box</li>
</ul>
</li>
<li><p>Know jal (for calling), and jr (for return)</p>

<ul>
<li>jal procedureName

<ul>
<li>puts address of following instruction in $ra</li>
<li>jump to target address</li>
<li>procedure call</li>
</ul>
</li>
<li>jr $ra

<ul>
<li>jump-register</li>
<li>copy $ra to PC</li>
<li>procedure return</li>
</ul>
</li>
</ul>
</li>
<li><p>Understand the fact(n) assembly example</p></li>
<li><p>The memory layout of a program</p></li>
<li><p>J-type instruction format, e.g., j and jal</p>

<ul>
<li><code>op(6 bits)-instruction address(26 bits)</code></li>
</ul>
</li>
<li><p>Know how to calculate the target of PC-relative addressing, and target of (pseudo) direct jump addressing</p>

<ul>
<li>target address = PC + offset * 4</li>
<li>pseudo instructions: not real instruction

<ul>
<li>move $t0, $t1 &ndash;> add $t0, $zero, $t1</li>
<li>blt $t0, $t1, L &ndash;> slt $at, $t0, $t1

<ul>
<li> bne $at, $zero, L</li>
</ul>
</li>
<li>$at : assembler temporary</li>
</ul>
</li>
</ul>
</li>
<li><p>Hardware synchronisation instructions</p>

<ul>
<li><p>ll rt, offset(rs)</p>

<ul>
<li>load linked</li>
</ul>
</li>
<li><p>sc rt, offset(rs)</p>

<ul>
<li>store conditional</li>
</ul>
</li>
<li>rt is both input and output</li>
</ul>
</li>
<li><p>Know what information is stored in object modules</p>

<ul>
<li>the assembler translate program into <strong>machine instructions</strong> which are stored in object modules</li>
</ul>
</li>
<li><p>Know what are Compiler, Assembler, Linker, Loader used for?</p>

<ul>
<li>C program compile through compiler</li>
<li>the compiler come up with assembly language program</li>
<li>then assembler generate object(Machine language module)</li>
<li>object(machine language module and library routine) go to linker</li>
<li>the linker static link and generate executable machine language program</li>
<li>then go to loader and load into memory</li>
</ul>
</li>
<li><p>A few fallacies and pithalls</p>

<ul>
<li>instruction count and CPI are not good performance indicators in isolation</li>
<li>compiler optimisation are sensitive to algorithm</li>
<li>java compiled code s significantly faster than JVM interpreted</li>
<li>nothing can fix a dumb algorithm</li>
<li>use assembly code for high performance</li>
<li>powerful instruction &ndash;> high performance</li>
<li>importance of binary compatibility => instruction set does not change</li>
<li>sequential words are at sequential byte addresses

<ul>
<li>increment by 4</li>
</ul>
</li>
<li>using a pointer to an automatic variable outside its defining procedure

<ul>
<li>e.g passing pointer back via returning result

<ul>
<li>because pointer becomes invalid when stack popped</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MIPS instruction</p></li>
<li><table>
<thead>
<tr>
<th>MIPS instructions </th>
<th> Name </th>
<th> format</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>add</td>
<td>R</td>
</tr>
<tr>
<td>subtract</td>
<td>sub</td>
<td>R</td>
</tr>
<tr>
<td>add immediate</td>
<td>addi</td>
<td>I</td>
</tr>
<tr>
<td>load word</td>
<td>lw</td>
<td>I</td>
</tr>
<tr>
<td>store word </td>
<td> sw </td>
<td> I</td>
</tr>
<tr>
<td>load half </td>
<td> lh </td>
<td> I</td>
</tr>
<tr>
<td>load half unsigned </td>
<td> lhu </td>
<td> I</td>
</tr>
<tr>
<td>store half </td>
<td> sh </td>
<td> I</td>
</tr>
<tr>
<td>load byte </td>
<td> lb </td>
<td>  I </td>
</tr>
<tr>
<td>load byte unsigned</td>
<td> lbu </td>
<td> I</td>
</tr>
<tr>
<td>store byte </td>
<td> sb </td>
<td> I</td>
</tr>
<tr>
<td>load linked </td>
<td> ll </td>
<td> I</td>
</tr>
<tr>
<td>store conditional </td>
<td> sc </td>
<td> I</td>
</tr>
<tr>
<td>load upper immediate </td>
<td> lui </td>
<td> I</td>
</tr>
<tr>
<td>and </td>
<td> and </td>
<td> R</td>
</tr>
<tr>
<td>or </td>
<td> or </td>
<td> R</td>
</tr>
<tr>
<td>nor </td>
<td> nor </td>
<td> R</td>
</tr>
<tr>
<td>and immediate </td>
<td> andi </td>
<td> I</td>
</tr>
<tr>
<td>or immediate </td>
<td> ori </td>
<td> I</td>
</tr>
<tr>
<td>shift left logical </td>
<td> all </td>
<td> R</td>
</tr>
<tr>
<td>shift right logical </td>
<td> srl </td>
<td> R</td>
</tr>
<tr>
<td>branch on equal </td>
<td> beq </td>
<td> I</td>
</tr>
<tr>
<td>branch on not equal </td>
<td> bne </td>
<td> I</td>
</tr>
<tr>
<td>set less than </td>
<td> slt </td>
<td> R</td>
</tr>
<tr>
<td>set less than immediate  </td>
<td> slti </td>
<td> I</td>
</tr>
<tr>
<td>set less than immediate unsigned</td>
<td> sltiu </td>
<td> I</td>
</tr>
<tr>
<td>jump </td>
<td> j </td>
<td> J</td>
</tr>
<tr>
<td>jump register </td>
<td> jr </td>
<td> R</td>
</tr>
<tr>
<td>jump and link </td>
<td> jal </td>
<td> J</td>
</tr>
</tbody>
</table>
</li>
<li><p>thus we can see that R instruction contain the kind</p>

<ul>
<li>add, sub, and, or , nor, slt, shift, jump register, move, multi</li>
</ul>
</li>
<li>the I instruction contain

<ul>
<li>contain the load, store, immediate command, branch</li>
</ul>
</li>
<li><p>J instruction only have j and jal</p></li>
<li><p>汇编代码示例</p>

<ul>
<li>1.<code>if (i == j) f = g + h; else f = g - h</code>

<ul>
<li>beq $s3, $s4, Then</li>
<li>sub $s0, $s1, $s2</li>
<li>J Exit</li>
<li>Then: add $s0, $s1, $s2</li>
<li>Exit: &hellip;</li>
</ul>
</li>
<li>2.<code>while(array[i] == k) i+=1</code>

<ul>
<li>Loop:sll $t1, $s3, 2 //t1 = i * 4</li>
<li>add $t1, $t1, $s6</li>
<li>lw $t0, $t1</li>
<li>beq $s5, $t0, EXIT</li>
<li>addi $s3, $s3, 1</li>
<li>j Loop</li>
<li>EXIT:&hellip;</li>
</ul>
</li>
<li><p>3.leaf procedure example</p>

<ul>
<li><p><code>
int leaf_example(int, g, h, i, j){
  int f;
  f = (g + h) - (i - j);
  return f;
}
</code></p></li>
<li><p>MIPS code:</p>

<ul>
<li>addi $sp, $sp, -4  //save s0 on stack</li>
<li>sw $s0, 0($sp)</li>
<li>add $t0, $a0, $a1</li>
<li>add $t1, $a2, $a3</li>
<li>sub $s0, $t0, $t1</li>
<li>add $v0, $s0, $zero   //store result</li>
<li>lw $s0, 0($sp)   //store s0</li>
<li>addi $sp, $sp, 4</li>
<li>jr $ra  //return</li>
</ul>
</li>
</ul>
</li>
<li><p> 4.no leaf procedure example</p>

<ul>
<li><p> <code>
int fact(int n){
   if(n &lt; 1){
       return 1;
   }else{
       return n * fact(n - 1);
   }
}
int main(){
   int n = 10;
   fact(n);
   printf(n);
}
</code></p></li>
<li><p> MIPS code:</p>

<ul>
<li> fact:

<ul>
<li>addi $sp, $sp, -8</li>
<li>lw $ra, 4($sp)</li>
<li>lw $a0, 0($sp)</li>
<li>slti $t0, $a0, 1  //n &lt; 1, t0 = 1</li>
<li>beq $t0, $zero, L1 //if t0 == 0(means n >= 1) go to L1</li>
<li>addi $v0, $zer0, 1</li>
<li>addi $sp, $sp, 8</li>
<li>jr $ra //return address</li>
</ul>
</li>
<li> L1:

<ul>
<li>addi $a0, $a0, -1 //n = n &ndash; 1</li>
<li>jal fact //递归</li>
<li>sw $a0, 0($sp)</li>
<li>sw $ra, 4($sp)</li>
<li>addi $sp, $sp, 8</li>
<li>multi $v0, $a0, $v0 //n*fact(n-1)</li>
<li>jr $ra  //return address</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>segment place</p>

<ul>
<li>code segment &ndash;> data segment &ndash;> heap segment &ndash;> stack segment

<h3>chapter 3</h3></li>
</ul>
</li>
<li><p>Given a logic function, know how to draw its logic gate diagram</p></li>
<li><p>Given a logic gate diagram, know how to write down its logic function</p></li>
<li>Know how a full adder is implemented</li>
<li>Know what are decoder and multiplexer and how they work</li>
<li>Understand clock, register, SRAM, DRAM

<ul>
<li>SRAM:static Random Access Memory</li>
<li>DRAM:dynamic Random Access Memory</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linkedin_api_example]]></title>
    <link href="http://pbking1.github.com/blog/2015/02/12/linkedin-api-example/"/>
    <updated>2015-02-12T14:51:14-05:00</updated>
    <id>http://pbking1.github.com/blog/2015/02/12/linkedin-api-example</id>
    <content type="html"><![CDATA[<ul>
<li>we can use the RESTFUL api to get some information in linkedin

<ul>
<li><a href="https://apigee.com/console/linkedin">https://apigee.com/console/linkedin</a>

<ul>
<li>this is a online simluator to perform RESTFUL api of linkedin</li>
</ul>
</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li>and the sample code below is using the linkedin package from thrid party

<ul>
<li>you can download the package using the following link

<ul>
<li><a href="https://pypi.python.org/pypi/python-linkedin/4.0">https://pypi.python.org/pypi/python-linkedin/4.0</a></li>
<li><a href="https://github.com/ozgur/python-linkedin">https://github.com/ozgur/python-linkedin</a></li>
</ul>
</li>
</ul>
</li>
<li>code

<ul>
<li>the following code can produce some result

<ul>
<li>but I have some problem in using the search api

<ul>
<li>application.search_profile(selectors=[{&lsquo;people&rsquo;: [&lsquo;first-name&rsquo;, &lsquo;last-name&rsquo;]}], params={&lsquo;keywords&rsquo;: &lsquo;apple microsoft&rsquo;})</li>
</ul>
</li>
<li>Search URL is &lsquo;<a href="https://api.linkedin.com/v1/people-search:">https://api.linkedin.com/v1/people-search:</a>(people:(first-name,last-name))?keywords=apple%20microsoft&rsquo;</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /usr/bin/env python
</span><span class='line'># -*- coding: utf-8 -*-
</span><span class='line'>
</span><span class='line'>CONSUMER_KEY = 'xxxxxxx'     # This is api_key
</span><span class='line'>CONSUMER_SECRET = 'xxxxxxx'   # This is secret_key
</span><span class='line'>
</span><span class='line'>USER_TOKEN = 'xxxxxxx'   # This is oauth_token
</span><span class='line'>USER_SECRET = 'xxxxxxx'   # This is oauth_secret
</span><span class='line'>RETURN_URL = 'http://localhost:8000'
</span><span class='line'>
</span><span class='line'>from linkedin import linkedin
</span><span class='line'>from oauthlib import *
</span><span class='line'>from urllib2 import *
</span><span class='line'>import urllib2
</span><span class='line'>from json import dumps, loads
</span><span class='line'># Define CONSUMER_KEY, CONSUMER_SECRET,  
</span><span class='line'># USER_TOKEN, and USER_SECRET from the credentials 
</span><span class='line'># provided in your LinkedIn application
</span><span class='line'>
</span><span class='line'># Instantiate the developer authentication class
</span><span class='line'>authentication = linkedin.LinkedInDeveloperAuthentication(CONSUMER_KEY, CONSUMER_SECRET, 
</span><span class='line'>                                                      USER_TOKEN, USER_SECRET, 
</span><span class='line'>                                                      RETURN_URL, linkedin.PERMISSIONS.enums.values())
</span><span class='line'>
</span><span class='line'># Pass it in to the app...
</span><span class='line'>application = linkedin.LinkedInApplication(authentication)
</span><span class='line'>
</span><span class='line'>print application.get_profile()
</span><span class='line'>
</span><span class='line'>print application.get_profile(selectors=['id', 'first-name', 'last-name', 'location', 'distance', 'num-connections', 'skills', 'educations'])
</span><span class='line'>
</span><span class='line'>print application.search_company(selectors=[{'companies': ['name', 'universal-name', 'website-url']}], params={'keywords': 'apple microsoft'})
</span><span class='line'># Search URL is https://api.linkedin.com/v1/company-search:(companies:(name,universal-name,webs
</span><span class='line'>
</span><span class='line'>print application.get_memberships(params={'count': 20})
</span><span class='line'>
</span><span class='line'>print application.get_companies(company_ids=[1035], universal_names=['apple'], selectors=['name'], params={'is-company-admin': 'true'})
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
